{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","path":"medias/icp.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/minivaline/MiniValine.js","path":"libs/minivaline/MiniValine.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.jpg","path":"medias/reward/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"b597b314c8d9c36e57e70429bfa47fc80dd6e48c","modified":1604680716000},{"_id":"source/404.md","hash":"d8941d95ca8cfbefd576e208b21116cdb53fee86","modified":1604680716000},{"_id":"source/about/index.md","hash":"62b987b668fad13660eceaff94a27f2775546fc3","modified":1604680716000},{"_id":"source/contact/index.md","hash":"2f22502b0520b602039e6dadad4ea05e6e64eef0","modified":1604680718000},{"_id":"source/categories/index.md","hash":"d2c19f828080831a45384f02ba98ff8296e0926e","modified":1604680716000},{"_id":"source/friends/index.md","hash":"dc711c8657f90e1347ff6ea5e04dc8caf1b67488","modified":1604680718000},{"_id":"source/_posts/CV/目标检测中的评价函数.md","hash":"6bfef2c315fe3402ad3216b1aaadce58985e91f8","modified":1607949175118},{"_id":"source/friends/_data/friends.json","hash":"1ff9c14db72e3325535faea03797d16e6707e85a","modified":1604906799811},{"_id":"source/_posts/Deepstream/DeepStream5.0结合OpenCV4实现视频的分析和截图.md","hash":"843f02971a5276826fd9bd20163292b27b0c7a02","modified":1607949184604},{"_id":"source/tags/index.md","hash":"14d0aaba581fb3c3bd133f5a7f884fbeb50e7ed5","modified":1604680720000},{"_id":"themes/hexo-theme-matery/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1604680840000},{"_id":"themes/hexo-theme-matery/README.md","hash":"56299cf1fe60a11fef61b3948fe148f995df747e","modified":1604680862000},{"_id":"themes/hexo-theme-matery/README_CN.md","hash":"011ed6522859e600c27ea6dce9591fbc447db177","modified":1604680862000},{"_id":"themes/hexo-theme-matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1604680862000},{"_id":"themes/hexo-theme-matery/languages/default.yml","hash":"54ccc01b097c5bf6820f0edfcece1a87b78ab32d","modified":1604680842000},{"_id":"themes/hexo-theme-matery/_config.yml","hash":"7cc94695736bebb971055c22267e8e89fe8d3291","modified":1604921844869},{"_id":"themes/hexo-theme-matery/languages/zh-CN.yml","hash":"a957b05f70265a86a87d922e18488571809d2472","modified":1604680842000},{"_id":"themes/hexo-theme-matery/languages/zh-HK.yml","hash":"ae34ac0e175c3037675722e436637efbceea32f0","modified":1604680842000},{"_id":"themes/hexo-theme-matery/layout/404.ejs","hash":"9c8ca67377211e5d60fdde272a975faa9a91a22a","modified":1604680842000},{"_id":"themes/hexo-theme-matery/layout/about.ejs","hash":"41849f9300b8dc47048333fcf4a897dd8a2a13ca","modified":1604680842000},{"_id":"themes/hexo-theme-matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1604680842000},{"_id":"themes/hexo-theme-matery/layout/category.ejs","hash":"00019bca11fb46477f22017cb1f5ad8444da0580","modified":1604680844000},{"_id":"themes/hexo-theme-matery/layout/contact.ejs","hash":"19d62e521c4253496db559478db5164ddfd2480e","modified":1604680844000},{"_id":"themes/hexo-theme-matery/layout/friends.ejs","hash":"f5d6459bed0f4ecb214f2dbff5b2207a80c44f66","modified":1604680844000},{"_id":"themes/hexo-theme-matery/layout/archive.ejs","hash":"cdac701de8370f9f3794a0eed4165983993a1ca7","modified":1604680842000},{"_id":"themes/hexo-theme-matery/layout/layout.ejs","hash":"c7453d5b064d42529e8c9fdef52d0901d51acb9b","modified":1604680844000},{"_id":"themes/hexo-theme-matery/layout/index.ejs","hash":"4dc6f08e7709cc04e886be72dbf0d06469f0effc","modified":1604680844000},{"_id":"themes/hexo-theme-matery/layout/post.ejs","hash":"90b5a4c1f70e4756db569c15a7c6cad0c77c4500","modified":1604680844000},{"_id":"themes/hexo-theme-matery/layout/tag.ejs","hash":"85a4b05bd8a6ad0f17ff2e97dae56949b379c204","modified":1604680844000},{"_id":"themes/hexo-theme-matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1604680846000},{"_id":"themes/hexo-theme-matery/source/favicon.png","hash":"3eca625a89b837e218c6749fd3c1ae2e3586b8d0","modified":1604683806000},{"_id":"themes/hexo-theme-matery/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1604680846000},{"_id":"themes/hexo-theme-matery/layout/_partial/background.ejs","hash":"aef6edeeb11209831a11d8c7f5d59992e2573335","modified":1604680846000},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1604680846000},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1604680846000},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover-content.ejs","hash":"28617bf2a35a4269eba6df466acd174e416d2d1e","modified":1604680846000},{"_id":"themes/hexo-theme-matery/layout/_partial/changyan.ejs","hash":"cd919d31564e118c2ee8d5cbfb7d51ee6da15d82","modified":1604680848000},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1604680848000},{"_id":"themes/hexo-theme-matery/layout/_partial/footer.ejs","hash":"3be24e4c370671eda53bdfd99fb748f4a22948ba","modified":1604680848000},{"_id":"themes/hexo-theme-matery/layout/_partial/disqus.ejs","hash":"b2dc2c8b5ed56815e55cc2ea54a6dc4eeba2375d","modified":1604680848000},{"_id":"themes/hexo-theme-matery/layout/_partial/gitalk.ejs","hash":"2aa8fbb04b046fa7679092a48372d7e036835dff","modified":1604680848000},{"_id":"themes/hexo-theme-matery/layout/_partial/gitment.ejs","hash":"90f6218512ef2eab63ada7ad2fc766ae635a2297","modified":1604680848000},{"_id":"themes/hexo-theme-matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1604680848000},{"_id":"themes/hexo-theme-matery/layout/_partial/head.ejs","hash":"f8438ac80df005934a330b029de292d26f0b6ecb","modified":1604680850000},{"_id":"themes/hexo-theme-matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1604680850000},{"_id":"themes/hexo-theme-matery/layout/_partial/header.ejs","hash":"59e38c70f3d8e7165e686e5e84a627835f4321b0","modified":1604680850000},{"_id":"themes/hexo-theme-matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1604680850000},{"_id":"themes/hexo-theme-matery/layout/_partial/index-cover.ejs","hash":"76b4a37e0364380b143fdf94bf1a5e6941564414","modified":1604680850000},{"_id":"themes/hexo-theme-matery/layout/_partial/minivaline.ejs","hash":"5f09386aece8f9cf31f6059bbde79cd6c5171493","modified":1604680850000},{"_id":"themes/hexo-theme-matery/layout/_partial/mobile-nav.ejs","hash":"cb0cb452be1cd1857ba600f04025b506f3b6fc79","modified":1604680850000},{"_id":"themes/hexo-theme-matery/layout/_partial/navigation.ejs","hash":"78b70ff24b3039c871331ebec114b936c1756cc8","modified":1604680852000},{"_id":"themes/hexo-theme-matery/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1604680852000},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail-toc.ejs","hash":"a0de13cde718c7951cbf8eff809e76538e32e8e2","modified":1604680852000},{"_id":"themes/hexo-theme-matery/layout/_partial/post-cover.ejs","hash":"d1c873c5de54498c722e155aadb8c0ec39485dfa","modified":1604680852000},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail.ejs","hash":"655ea63374186a1d5230648f70ab4d327bb663bb","modified":1604680854000},{"_id":"themes/hexo-theme-matery/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1604680854000},{"_id":"themes/hexo-theme-matery/layout/_partial/prev-next.ejs","hash":"c76b78782ea82340104fccc089417572e0adece4","modified":1604680854000},{"_id":"themes/hexo-theme-matery/layout/_partial/reward.ejs","hash":"ffc55bc7e73bc698bfc58d8e3780c336b83282cf","modified":1604680854000},{"_id":"themes/hexo-theme-matery/layout/_partial/search.ejs","hash":"81eca110e533693a5369c0cc9106bf0f0432ee37","modified":1604680854000},{"_id":"themes/hexo-theme-matery/layout/_partial/share.ejs","hash":"c941730a2471d6aab367cbb6e09ed08b56c83143","modified":1604680854000},{"_id":"themes/hexo-theme-matery/layout/_partial/social-link.ejs","hash":"6f871bd3a70f720e4e451f1f4f625cbc6d8994a4","modified":1604680856000},{"_id":"themes/hexo-theme-matery/layout/_partial/reprint-statement.ejs","hash":"0ce3f9361f558b99cc2f059c5e50b0e2a152ae38","modified":1604680854000},{"_id":"themes/hexo-theme-matery/layout/_partial/valine.ejs","hash":"0e4c0a6154aa34007849928ca88f05b6185b256e","modified":1604680856000},{"_id":"themes/hexo-theme-matery/layout/_widget/artitalk.ejs","hash":"b14e486f12b9ac42a273b80e4d785fcb94cf04b2","modified":1604680856000},{"_id":"themes/hexo-theme-matery/layout/_widget/category-cloud.ejs","hash":"1b3df1009234c0112424b497b18b4ad8240b3bc7","modified":1604680856000},{"_id":"themes/hexo-theme-matery/layout/_widget/category-radar.ejs","hash":"1d8747fda89a0b2ca3c7008867cbfeecad0578a6","modified":1604680856000},{"_id":"themes/hexo-theme-matery/layout/_widget/dream.ejs","hash":"9a472ad5591100cdb65d0df9d01034163bd6dd9d","modified":1604680856000},{"_id":"themes/hexo-theme-matery/layout/_widget/music.ejs","hash":"e9e3e327d5de9d7aeadbde32e1d558652d9e9195","modified":1604680858000},{"_id":"themes/hexo-theme-matery/layout/_widget/my-gallery.ejs","hash":"65a2d2f9722f84c7fd98f6bdf79087a14848ebd8","modified":1604680860000},{"_id":"themes/hexo-theme-matery/layout/_widget/my-projects.ejs","hash":"ef60b64021fa349b0048425d858dfcf6c906fede","modified":1604680860000},{"_id":"themes/hexo-theme-matery/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1604680860000},{"_id":"themes/hexo-theme-matery/layout/_widget/post-calendar.ejs","hash":"48821e644bc73553d7c5c56d2e8ee111a70cd776","modified":1604680860000},{"_id":"themes/hexo-theme-matery/layout/_widget/post-charts.ejs","hash":"ab5f986f428215941aeaa0c88aefd440c47d3bcf","modified":1604680860000},{"_id":"themes/hexo-theme-matery/layout/_widget/recommend.ejs","hash":"8551137e94ca4e2e3b8b63d5626255884cb60cb5","modified":1604680860000},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1604680860000},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-wordcloud.ejs","hash":"487aacb2454d6bf0d21cdb07ddd1fd5ddbca9038","modified":1604680860000},{"_id":"themes/hexo-theme-matery/layout/_widget/video.ejs","hash":"a0e002377af2a7f7e4da6d9a644de97adb035925","modified":1604680862000},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1604680864000},{"_id":"themes/hexo-theme-matery/source/css/matery.css","hash":"b53f4b6b7b2d992c904a9bf98b504fba247b220e","modified":1604680864000},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1604680864000},{"_id":"themes/hexo-theme-matery/source/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1604680864000},{"_id":"themes/hexo-theme-matery/source/js/search.js","hash":"e1482406c58ea2a0eb178d7e4efb2c879cdddc80","modified":1604680866000},{"_id":"themes/hexo-theme-matery/source/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1604680866000},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","hash":"3912519a271c37bbee30968269bb08be0cdfeb5a","modified":1604682658000},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1604680930000},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1604680946000},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","hash":"a07cb5618233f89660f3a42b7eddd8daf6a6ad7f","modified":1604681950000},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1604680866000},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1604680868000},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1604680868000},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1604680896000},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1604680896000},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1604680896000},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1604680896000},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1604680868000},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1604680898000},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1604680898000},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1604680898000},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1604680868000},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1604680898000},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1604680898000},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1604680906000},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1604680906000},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1604680908000},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1604680908000},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1604680900000},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1604680908000},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1604680912000},{"_id":"themes/hexo-theme-matery/source/libs/minivaline/MiniValine.js","hash":"fbb58c37e2c74f127ae0c566afa9b48889aab79f","modified":1604680916000},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1604680916000},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1604680916000},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1604680916000},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1604680920000},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1604680920000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1604680934000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1604680934000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1604680936000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1604680936000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1604680938000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1604680942000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1604680942000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1604680942000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1604680942000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1604680944000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1604680944000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1604680944000},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.jpg","hash":"a701f6e6873b4c66dfdb22d6748637b645b7cf35","modified":1604682332000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1604680886000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1604680884000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1604680888000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1604680886000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1604680910000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1604680910000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1604680910000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1604680910000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1604680910000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1604680912000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1604680912000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1604680912000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1604680912000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1604680912000},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1604680918000},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1604680918000},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1604680918000},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1604680918000},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1604680918000},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1604680920000},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1604680918000},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1604680908000},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1604680900000},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1604680910000},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1604680922000},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1604680922000},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1604680926000},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1604680926000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1604680932000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1604680932000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1604680934000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1604680934000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1604680936000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1604680936000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1604680938000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1604680938000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1604680940000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1604680942000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1604680944000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1604680946000},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","hash":"522ed48c71a6099383fc48a5ea78b21e55611630","modified":1604682346000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1604680870000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1604680884000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1604680884000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1604680884000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1604680896000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1604680896000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1604680870000},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1604680932000},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1604680906000},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1604680914000},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1604680916000},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1604680922000},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1604680924000},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1604680928000},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1604680930000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1604680886000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1604680888000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1604680894000},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1604680928000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1604680882000},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1604680904000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1604680894000},{"_id":"public/atom.xml","hash":"35fdae5442d0be49f82413b6a02a920c7a68cf8a","modified":1607949476015},{"_id":"public/search.xml","hash":"c6f002113e6d581607fc8ebcef87e62d9816a2d7","modified":1607949476015},{"_id":"public/404.html","hash":"be6792bebfb6eaa2aeb25658c488fc80b57fe0ab","modified":1604927853935},{"_id":"public/categories/index.html","hash":"2703196c9bae4e850a44f0ce89ff5fffef04216d","modified":1607949102580},{"_id":"public/about/index.html","hash":"9124d4df797a676f8d23d0f4641a29f992d423cf","modified":1607949476015},{"_id":"public/contact/index.html","hash":"5283f05a039997960daf950c943fba5b9f57af1e","modified":1604927853935},{"_id":"public/friends/index.html","hash":"71add5aac6eb86f166566f2926b199d8df86033d","modified":1604927853935},{"_id":"public/tags/index.html","hash":"7422293c19168f563dbeba9060d75f981848c1bc","modified":1607949102580},{"_id":"public/2020/07/15/cv/mu-biao-jian-ce-zhong-de-ping-jie-han-shu/index.html","hash":"60e301aa7ce033fb15832890cc1f1ab7fbba145d","modified":1607949476015},{"_id":"public/2020/05/15/deepstream/deepstream5.0-jie-he-opencv4-shi-xian-shi-pin-de-fen-xi-he-jie-tu/index.html","hash":"e5bceb72b72d3314b0b17310527e3cfcfa509a31","modified":1607949191914},{"_id":"public/categories/CV/index.html","hash":"18920c98c05b9f996eb0f329c317d07200a25c0a","modified":1607949102580},{"_id":"public/categories/视频分析/index.html","hash":"9c611464fde6b2c0311ca29f00d09ed995cd38e9","modified":1607949102580},{"_id":"public/archives/index.html","hash":"27afa8a0da6d6f0300d4f3a1cce7eafcea7232c8","modified":1607949476015},{"_id":"public/archives/2020/index.html","hash":"e03bc426aa5805c1a1341775e752b0494bb8687a","modified":1607949476015},{"_id":"public/archives/2020/05/index.html","hash":"5e5d091edb0a43e1b6197f7d842c287c116123b1","modified":1607949476015},{"_id":"public/archives/2020/07/index.html","hash":"79ef28ac2df4d6d7197ffda2d3aa9e32ad1ec5c0","modified":1607949476015},{"_id":"public/index.html","hash":"7ac67931417ee58011ea0b8cd9628c95a8227f6b","modified":1607949476015},{"_id":"public/tags/CV/index.html","hash":"b353eadac36948f9b2f3c0a18e1bad107b788bd6","modified":1607949102580},{"_id":"public/tags/目标检测/index.html","hash":"10ab7bc05370c6edb05c63b8e3760c53f3ad009f","modified":1607949102580},{"_id":"public/tags/视频分析/index.html","hash":"a10da3c47d2d04000593b6459e6ea6191461aa0e","modified":1607949102580},{"_id":"public/tags/DeepStream/index.html","hash":"a61cddea11bcdd52bd949b5a474a2a430d555182","modified":1607949102580},{"_id":"public/CNAME","hash":"b597b314c8d9c36e57e70429bfa47fc80dd6e48c","modified":1604927853935},{"_id":"public/medias/avatar.jpg","hash":"3912519a271c37bbee30968269bb08be0cdfeb5a","modified":1604927853935},{"_id":"public/favicon.png","hash":"3eca625a89b837e218c6749fd3c1ae2e3586b8d0","modified":1604927853935},{"_id":"public/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1604927853935},{"_id":"public/medias/logo.png","hash":"a07cb5618233f89660f3a42b7eddd8daf6a6ad7f","modified":1604927853935},{"_id":"public/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1604927853935},{"_id":"public/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1604927853935},{"_id":"public/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1604927853935},{"_id":"public/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1604927853935},{"_id":"public/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1604927853935},{"_id":"public/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1604927853935},{"_id":"public/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1604927853935},{"_id":"public/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1604927853935},{"_id":"public/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1604927853935},{"_id":"public/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1604927853935},{"_id":"public/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1604927853935},{"_id":"public/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1604927853935},{"_id":"public/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1604927853935},{"_id":"public/medias/reward/wechat.jpg","hash":"a701f6e6873b4c66dfdb22d6748637b645b7cf35","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1604927853935},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1604927853935},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1604927853935},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1604927853935},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1604927853935},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1604927853935},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1604927853935},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1604927853935},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1604927853935},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1604927853935},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1604927853935},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1604927853935},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1604927853935},{"_id":"public/css/prism-tomorrow.css","hash":"3b99487dfc9b4e51e9105a93743b92a761840e34","modified":1604927853935},{"_id":"public/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1604927853935},{"_id":"public/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1604927853935},{"_id":"public/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1604927853935},{"_id":"public/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1604927853935},{"_id":"public/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1604927853935},{"_id":"public/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1604927853935},{"_id":"public/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1604927853935},{"_id":"public/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1604927853935},{"_id":"public/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1604927853935},{"_id":"public/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1604927853935},{"_id":"public/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1604927853935},{"_id":"public/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1604927853935},{"_id":"public/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1604927853935},{"_id":"public/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1604927853935},{"_id":"public/medias/reward/alipay.jpg","hash":"522ed48c71a6099383fc48a5ea78b21e55611630","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1604927853935},{"_id":"public/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1604927853935},{"_id":"public/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1604927853935},{"_id":"public/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1604927853935},{"_id":"public/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1604927853935},{"_id":"public/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1604927853935},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1604927853935},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1604927853935},{"_id":"public/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1604927853935},{"_id":"public/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1604927853935},{"_id":"public/js/search.js","hash":"e1482406c58ea2a0eb178d7e4efb2c879cdddc80","modified":1604927853935},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1604927853935},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1604927853935},{"_id":"public/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1604927853935},{"_id":"public/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1604927853935},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1604927853935},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1604927853935},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1604927853935},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1604927853935},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1604927853935},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1604927853935},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1604927853935},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1604927853935},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1604927853935},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1604927853935},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1604927853935},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1604927853935},{"_id":"public/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1604927853935},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1604927853935},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1604927853935},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1604927853935},{"_id":"public/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1604927853935},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1604927853935},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1604927853935},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1604927853935},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1604927853935},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1604927853935},{"_id":"public/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1604927853935},{"_id":"public/css/matery.css","hash":"b53f4b6b7b2d992c904a9bf98b504fba247b220e","modified":1604927853935},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1604927853935},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1604927853935},{"_id":"public/libs/minivaline/MiniValine.js","hash":"fbb58c37e2c74f127ae0c566afa9b48889aab79f","modified":1604927853935},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1604927853935},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1604927853935},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1604927853935},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1604927853935},{"_id":"public/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1604927853935},{"_id":"public/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1604927853935},{"_id":"public/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1604927853935},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1604927853935},{"_id":"public/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1604927853935},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1604927853935},{"_id":"public/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1604927853935},{"_id":"public/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1604927853935},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1604927853935},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1604927853935},{"_id":"source/_posts/Communication/在C++与python间传视频帧.md","hash":"15731dd54fca788fca46cd81c457530fde74e964","modified":1606744543644},{"_id":"public/2020/11/30/communication/zai-c-yu-python-jian-chuan-shi-pin-zheng/index.html","hash":"d1bc05bd0052ddc8291c57bf74ee71218f82bf42","modified":1607949476015},{"_id":"public/archives/2020/11/index.html","hash":"57886e09f6d9e6f84598841d1c28b62c006cf968","modified":1607949476015},{"_id":"public/categories/Communication/index.html","hash":"a97f2a803aa5e9908d9a3f0a19616687376eb833","modified":1607949476015},{"_id":"public/tags/共享内存/index.html","hash":"a4c47512e276b286d5d158cae02d5d76efbfe9de","modified":1607949102580},{"_id":"public/tags/socket/index.html","hash":"6b255fcf8fa7eaed2f40f0a06c5b6d4a9bff477e","modified":1607949476015},{"_id":"source/_posts/Communication/Winsock创建socket server和client.md","hash":"259ec30ddb337b969a46664588b787d228d8ed84","modified":1607949460807},{"_id":"public/2020/11/30/communication/winsock-chuang-jian-socket-server-he-client/index.html","hash":"c57657826d94ba68a116704578c454787f69fe22","modified":1607949373499},{"_id":"public/2020/12/14/communication/winsock-chuang-jian-socket-server-he-client/index.html","hash":"d0cfc1d966e7126b6c175b2bb0d7ba2140c97e94","modified":1607949476015},{"_id":"public/archives/2020/12/index.html","hash":"55309b56d6f569ac721dc0540bdb409d55197b39","modified":1607949476015}],"Category":[{"name":"CV","_id":"ckhaklucq0008vp7e203z06vf"},{"name":"视频分析","_id":"ckhaklucs000avp7e2hi07uhl"},{"name":"Communication","_id":"cki4lrn550001z77e497rda35"}],"Data":[{"_id":"friends","data":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}],"Page":[{"title":"404","date":"2018-09-30T09:25:30.000Z","type":"404","layout":"404","description":"Oops～，我崩溃了！找不到你想要的页面 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2018-09-30 17:25:30\ntype: \"404\"\nlayout: \"404\"\ndescription: \"Oops～，我崩溃了！找不到你想要的页面 :(\"\n---","updated":"2020-11-06T16:38:36.000Z","path":"404.html","comments":1,"_id":"ckhakluca0000vp7e9in17hxs","content":"","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"categories","date":"2020-11-06T06:54:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-11-06 14:54:20\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2020-11-06T16:38:36.000Z","path":"categories/index.html","comments":1,"_id":"ckhaklucc0001vp7egd5r4kg7","content":"","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"about","date":"2020-11-06T06:55:32.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-11-06 14:55:32\ntype: \"about\"\nlayout: \"about\"\n---\n","updated":"2020-11-06T16:38:36.000Z","path":"about/index.html","comments":1,"_id":"ckhaklucc0002vp7ec2zu8l76","content":"","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"contact","date":"2020-11-06T06:55:50.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2020-11-06 14:55:50\ntype: \"contact\"\nlayout: \"contact\"\n---\n","updated":"2020-11-06T16:38:38.000Z","path":"contact/index.html","comments":1,"_id":"ckhaklucd0003vp7e7bvy9geb","content":"","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"friends","date":"2020-11-06T06:56:43.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2020-11-06 14:56:43\ntype: \"friends\"\nlayout: \"friends\"\n---\n","updated":"2020-11-06T16:38:38.000Z","path":"friends/index.html","comments":1,"_id":"ckhaklucd0004vp7e4qv2fghr","content":"","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"tags","date":"2020-11-06T06:55:10.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-11-06 14:55:10\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2020-11-06T16:38:40.000Z","path":"tags/index.html","comments":1,"_id":"ckhaklucd0005vp7e48h080gt","content":"","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}},"excerpt":"","more":""}],"Post":[{"title":"目标检测中的评价指标","date":"2020-07-15T07:56:33.000Z","author":"马捷径","img":"https://img-blog.csdnimg.cn/202007151105556.png","top":true,"cover":true,"coverImg":"https://img-blog.csdnimg.cn/202007151105556.png","toc":true,"mathjax":true,"summary":"对目标检测中AP、MAP、Precision-Recall曲线的理解，以及概念之间的关系","keywords":["AP","MAP","Precision-Recall"],"_content":"\n# 1. 问题定义\n**目标：** 预测图像中各个物体是否出现及其位置。目标检测涉及图像中物体的**定位**和**分类**。\n![目标检测任务](https://img-blog.csdnimg.cn/202007151105556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70)\n例如我们要区分出红细胞(RBC)、白细胞(WBC)和血小板(platelets)。除了需要用框(bounding box)框出物体，还需要对他们分类，标在框上。每个类别后跟着一个数字即判定为该类别的置信度。\n\n**那么如何判断那个模型好（准确）呢？**\n比如上图中绿色的框标出大部分的白细胞 ，但是有些边缘的没有标出，但是我们不能通过图片，凭直觉判断模型的好坏。我们需要一个量化指标。即直接量化每个模型在测试集中的图像、类和不同置信阈值下的表现。这个工具就是mAP。\n为了学习mAP，需要先了解几个概念。\n# 2. 几个概念\n- mAP: （Mean Average Precision）平均AP\n- AP：P-R下面积，平均精度。\n- P-R曲线：Precision-Recall曲线\n- Precision：精度，即所有检测结果中，正确（IoU>0.5）个数的占比。`TP/(TP+FP)` 。\n- Recall：召回率，即所有真实物体中被检测出来的个数占比。`TP/(TP+FN)`\n- TP：(True Positive)真正例。IoU>0.5的检测框个数，同一个Ground Truth只计算一次\n- FP：(False Positive)假正例。IoU<0.5的检测框个数，同一个GT的多余检测框也计算\n- FN：(False Negatives)假负例。GT里没有被检测到的数量。即模型漏检的物体。\n- IoU：交并比。评价边界框正确性的度量指标\n\n**一张有猫的图片中，不光要检测出猫，还要检测猫的位置正确。**\n\n# 3. Precision-Recall曲线\n可以分别用一句话区分精度Precision和召回率Recall\n>Precision : “when your model guesses how often does it guess correctly?” （模型多少次预测正确？）\n>Recall ：“has your model guessed every time that it should have guessed?” （模型应该检测到的某一物体时候是否检测到了物体？）\n\n例如上面的例子。假设一张图里有10个红细胞，模型检测到一个红细胞，并且标注位置和类别都正确，那么模型就是有**高精度**（1个红细胞的框是准确的），**低召回率**（10个只检测到1个）\n\n通过调整**阈值**可以控制召回率。具体做法要看模型需要的环境。比如当避免假真例比避免假负例更重要时（可以不都检测到，但检测到的一定要正确），可以设置高阈值。\n\n建立Precision和Recall之间的函数关系并绘制在图上，这个曲线就是**P-R曲线**。该曲线**向下倾斜的（递减）**，因为当置信度降低时，会做出更多的预测(提升召回)，而做出的预测则不那么精确(影响精度)。打个比方，当要求“说出每一种鲨鱼的名称”，你会从熟悉且肯定的说起（高精度），但是很难保证说出来的都正确（接近于高召回率，低精度）。如果PR曲线不是向下倾斜的，说明模型有问题，需要回去检测。\n![Precision和Recall](https://img-blog.csdnimg.cn/20200715152547411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70)\n\n**那么如何通过P-R曲线找到最好的阈值呢？**\n有三种思路。\n（1）斜率接近-1\n（2）计算P-R曲线下的面积（AUC，Area Under the Curve）\n（3）计算平均精度（AP，Average Precision）\n通常我们采用AP的方法。下面将开始介绍AP的计算。\n![P-R曲线理解](https://img-blog.csdnimg.cn/20200715153333755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70)\n# 4. AP\n\nVOC2010前：Recall >= 0, 0.1, 0.2, ..., 1共11个recall下precision的平均值。熟悉微积分的可以看出，下面公式的含义就是$p(r)$即precision-recall曲线下的面积。\n$$ AP = \\frac {1}{11}\\sum_{r\\in{\\lbrace 0,0.1,...,1\\rbrace}}p_{interp}(r)$$\nVOC2010后：所有数据点，而不是仅使用11个recall值来计算AP。\n$$ p_{interp}(r)=\\max_{\\hat{r}:\\hat{r}\\geq{r}}p(\\hat{r})$$\n为保证p-r曲线单调递减，对于某个recall值r，precision值取所有recall>=r中的最大值。\n\n# 5. mAP\nAP是针对一个类别的计算。所有类别的AP平均值即mAP。\n建议在分析模型结果时查看各个类的AP值。这些值也许暗示你需要添加更多的训练样本。\n例如下面的分析结果：\n\n```cpp\n// EfficientDet模型\n78.59% = Platelets AP \n77.87% = RBC AP \n96.47% = WBC AP \nmAP = 84.31%\n```\n\n```cpp\n// YOLOv3模型\n72.15% = Platelets AP \n74.41% = RBC AP \n95.54% = WBC AP \nmAP = 80.70%\n```\n表明在这一数据集上EfficientDet更精确 ，同时，对于白细胞检测比红细胞更容易。\nmAP除了分不同的IOU阈值（COCO从0.5到0.95，步长为0.05），还通常分为小、中、大三个对象，帮助识别模型(或数据集)可能出错的地方。\n\n---\n【参考】\n\n<div id=\"refer-anchor-1\"></div>\n\n[1] [Measuring Object Detection models - mAP - What is Mean Average Precision?](https://tarangshah.com/blog/2018-01-27/what-is-map-understanding-the-statistic-of-choice-for-comparing-object-detection-models/)\n<div id=\"refer-anchor-2\"></div>\n\n[2][What is Mean Average Precision (mAP) in Object Detection?](https://towardsdatascience.com/what-is-mean-average-precision-map-in-object-detection-8f893b48afd3)","source":"_posts/CV/目标检测中的评价函数.md","raw":"---\ntitle: 目标检测中的评价指标\ndate: 2020-07-15 15:56:33\nauthor: 马捷径\nimg: https://img-blog.csdnimg.cn/202007151105556.png\ntop: true\ncover: true\ncoverImg: https://img-blog.csdnimg.cn/202007151105556.png\ntoc: true\nmathjax: true\nsummary: 对目标检测中AP、MAP、Precision-Recall曲线的理解，以及概念之间的关系\nkeywords: \n  - AP \n  - MAP\n  - Precision-Recall\ncategories: CV\ntags:\n  - CV\n  - 目标检测\n---\n\n# 1. 问题定义\n**目标：** 预测图像中各个物体是否出现及其位置。目标检测涉及图像中物体的**定位**和**分类**。\n![目标检测任务](https://img-blog.csdnimg.cn/202007151105556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70)\n例如我们要区分出红细胞(RBC)、白细胞(WBC)和血小板(platelets)。除了需要用框(bounding box)框出物体，还需要对他们分类，标在框上。每个类别后跟着一个数字即判定为该类别的置信度。\n\n**那么如何判断那个模型好（准确）呢？**\n比如上图中绿色的框标出大部分的白细胞 ，但是有些边缘的没有标出，但是我们不能通过图片，凭直觉判断模型的好坏。我们需要一个量化指标。即直接量化每个模型在测试集中的图像、类和不同置信阈值下的表现。这个工具就是mAP。\n为了学习mAP，需要先了解几个概念。\n# 2. 几个概念\n- mAP: （Mean Average Precision）平均AP\n- AP：P-R下面积，平均精度。\n- P-R曲线：Precision-Recall曲线\n- Precision：精度，即所有检测结果中，正确（IoU>0.5）个数的占比。`TP/(TP+FP)` 。\n- Recall：召回率，即所有真实物体中被检测出来的个数占比。`TP/(TP+FN)`\n- TP：(True Positive)真正例。IoU>0.5的检测框个数，同一个Ground Truth只计算一次\n- FP：(False Positive)假正例。IoU<0.5的检测框个数，同一个GT的多余检测框也计算\n- FN：(False Negatives)假负例。GT里没有被检测到的数量。即模型漏检的物体。\n- IoU：交并比。评价边界框正确性的度量指标\n\n**一张有猫的图片中，不光要检测出猫，还要检测猫的位置正确。**\n\n# 3. Precision-Recall曲线\n可以分别用一句话区分精度Precision和召回率Recall\n>Precision : “when your model guesses how often does it guess correctly?” （模型多少次预测正确？）\n>Recall ：“has your model guessed every time that it should have guessed?” （模型应该检测到的某一物体时候是否检测到了物体？）\n\n例如上面的例子。假设一张图里有10个红细胞，模型检测到一个红细胞，并且标注位置和类别都正确，那么模型就是有**高精度**（1个红细胞的框是准确的），**低召回率**（10个只检测到1个）\n\n通过调整**阈值**可以控制召回率。具体做法要看模型需要的环境。比如当避免假真例比避免假负例更重要时（可以不都检测到，但检测到的一定要正确），可以设置高阈值。\n\n建立Precision和Recall之间的函数关系并绘制在图上，这个曲线就是**P-R曲线**。该曲线**向下倾斜的（递减）**，因为当置信度降低时，会做出更多的预测(提升召回)，而做出的预测则不那么精确(影响精度)。打个比方，当要求“说出每一种鲨鱼的名称”，你会从熟悉且肯定的说起（高精度），但是很难保证说出来的都正确（接近于高召回率，低精度）。如果PR曲线不是向下倾斜的，说明模型有问题，需要回去检测。\n![Precision和Recall](https://img-blog.csdnimg.cn/20200715152547411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70)\n\n**那么如何通过P-R曲线找到最好的阈值呢？**\n有三种思路。\n（1）斜率接近-1\n（2）计算P-R曲线下的面积（AUC，Area Under the Curve）\n（3）计算平均精度（AP，Average Precision）\n通常我们采用AP的方法。下面将开始介绍AP的计算。\n![P-R曲线理解](https://img-blog.csdnimg.cn/20200715153333755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70)\n# 4. AP\n\nVOC2010前：Recall >= 0, 0.1, 0.2, ..., 1共11个recall下precision的平均值。熟悉微积分的可以看出，下面公式的含义就是$p(r)$即precision-recall曲线下的面积。\n$$ AP = \\frac {1}{11}\\sum_{r\\in{\\lbrace 0,0.1,...,1\\rbrace}}p_{interp}(r)$$\nVOC2010后：所有数据点，而不是仅使用11个recall值来计算AP。\n$$ p_{interp}(r)=\\max_{\\hat{r}:\\hat{r}\\geq{r}}p(\\hat{r})$$\n为保证p-r曲线单调递减，对于某个recall值r，precision值取所有recall>=r中的最大值。\n\n# 5. mAP\nAP是针对一个类别的计算。所有类别的AP平均值即mAP。\n建议在分析模型结果时查看各个类的AP值。这些值也许暗示你需要添加更多的训练样本。\n例如下面的分析结果：\n\n```cpp\n// EfficientDet模型\n78.59% = Platelets AP \n77.87% = RBC AP \n96.47% = WBC AP \nmAP = 84.31%\n```\n\n```cpp\n// YOLOv3模型\n72.15% = Platelets AP \n74.41% = RBC AP \n95.54% = WBC AP \nmAP = 80.70%\n```\n表明在这一数据集上EfficientDet更精确 ，同时，对于白细胞检测比红细胞更容易。\nmAP除了分不同的IOU阈值（COCO从0.5到0.95，步长为0.05），还通常分为小、中、大三个对象，帮助识别模型(或数据集)可能出错的地方。\n\n---\n【参考】\n\n<div id=\"refer-anchor-1\"></div>\n\n[1] [Measuring Object Detection models - mAP - What is Mean Average Precision?](https://tarangshah.com/blog/2018-01-27/what-is-map-understanding-the-statistic-of-choice-for-comparing-object-detection-models/)\n<div id=\"refer-anchor-2\"></div>\n\n[2][What is Mean Average Precision (mAP) in Object Detection?](https://towardsdatascience.com/what-is-mean-average-precision-map-in-object-detection-8f893b48afd3)","slug":"CV/目标检测中的评价函数","published":1,"updated":"2020-12-14T12:32:55.118Z","_id":"ckhaklucn0006vp7edsck3x8h","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-问题定义\"><a href=\"#1-问题定义\" class=\"headerlink\" title=\"1. 问题定义\"></a>1. 问题定义</h1><p><strong>目标：</strong> 预测图像中各个物体是否出现及其位置。目标检测涉及图像中物体的<strong>定位</strong>和<strong>分类</strong>。<br><img src=\"https://img-blog.csdnimg.cn/202007151105556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70\" alt=\"目标检测任务\"><br>例如我们要区分出红细胞(RBC)、白细胞(WBC)和血小板(platelets)。除了需要用框(bounding box)框出物体，还需要对他们分类，标在框上。每个类别后跟着一个数字即判定为该类别的置信度。</p>\n<p><strong>那么如何判断那个模型好（准确）呢？</strong><br>比如上图中绿色的框标出大部分的白细胞 ，但是有些边缘的没有标出，但是我们不能通过图片，凭直觉判断模型的好坏。我们需要一个量化指标。即直接量化每个模型在测试集中的图像、类和不同置信阈值下的表现。这个工具就是mAP。<br>为了学习mAP，需要先了解几个概念。</p>\n<h1 id=\"2-几个概念\"><a href=\"#2-几个概念\" class=\"headerlink\" title=\"2. 几个概念\"></a>2. 几个概念</h1><ul>\n<li>mAP: （Mean Average Precision）平均AP</li>\n<li>AP：P-R下面积，平均精度。</li>\n<li>P-R曲线：Precision-Recall曲线</li>\n<li>Precision：精度，即所有检测结果中，正确（IoU&gt;0.5）个数的占比。<code>TP/(TP+FP)</code> 。</li>\n<li>Recall：召回率，即所有真实物体中被检测出来的个数占比。<code>TP/(TP+FN)</code></li>\n<li>TP：(True Positive)真正例。IoU&gt;0.5的检测框个数，同一个Ground Truth只计算一次</li>\n<li>FP：(False Positive)假正例。IoU&lt;0.5的检测框个数，同一个GT的多余检测框也计算</li>\n<li>FN：(False Negatives)假负例。GT里没有被检测到的数量。即模型漏检的物体。</li>\n<li>IoU：交并比。评价边界框正确性的度量指标</li>\n</ul>\n<p><strong>一张有猫的图片中，不光要检测出猫，还要检测猫的位置正确。</strong></p>\n<h1 id=\"3-Precision-Recall曲线\"><a href=\"#3-Precision-Recall曲线\" class=\"headerlink\" title=\"3. Precision-Recall曲线\"></a>3. Precision-Recall曲线</h1><p>可以分别用一句话区分精度Precision和召回率Recall</p>\n<blockquote>\n<p>Precision : “when your model guesses how often does it guess correctly?” （模型多少次预测正确？）<br>Recall ：“has your model guessed every time that it should have guessed?” （模型应该检测到的某一物体时候是否检测到了物体？）</p>\n</blockquote>\n<p>例如上面的例子。假设一张图里有10个红细胞，模型检测到一个红细胞，并且标注位置和类别都正确，那么模型就是有<strong>高精度</strong>（1个红细胞的框是准确的），<strong>低召回率</strong>（10个只检测到1个）</p>\n<p>通过调整<strong>阈值</strong>可以控制召回率。具体做法要看模型需要的环境。比如当避免假真例比避免假负例更重要时（可以不都检测到，但检测到的一定要正确），可以设置高阈值。</p>\n<p>建立Precision和Recall之间的函数关系并绘制在图上，这个曲线就是<strong>P-R曲线</strong>。该曲线<strong>向下倾斜的（递减）</strong>，因为当置信度降低时，会做出更多的预测(提升召回)，而做出的预测则不那么精确(影响精度)。打个比方，当要求“说出每一种鲨鱼的名称”，你会从熟悉且肯定的说起（高精度），但是很难保证说出来的都正确（接近于高召回率，低精度）。如果PR曲线不是向下倾斜的，说明模型有问题，需要回去检测。<br><img src=\"https://img-blog.csdnimg.cn/20200715152547411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70\" alt=\"Precision和Recall\"></p>\n<p><strong>那么如何通过P-R曲线找到最好的阈值呢？</strong><br>有三种思路。<br>（1）斜率接近-1<br>（2）计算P-R曲线下的面积（AUC，Area Under the Curve）<br>（3）计算平均精度（AP，Average Precision）<br>通常我们采用AP的方法。下面将开始介绍AP的计算。<br><img src=\"https://img-blog.csdnimg.cn/20200715153333755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70\" alt=\"P-R曲线理解\"></p>\n<h1 id=\"4-AP\"><a href=\"#4-AP\" class=\"headerlink\" title=\"4. AP\"></a>4. AP</h1><p>VOC2010前：Recall &gt;= 0, 0.1, 0.2, …, 1共11个recall下precision的平均值。熟悉微积分的可以看出，下面公式的含义就是$p(r)$即precision-recall曲线下的面积。<br>$$ AP = \\frac {1}{11}\\sum_{r\\in{\\lbrace 0,0.1,…,1\\rbrace}}p_{interp}(r)$$<br>VOC2010后：所有数据点，而不是仅使用11个recall值来计算AP。<br>$$ p_{interp}(r)=\\max_{\\hat{r}:\\hat{r}\\geq{r}}p(\\hat{r})$$<br>为保证p-r曲线单调递减，对于某个recall值r，precision值取所有recall&gt;=r中的最大值。</p>\n<h1 id=\"5-mAP\"><a href=\"#5-mAP\" class=\"headerlink\" title=\"5. mAP\"></a>5. mAP</h1><p>AP是针对一个类别的计算。所有类别的AP平均值即mAP。<br>建议在分析模型结果时查看各个类的AP值。这些值也许暗示你需要添加更多的训练样本。<br>例如下面的分析结果：</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// EfficientDet模型</span>\n<span class=\"token number\">78.59</span><span class=\"token operator\">%</span> <span class=\"token operator\">=</span> Platelets AP \n<span class=\"token number\">77.87</span><span class=\"token operator\">%</span> <span class=\"token operator\">=</span> RBC AP \n<span class=\"token number\">96.47</span><span class=\"token operator\">%</span> <span class=\"token operator\">=</span> WBC AP \nmAP <span class=\"token operator\">=</span> <span class=\"token number\">84.31</span><span class=\"token operator\">%</span></code></pre>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// YOLOv3模型</span>\n<span class=\"token number\">72.15</span><span class=\"token operator\">%</span> <span class=\"token operator\">=</span> Platelets AP \n<span class=\"token number\">74.41</span><span class=\"token operator\">%</span> <span class=\"token operator\">=</span> RBC AP \n<span class=\"token number\">95.54</span><span class=\"token operator\">%</span> <span class=\"token operator\">=</span> WBC AP \nmAP <span class=\"token operator\">=</span> <span class=\"token number\">80.70</span><span class=\"token operator\">%</span></code></pre>\n<p>表明在这一数据集上EfficientDet更精确 ，同时，对于白细胞检测比红细胞更容易。<br>mAP除了分不同的IOU阈值（COCO从0.5到0.95，步长为0.05），还通常分为小、中、大三个对象，帮助识别模型(或数据集)可能出错的地方。</p>\n<hr>\n<p>【参考】</p>\n<div id=\"refer-anchor-1\"></div>\n\n<p>[1] <a href=\"https://tarangshah.com/blog/2018-01-27/what-is-map-understanding-the-statistic-of-choice-for-comparing-object-detection-models/\">Measuring Object Detection models - mAP - What is Mean Average Precision?</a></p>\n<div id=\"refer-anchor-2\"></div>\n\n<p>[2]<a href=\"https://towardsdatascience.com/what-is-mean-average-precision-map-in-object-detection-8f893b48afd3\">What is Mean Average Precision (mAP) in Object Detection?</a></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"1-问题定义\"><a href=\"#1-问题定义\" class=\"headerlink\" title=\"1. 问题定义\"></a>1. 问题定义</h1><p><strong>目标：</strong> 预测图像中各个物体是否出现及其位置。目标检测涉及图像中物体的<strong>定位</strong>和<strong>分类</strong>。<br><img src=\"https://img-blog.csdnimg.cn/202007151105556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70\" alt=\"目标检测任务\"><br>例如我们要区分出红细胞(RBC)、白细胞(WBC)和血小板(platelets)。除了需要用框(bounding box)框出物体，还需要对他们分类，标在框上。每个类别后跟着一个数字即判定为该类别的置信度。</p>\n<p><strong>那么如何判断那个模型好（准确）呢？</strong><br>比如上图中绿色的框标出大部分的白细胞 ，但是有些边缘的没有标出，但是我们不能通过图片，凭直觉判断模型的好坏。我们需要一个量化指标。即直接量化每个模型在测试集中的图像、类和不同置信阈值下的表现。这个工具就是mAP。<br>为了学习mAP，需要先了解几个概念。</p>\n<h1 id=\"2-几个概念\"><a href=\"#2-几个概念\" class=\"headerlink\" title=\"2. 几个概念\"></a>2. 几个概念</h1><ul>\n<li>mAP: （Mean Average Precision）平均AP</li>\n<li>AP：P-R下面积，平均精度。</li>\n<li>P-R曲线：Precision-Recall曲线</li>\n<li>Precision：精度，即所有检测结果中，正确（IoU&gt;0.5）个数的占比。<code>TP/(TP+FP)</code> 。</li>\n<li>Recall：召回率，即所有真实物体中被检测出来的个数占比。<code>TP/(TP+FN)</code></li>\n<li>TP：(True Positive)真正例。IoU&gt;0.5的检测框个数，同一个Ground Truth只计算一次</li>\n<li>FP：(False Positive)假正例。IoU&lt;0.5的检测框个数，同一个GT的多余检测框也计算</li>\n<li>FN：(False Negatives)假负例。GT里没有被检测到的数量。即模型漏检的物体。</li>\n<li>IoU：交并比。评价边界框正确性的度量指标</li>\n</ul>\n<p><strong>一张有猫的图片中，不光要检测出猫，还要检测猫的位置正确。</strong></p>\n<h1 id=\"3-Precision-Recall曲线\"><a href=\"#3-Precision-Recall曲线\" class=\"headerlink\" title=\"3. Precision-Recall曲线\"></a>3. Precision-Recall曲线</h1><p>可以分别用一句话区分精度Precision和召回率Recall</p>\n<blockquote>\n<p>Precision : “when your model guesses how often does it guess correctly?” （模型多少次预测正确？）<br>Recall ：“has your model guessed every time that it should have guessed?” （模型应该检测到的某一物体时候是否检测到了物体？）</p>\n</blockquote>\n<p>例如上面的例子。假设一张图里有10个红细胞，模型检测到一个红细胞，并且标注位置和类别都正确，那么模型就是有<strong>高精度</strong>（1个红细胞的框是准确的），<strong>低召回率</strong>（10个只检测到1个）</p>\n<p>通过调整<strong>阈值</strong>可以控制召回率。具体做法要看模型需要的环境。比如当避免假真例比避免假负例更重要时（可以不都检测到，但检测到的一定要正确），可以设置高阈值。</p>\n<p>建立Precision和Recall之间的函数关系并绘制在图上，这个曲线就是<strong>P-R曲线</strong>。该曲线<strong>向下倾斜的（递减）</strong>，因为当置信度降低时，会做出更多的预测(提升召回)，而做出的预测则不那么精确(影响精度)。打个比方，当要求“说出每一种鲨鱼的名称”，你会从熟悉且肯定的说起（高精度），但是很难保证说出来的都正确（接近于高召回率，低精度）。如果PR曲线不是向下倾斜的，说明模型有问题，需要回去检测。<br><img src=\"https://img-blog.csdnimg.cn/20200715152547411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70\" alt=\"Precision和Recall\"></p>\n<p><strong>那么如何通过P-R曲线找到最好的阈值呢？</strong><br>有三种思路。<br>（1）斜率接近-1<br>（2）计算P-R曲线下的面积（AUC，Area Under the Curve）<br>（3）计算平均精度（AP，Average Precision）<br>通常我们采用AP的方法。下面将开始介绍AP的计算。<br><img src=\"https://img-blog.csdnimg.cn/20200715153333755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM2OTQ5Mg==,size_16,color_FFFFFF,t_70\" alt=\"P-R曲线理解\"></p>\n<h1 id=\"4-AP\"><a href=\"#4-AP\" class=\"headerlink\" title=\"4. AP\"></a>4. AP</h1><p>VOC2010前：Recall &gt;= 0, 0.1, 0.2, …, 1共11个recall下precision的平均值。熟悉微积分的可以看出，下面公式的含义就是$p(r)$即precision-recall曲线下的面积。<br>$$ AP = \\frac {1}{11}\\sum_{r\\in{\\lbrace 0,0.1,…,1\\rbrace}}p_{interp}(r)$$<br>VOC2010后：所有数据点，而不是仅使用11个recall值来计算AP。<br>$$ p_{interp}(r)=\\max_{\\hat{r}:\\hat{r}\\geq{r}}p(\\hat{r})$$<br>为保证p-r曲线单调递减，对于某个recall值r，precision值取所有recall&gt;=r中的最大值。</p>\n<h1 id=\"5-mAP\"><a href=\"#5-mAP\" class=\"headerlink\" title=\"5. mAP\"></a>5. mAP</h1><p>AP是针对一个类别的计算。所有类别的AP平均值即mAP。<br>建议在分析模型结果时查看各个类的AP值。这些值也许暗示你需要添加更多的训练样本。<br>例如下面的分析结果：</p>\n<pre><code class=\"cpp\">// EfficientDet模型\n78.59% = Platelets AP \n77.87% = RBC AP \n96.47% = WBC AP \nmAP = 84.31%</code></pre>\n<pre><code class=\"cpp\">// YOLOv3模型\n72.15% = Platelets AP \n74.41% = RBC AP \n95.54% = WBC AP \nmAP = 80.70%</code></pre>\n<p>表明在这一数据集上EfficientDet更精确 ，同时，对于白细胞检测比红细胞更容易。<br>mAP除了分不同的IOU阈值（COCO从0.5到0.95，步长为0.05），还通常分为小、中、大三个对象，帮助识别模型(或数据集)可能出错的地方。</p>\n<hr>\n<p>【参考】</p>\n<div id=\"refer-anchor-1\"></div>\n\n<p>[1] <a href=\"https://tarangshah.com/blog/2018-01-27/what-is-map-understanding-the-statistic-of-choice-for-comparing-object-detection-models/\">Measuring Object Detection models - mAP - What is Mean Average Precision?</a></p>\n<div id=\"refer-anchor-2\"></div>\n\n<p>[2]<a href=\"https://towardsdatascience.com/what-is-mean-average-precision-map-in-object-detection-8f893b48afd3\">What is Mean Average Precision (mAP) in Object Detection?</a></p>\n"},{"title":"DeepStream5.0结合OpenCV4实现视频的分析和截图","date":"2020-05-15T08:58:14.000Z","author":"马捷径","img":"https://img-blog.csdnimg.cn/20200326193416267.png","top":true,"cover":true,"coverImg":"https://img-blog.csdnimg.cn/20200326193416267.png","toc":true,"mathjax":true,"summary":"在deepstream的基础上利用opencv4进行截图","keywords":["DeepStream","Opencv4","NvBufSurface","截图"],"_content":"# 0. 前言\n上次测试opencv结合deepstream4进行截图时，出现了一个[错误](https://blog.csdn.net/weixin_38369492/article/details/105418579#3__94)。当时在deepstream4中，虽然报错却仍能保证程序正常进行。但是deepstream5出来以后，迁移代码再跑时，这个错误就直接让程序崩掉了。找了半天没找到原因，所以改写了一下截图部分代码。\n\n**思路**\n[DeepStream结合OpenCV4实现视频的分析和截图（二）](https://blog.csdn.net/weixin_38369492/article/details/105418579)中的方式是取一帧数据，进行格式和参数转换，保存到另一个==NvBufSurface==结构中。然后再从该结构取数据保存到opencv的==mat==中，imwrite存图。问题出现在==NvBufSurface==转换上。\n\n这次干脆放弃转换NvBufSurface，不再调用==NvBufSurfTransform==函数，而是先取数据到mat再转换格式。而是参考[DeepStream结合OpenCV4实现视频的分析和截图（一）](https://blog.csdn.net/weixin_38369492/article/details/105121729)中方法，稍作调整。\n\n# 1. 环境\n- Ubuntu 18.04\n- CUDA 10.2\n- CUDNN 7.6.5.32\n- TensorRT 7.0.0.2\n- DeepStream 5.0\n- OpenCV 4.2\n\n# 2. 方法概述\n取出指定源帧数据->cudaMemcpy拷贝出帧数据->存到mat结构中->颜色空间转换。\n\n相比（一）中代码，这里多了指定源，以及NV12转BGR。 \n\n- **指定源**利用surface->surfaceList[batch_id]\n- **格式转换**首先要查看surface原始的色彩空间，比如我在deepstream-app上测试的，infer后的色彩空间是NV12。\n\n1. **NV12的Mat定义：**\n\n注意是==height*3/2==，==CV_8UC1==\n```cpp\ncv::Mat frame = cv::Mat(frame_height * 3 / 2, frame_width, CV_8UC1, src_data, frame_step);\n```\n2. **OpenCV中NV12转BGR**\n\n```cpp\ncv::cvtColor(frame, out_mat, CV_YUV2BGR_NV12);\n```\n\n3. **图像压缩**\n\n```cpp\nfloat fx = 0.6;\nfloat fy = 0.6; //图像压缩比例\ncv::Size dsize = cv::Size(round(fx * out_mat.cols), round(fy * out_mat.rows));\ncv::resize(source_mat, out_mat, dsize, 0, 0, cv::INTER_AREA); //重采样差值法进行图像压缩\n```\n\n# 3. Code\n\n```cpp\nbatch_id = frame_meta->batch_id;\nmemset(&in_map_info, 0, sizeof(in_map_info));\nif (!gst_buffer_map(buf, &in_map_info, GST_MAP_READ))\n{\n    g_print(\"Error: Failed to map gst buffer\\n\");\n}\nsurface = (NvBufSurface *)in_map_info.data;\nchar *src_data = NULL;\nsrc_data = (char *)malloc(surface->surfaceList[batch_id].dataSize);\nif (src_data == NULL)\n{\n    g_print(\"Error: failed to malloc src_data \\n\");\n}\n#ifdef PLATFORM_TEGRA\nNvBufSurfaceMap(surface, -1, -1, NVBUF_MAP_READ);\nNvBufSurfacePlaneParams *pParams = &surface->surfaceList[batch_id].planeParams;\nunsigned int offset = 0;\nfor (unsigned int num_planes = 0; num_planes < pParams->num_planes; num_planes++)\n{\n    if (num_planes > 0)\n        offset += pParams->height[num_planes - 1] * (pParams->bytesPerPix[num_planes - 1] * pParams->width[num_planes - 1]);\n    for (unsigned int h = 0; h < pParams->height[num_planes]; h++)\n    {\n        memcpy((void *)(src_data + offset + h * pParams->bytesPerPix[num_planes] * pParams->width[num_planes]),\n               (void *)((char *)surface->surfaceList[batch_id].mappedAddr.addr[num_planes] + h * pParams->pitch[num_planes]),\n               pParams->bytesPerPix[num_planes] * pParams->width[num_planes]);\n    }\n}\nNvBufSurfaceSyncForDevice(surface, -1, -1);\nNvBufSurfaceUnMap(surface, -1, -1);\n#else\ncudaMemcpy((void *)src_data,\n           (void *)surface->surfaceList[batch_id].dataPtr,\n           surface->surfaceList[batch_id].dataSize,\n           cudaMemcpyDeviceToHost);\n#endif\ngint frame_width = (gint)surface->surfaceList[batch_id].width;\ngint frame_height = (gint)surface->surfaceList[batch_id].height;\ngint frame_step = surface->surfaceList[batch_id].pitch;\ncv::Mat frame = cv::Mat(frame_height * 3 / 2, frame_width, CV_8UC1, src_data, frame_step);\n// g_print(\"%d\\n\",frame.channels());\n// g_print(\"%d\\n\",frame.rows);\n// g_print(\"%d\\n\",frame.cols);\ncv::Mat out_mat = cv::Mat(cv::Size(frame_width, frame_height), CV_8UC3);\ncv::cvtColor(frame, out_mat, CV_YUV2BGR_NV12);\ncv::imwrite(savefilename, out_mat);\nif (src_data != NULL)\n{\n    free(src_data);\n    src_data = NULL;\n}\ngst_buffer_unmap(buf, &in_map_info);\n```","source":"_posts/Deepstream/DeepStream5.0结合OpenCV4实现视频的分析和截图.md","raw":"---\ntitle: DeepStream5.0结合OpenCV4实现视频的分析和截图\ndate: 2020-05-15 16:58:14\nauthor: 马捷径\nimg: https://img-blog.csdnimg.cn/20200326193416267.png\ntop: true\ncover: true\ncoverImg: https://img-blog.csdnimg.cn/20200326193416267.png\ntoc: true\nmathjax: true\nsummary: 在deepstream的基础上利用opencv4进行截图\nkeywords: \n  - DeepStream\n  - Opencv4\n  - NvBufSurface\n  - 截图\ncategories: 视频分析\ntags:\n  - 视频分析\n  - DeepStream\n---\n# 0. 前言\n上次测试opencv结合deepstream4进行截图时，出现了一个[错误](https://blog.csdn.net/weixin_38369492/article/details/105418579#3__94)。当时在deepstream4中，虽然报错却仍能保证程序正常进行。但是deepstream5出来以后，迁移代码再跑时，这个错误就直接让程序崩掉了。找了半天没找到原因，所以改写了一下截图部分代码。\n\n**思路**\n[DeepStream结合OpenCV4实现视频的分析和截图（二）](https://blog.csdn.net/weixin_38369492/article/details/105418579)中的方式是取一帧数据，进行格式和参数转换，保存到另一个==NvBufSurface==结构中。然后再从该结构取数据保存到opencv的==mat==中，imwrite存图。问题出现在==NvBufSurface==转换上。\n\n这次干脆放弃转换NvBufSurface，不再调用==NvBufSurfTransform==函数，而是先取数据到mat再转换格式。而是参考[DeepStream结合OpenCV4实现视频的分析和截图（一）](https://blog.csdn.net/weixin_38369492/article/details/105121729)中方法，稍作调整。\n\n# 1. 环境\n- Ubuntu 18.04\n- CUDA 10.2\n- CUDNN 7.6.5.32\n- TensorRT 7.0.0.2\n- DeepStream 5.0\n- OpenCV 4.2\n\n# 2. 方法概述\n取出指定源帧数据->cudaMemcpy拷贝出帧数据->存到mat结构中->颜色空间转换。\n\n相比（一）中代码，这里多了指定源，以及NV12转BGR。 \n\n- **指定源**利用surface->surfaceList[batch_id]\n- **格式转换**首先要查看surface原始的色彩空间，比如我在deepstream-app上测试的，infer后的色彩空间是NV12。\n\n1. **NV12的Mat定义：**\n\n注意是==height*3/2==，==CV_8UC1==\n```cpp\ncv::Mat frame = cv::Mat(frame_height * 3 / 2, frame_width, CV_8UC1, src_data, frame_step);\n```\n2. **OpenCV中NV12转BGR**\n\n```cpp\ncv::cvtColor(frame, out_mat, CV_YUV2BGR_NV12);\n```\n\n3. **图像压缩**\n\n```cpp\nfloat fx = 0.6;\nfloat fy = 0.6; //图像压缩比例\ncv::Size dsize = cv::Size(round(fx * out_mat.cols), round(fy * out_mat.rows));\ncv::resize(source_mat, out_mat, dsize, 0, 0, cv::INTER_AREA); //重采样差值法进行图像压缩\n```\n\n# 3. Code\n\n```cpp\nbatch_id = frame_meta->batch_id;\nmemset(&in_map_info, 0, sizeof(in_map_info));\nif (!gst_buffer_map(buf, &in_map_info, GST_MAP_READ))\n{\n    g_print(\"Error: Failed to map gst buffer\\n\");\n}\nsurface = (NvBufSurface *)in_map_info.data;\nchar *src_data = NULL;\nsrc_data = (char *)malloc(surface->surfaceList[batch_id].dataSize);\nif (src_data == NULL)\n{\n    g_print(\"Error: failed to malloc src_data \\n\");\n}\n#ifdef PLATFORM_TEGRA\nNvBufSurfaceMap(surface, -1, -1, NVBUF_MAP_READ);\nNvBufSurfacePlaneParams *pParams = &surface->surfaceList[batch_id].planeParams;\nunsigned int offset = 0;\nfor (unsigned int num_planes = 0; num_planes < pParams->num_planes; num_planes++)\n{\n    if (num_planes > 0)\n        offset += pParams->height[num_planes - 1] * (pParams->bytesPerPix[num_planes - 1] * pParams->width[num_planes - 1]);\n    for (unsigned int h = 0; h < pParams->height[num_planes]; h++)\n    {\n        memcpy((void *)(src_data + offset + h * pParams->bytesPerPix[num_planes] * pParams->width[num_planes]),\n               (void *)((char *)surface->surfaceList[batch_id].mappedAddr.addr[num_planes] + h * pParams->pitch[num_planes]),\n               pParams->bytesPerPix[num_planes] * pParams->width[num_planes]);\n    }\n}\nNvBufSurfaceSyncForDevice(surface, -1, -1);\nNvBufSurfaceUnMap(surface, -1, -1);\n#else\ncudaMemcpy((void *)src_data,\n           (void *)surface->surfaceList[batch_id].dataPtr,\n           surface->surfaceList[batch_id].dataSize,\n           cudaMemcpyDeviceToHost);\n#endif\ngint frame_width = (gint)surface->surfaceList[batch_id].width;\ngint frame_height = (gint)surface->surfaceList[batch_id].height;\ngint frame_step = surface->surfaceList[batch_id].pitch;\ncv::Mat frame = cv::Mat(frame_height * 3 / 2, frame_width, CV_8UC1, src_data, frame_step);\n// g_print(\"%d\\n\",frame.channels());\n// g_print(\"%d\\n\",frame.rows);\n// g_print(\"%d\\n\",frame.cols);\ncv::Mat out_mat = cv::Mat(cv::Size(frame_width, frame_height), CV_8UC3);\ncv::cvtColor(frame, out_mat, CV_YUV2BGR_NV12);\ncv::imwrite(savefilename, out_mat);\nif (src_data != NULL)\n{\n    free(src_data);\n    src_data = NULL;\n}\ngst_buffer_unmap(buf, &in_map_info);\n```","slug":"Deepstream/DeepStream5.0结合OpenCV4实现视频的分析和截图","published":1,"updated":"2020-12-14T12:33:04.604Z","_id":"ckhaklucp0007vp7e02on8v3u","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0. 前言\"></a>0. 前言</h1><p>上次测试opencv结合deepstream4进行截图时，出现了一个<a href=\"https://blog.csdn.net/weixin_38369492/article/details/105418579#3__94\">错误</a>。当时在deepstream4中，虽然报错却仍能保证程序正常进行。但是deepstream5出来以后，迁移代码再跑时，这个错误就直接让程序崩掉了。找了半天没找到原因，所以改写了一下截图部分代码。</p>\n<p><strong>思路</strong><br><a href=\"https://blog.csdn.net/weixin_38369492/article/details/105418579\">DeepStream结合OpenCV4实现视频的分析和截图（二）</a>中的方式是取一帧数据，进行格式和参数转换，保存到另一个==NvBufSurface==结构中。然后再从该结构取数据保存到opencv的==mat==中，imwrite存图。问题出现在==NvBufSurface==转换上。</p>\n<p>这次干脆放弃转换NvBufSurface，不再调用==NvBufSurfTransform==函数，而是先取数据到mat再转换格式。而是参考<a href=\"https://blog.csdn.net/weixin_38369492/article/details/105121729\">DeepStream结合OpenCV4实现视频的分析和截图（一）</a>中方法，稍作调整。</p>\n<h1 id=\"1-环境\"><a href=\"#1-环境\" class=\"headerlink\" title=\"1. 环境\"></a>1. 环境</h1><ul>\n<li>Ubuntu 18.04</li>\n<li>CUDA 10.2</li>\n<li>CUDNN 7.6.5.32</li>\n<li>TensorRT 7.0.0.2</li>\n<li>DeepStream 5.0</li>\n<li>OpenCV 4.2</li>\n</ul>\n<h1 id=\"2-方法概述\"><a href=\"#2-方法概述\" class=\"headerlink\" title=\"2. 方法概述\"></a>2. 方法概述</h1><p>取出指定源帧数据-&gt;cudaMemcpy拷贝出帧数据-&gt;存到mat结构中-&gt;颜色空间转换。</p>\n<p>相比（一）中代码，这里多了指定源，以及NV12转BGR。 </p>\n<ul>\n<li><strong>指定源</strong>利用surface-&gt;surfaceList[batch_id]</li>\n<li><strong>格式转换</strong>首先要查看surface原始的色彩空间，比如我在deepstream-app上测试的，infer后的色彩空间是NV12。</li>\n</ul>\n<ol>\n<li><strong>NV12的Mat定义：</strong></li>\n</ol>\n<p>注意是==height*3/2==，==CV_8UC1==</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">cv<span class=\"token operator\">::</span>Mat frame <span class=\"token operator\">=</span> cv<span class=\"token operator\">::</span><span class=\"token function\">Mat</span><span class=\"token punctuation\">(</span>frame_height <span class=\"token operator\">*</span> <span class=\"token number\">3</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> frame_width<span class=\"token punctuation\">,</span> CV_8UC1<span class=\"token punctuation\">,</span> src_data<span class=\"token punctuation\">,</span> frame_step<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<ol start=\"2\">\n<li><strong>OpenCV中NV12转BGR</strong></li>\n</ol>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">cv<span class=\"token operator\">::</span><span class=\"token function\">cvtColor</span><span class=\"token punctuation\">(</span>frame<span class=\"token punctuation\">,</span> out_mat<span class=\"token punctuation\">,</span> CV_YUV2BGR_NV12<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<ol start=\"3\">\n<li><strong>图像压缩</strong></li>\n</ol>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">float</span> fx <span class=\"token operator\">=</span> <span class=\"token number\">0.6</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">float</span> fy <span class=\"token operator\">=</span> <span class=\"token number\">0.6</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//图像压缩比例</span>\ncv<span class=\"token operator\">::</span>Size dsize <span class=\"token operator\">=</span> cv<span class=\"token operator\">::</span><span class=\"token function\">Size</span><span class=\"token punctuation\">(</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>fx <span class=\"token operator\">*</span> out_mat<span class=\"token punctuation\">.</span>cols<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">round</span><span class=\"token punctuation\">(</span>fy <span class=\"token operator\">*</span> out_mat<span class=\"token punctuation\">.</span>rows<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncv<span class=\"token operator\">::</span><span class=\"token function\">resize</span><span class=\"token punctuation\">(</span>source_mat<span class=\"token punctuation\">,</span> out_mat<span class=\"token punctuation\">,</span> dsize<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> cv<span class=\"token operator\">::</span>INTER_AREA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//重采样差值法进行图像压缩</span></code></pre>\n<h1 id=\"3-Code\"><a href=\"#3-Code\" class=\"headerlink\" title=\"3. Code\"></a>3. Code</h1><pre class=\" language-cpp\"><code class=\"language-cpp\">batch_id <span class=\"token operator\">=</span> frame_meta<span class=\"token operator\">-</span><span class=\"token operator\">></span>batch_id<span class=\"token punctuation\">;</span>\n<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>in_map_info<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>in_map_info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">gst_buffer_map</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>in_map_info<span class=\"token punctuation\">,</span> GST_MAP_READ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">g_print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error: Failed to map gst buffer\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nsurface <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>NvBufSurface <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>in_map_info<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>src_data <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\nsrc_data <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>surface<span class=\"token operator\">-</span><span class=\"token operator\">></span>surfaceList<span class=\"token punctuation\">[</span>batch_id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>dataSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>src_data <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">g_print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error: failed to malloc src_data \\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> PLATFORM_TEGRA</span>\n<span class=\"token function\">NvBufSurfaceMap</span><span class=\"token punctuation\">(</span>surface<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> NVBUF_MAP_READ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nNvBufSurfacePlaneParams <span class=\"token operator\">*</span>pParams <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>surface<span class=\"token operator\">-</span><span class=\"token operator\">></span>surfaceList<span class=\"token punctuation\">[</span>batch_id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>planeParams<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> offset <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> num_planes <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> num_planes <span class=\"token operator\">&lt;</span> pParams<span class=\"token operator\">-</span><span class=\"token operator\">></span>num_planes<span class=\"token punctuation\">;</span> num_planes<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num_planes <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        offset <span class=\"token operator\">+</span><span class=\"token operator\">=</span> pParams<span class=\"token operator\">-</span><span class=\"token operator\">></span>height<span class=\"token punctuation\">[</span>num_planes <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>pParams<span class=\"token operator\">-</span><span class=\"token operator\">></span>bytesPerPix<span class=\"token punctuation\">[</span>num_planes <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> pParams<span class=\"token operator\">-</span><span class=\"token operator\">></span>width<span class=\"token punctuation\">[</span>num_planes <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> h <span class=\"token operator\">&lt;</span> pParams<span class=\"token operator\">-</span><span class=\"token operator\">></span>height<span class=\"token punctuation\">[</span>num_planes<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> h<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>src_data <span class=\"token operator\">+</span> offset <span class=\"token operator\">+</span> h <span class=\"token operator\">*</span> pParams<span class=\"token operator\">-</span><span class=\"token operator\">></span>bytesPerPix<span class=\"token punctuation\">[</span>num_planes<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> pParams<span class=\"token operator\">-</span><span class=\"token operator\">></span>width<span class=\"token punctuation\">[</span>num_planes<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n               <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>surface<span class=\"token operator\">-</span><span class=\"token operator\">></span>surfaceList<span class=\"token punctuation\">[</span>batch_id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>mappedAddr<span class=\"token punctuation\">.</span>addr<span class=\"token punctuation\">[</span>num_planes<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> h <span class=\"token operator\">*</span> pParams<span class=\"token operator\">-</span><span class=\"token operator\">></span>pitch<span class=\"token punctuation\">[</span>num_planes<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n               pParams<span class=\"token operator\">-</span><span class=\"token operator\">></span>bytesPerPix<span class=\"token punctuation\">[</span>num_planes<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> pParams<span class=\"token operator\">-</span><span class=\"token operator\">></span>width<span class=\"token punctuation\">[</span>num_planes<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">NvBufSurfaceSyncForDevice</span><span class=\"token punctuation\">(</span>surface<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">NvBufSurfaceUnMap</span><span class=\"token punctuation\">(</span>surface<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">else</span></span>\n<span class=\"token function\">cudaMemcpy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>src_data<span class=\"token punctuation\">,</span>\n           <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>surface<span class=\"token operator\">-</span><span class=\"token operator\">></span>surfaceList<span class=\"token punctuation\">[</span>batch_id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>dataPtr<span class=\"token punctuation\">,</span>\n           surface<span class=\"token operator\">-</span><span class=\"token operator\">></span>surfaceList<span class=\"token punctuation\">[</span>batch_id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>dataSize<span class=\"token punctuation\">,</span>\n           cudaMemcpyDeviceToHost<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\ngint frame_width <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>gint<span class=\"token punctuation\">)</span>surface<span class=\"token operator\">-</span><span class=\"token operator\">></span>surfaceList<span class=\"token punctuation\">[</span>batch_id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">;</span>\ngint frame_height <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>gint<span class=\"token punctuation\">)</span>surface<span class=\"token operator\">-</span><span class=\"token operator\">></span>surfaceList<span class=\"token punctuation\">[</span>batch_id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">;</span>\ngint frame_step <span class=\"token operator\">=</span> surface<span class=\"token operator\">-</span><span class=\"token operator\">></span>surfaceList<span class=\"token punctuation\">[</span>batch_id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>pitch<span class=\"token punctuation\">;</span>\ncv<span class=\"token operator\">::</span>Mat frame <span class=\"token operator\">=</span> cv<span class=\"token operator\">::</span><span class=\"token function\">Mat</span><span class=\"token punctuation\">(</span>frame_height <span class=\"token operator\">*</span> <span class=\"token number\">3</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> frame_width<span class=\"token punctuation\">,</span> CV_8UC1<span class=\"token punctuation\">,</span> src_data<span class=\"token punctuation\">,</span> frame_step<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// g_print(\"%d\\n\",frame.channels());</span>\n<span class=\"token comment\" spellcheck=\"true\">// g_print(\"%d\\n\",frame.rows);</span>\n<span class=\"token comment\" spellcheck=\"true\">// g_print(\"%d\\n\",frame.cols);</span>\ncv<span class=\"token operator\">::</span>Mat out_mat <span class=\"token operator\">=</span> cv<span class=\"token operator\">::</span><span class=\"token function\">Mat</span><span class=\"token punctuation\">(</span>cv<span class=\"token operator\">::</span><span class=\"token function\">Size</span><span class=\"token punctuation\">(</span>frame_width<span class=\"token punctuation\">,</span> frame_height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> CV_8UC3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncv<span class=\"token operator\">::</span><span class=\"token function\">cvtColor</span><span class=\"token punctuation\">(</span>frame<span class=\"token punctuation\">,</span> out_mat<span class=\"token punctuation\">,</span> CV_YUV2BGR_NV12<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncv<span class=\"token operator\">::</span><span class=\"token function\">imwrite</span><span class=\"token punctuation\">(</span>savefilename<span class=\"token punctuation\">,</span> out_mat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>src_data <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>src_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    src_data <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">gst_buffer_unmap</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>in_map_info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0. 前言\"></a>0. 前言</h1><p>上次测试opencv结合deepstream4进行截图时，出现了一个<a href=\"https://blog.csdn.net/weixin_38369492/article/details/105418579#3__94\">错误</a>。当时在deepstream4中，虽然报错却仍能保证程序正常进行。但是deepstream5出来以后，迁移代码再跑时，这个错误就直接让程序崩掉了。找了半天没找到原因，所以改写了一下截图部分代码。</p>\n<p><strong>思路</strong><br><a href=\"https://blog.csdn.net/weixin_38369492/article/details/105418579\">DeepStream结合OpenCV4实现视频的分析和截图（二）</a>中的方式是取一帧数据，进行格式和参数转换，保存到另一个==NvBufSurface==结构中。然后再从该结构取数据保存到opencv的==mat==中，imwrite存图。问题出现在==NvBufSurface==转换上。</p>\n<p>这次干脆放弃转换NvBufSurface，不再调用==NvBufSurfTransform==函数，而是先取数据到mat再转换格式。而是参考<a href=\"https://blog.csdn.net/weixin_38369492/article/details/105121729\">DeepStream结合OpenCV4实现视频的分析和截图（一）</a>中方法，稍作调整。</p>\n<h1 id=\"1-环境\"><a href=\"#1-环境\" class=\"headerlink\" title=\"1. 环境\"></a>1. 环境</h1><ul>\n<li>Ubuntu 18.04</li>\n<li>CUDA 10.2</li>\n<li>CUDNN 7.6.5.32</li>\n<li>TensorRT 7.0.0.2</li>\n<li>DeepStream 5.0</li>\n<li>OpenCV 4.2</li>\n</ul>\n<h1 id=\"2-方法概述\"><a href=\"#2-方法概述\" class=\"headerlink\" title=\"2. 方法概述\"></a>2. 方法概述</h1><p>取出指定源帧数据-&gt;cudaMemcpy拷贝出帧数据-&gt;存到mat结构中-&gt;颜色空间转换。</p>\n<p>相比（一）中代码，这里多了指定源，以及NV12转BGR。 </p>\n<ul>\n<li><strong>指定源</strong>利用surface-&gt;surfaceList[batch_id]</li>\n<li><strong>格式转换</strong>首先要查看surface原始的色彩空间，比如我在deepstream-app上测试的，infer后的色彩空间是NV12。</li>\n</ul>\n<ol>\n<li><strong>NV12的Mat定义：</strong></li>\n</ol>\n<p>注意是==height*3/2==，==CV_8UC1==</p>\n<pre><code class=\"cpp\">cv::Mat frame = cv::Mat(frame_height * 3 / 2, frame_width, CV_8UC1, src_data, frame_step);</code></pre>\n<ol start=\"2\">\n<li><strong>OpenCV中NV12转BGR</strong></li>\n</ol>\n<pre><code class=\"cpp\">cv::cvtColor(frame, out_mat, CV_YUV2BGR_NV12);</code></pre>\n<ol start=\"3\">\n<li><strong>图像压缩</strong></li>\n</ol>\n<pre><code class=\"cpp\">float fx = 0.6;\nfloat fy = 0.6; //图像压缩比例\ncv::Size dsize = cv::Size(round(fx * out_mat.cols), round(fy * out_mat.rows));\ncv::resize(source_mat, out_mat, dsize, 0, 0, cv::INTER_AREA); //重采样差值法进行图像压缩</code></pre>\n<h1 id=\"3-Code\"><a href=\"#3-Code\" class=\"headerlink\" title=\"3. Code\"></a>3. Code</h1><pre><code class=\"cpp\">batch_id = frame_meta-&gt;batch_id;\nmemset(&amp;in_map_info, 0, sizeof(in_map_info));\nif (!gst_buffer_map(buf, &amp;in_map_info, GST_MAP_READ))\n&#123;\n    g_print(&quot;Error: Failed to map gst buffer\\n&quot;);\n&#125;\nsurface = (NvBufSurface *)in_map_info.data;\nchar *src_data = NULL;\nsrc_data = (char *)malloc(surface-&gt;surfaceList[batch_id].dataSize);\nif (src_data == NULL)\n&#123;\n    g_print(&quot;Error: failed to malloc src_data \\n&quot;);\n&#125;\n#ifdef PLATFORM_TEGRA\nNvBufSurfaceMap(surface, -1, -1, NVBUF_MAP_READ);\nNvBufSurfacePlaneParams *pParams = &amp;surface-&gt;surfaceList[batch_id].planeParams;\nunsigned int offset = 0;\nfor (unsigned int num_planes = 0; num_planes &lt; pParams-&gt;num_planes; num_planes++)\n&#123;\n    if (num_planes &gt; 0)\n        offset += pParams-&gt;height[num_planes - 1] * (pParams-&gt;bytesPerPix[num_planes - 1] * pParams-&gt;width[num_planes - 1]);\n    for (unsigned int h = 0; h &lt; pParams-&gt;height[num_planes]; h++)\n    &#123;\n        memcpy((void *)(src_data + offset + h * pParams-&gt;bytesPerPix[num_planes] * pParams-&gt;width[num_planes]),\n               (void *)((char *)surface-&gt;surfaceList[batch_id].mappedAddr.addr[num_planes] + h * pParams-&gt;pitch[num_planes]),\n               pParams-&gt;bytesPerPix[num_planes] * pParams-&gt;width[num_planes]);\n    &#125;\n&#125;\nNvBufSurfaceSyncForDevice(surface, -1, -1);\nNvBufSurfaceUnMap(surface, -1, -1);\n#else\ncudaMemcpy((void *)src_data,\n           (void *)surface-&gt;surfaceList[batch_id].dataPtr,\n           surface-&gt;surfaceList[batch_id].dataSize,\n           cudaMemcpyDeviceToHost);\n#endif\ngint frame_width = (gint)surface-&gt;surfaceList[batch_id].width;\ngint frame_height = (gint)surface-&gt;surfaceList[batch_id].height;\ngint frame_step = surface-&gt;surfaceList[batch_id].pitch;\ncv::Mat frame = cv::Mat(frame_height * 3 / 2, frame_width, CV_8UC1, src_data, frame_step);\n// g_print(&quot;%d\\n&quot;,frame.channels());\n// g_print(&quot;%d\\n&quot;,frame.rows);\n// g_print(&quot;%d\\n&quot;,frame.cols);\ncv::Mat out_mat = cv::Mat(cv::Size(frame_width, frame_height), CV_8UC3);\ncv::cvtColor(frame, out_mat, CV_YUV2BGR_NV12);\ncv::imwrite(savefilename, out_mat);\nif (src_data != NULL)\n&#123;\n    free(src_data);\n    src_data = NULL;\n&#125;\ngst_buffer_unmap(buf, &amp;in_map_info);</code></pre>\n"},{"title":"在C++与python间传视频帧","date":"2020-11-30T13:37:33.000Z","author":"马捷径","img":"https://img-blog.csdnimg.cn/20201130204440444.png","top":true,"cover":true,"coverImg":"https://img-blog.csdnimg.cn/20201130204440444.png","toc":true,"mathjax":true,"summary":"本案例旨在实现跨语言（C++和python间）视频的实时通信。这一工作内容在实际工程中很常见。由于python语言支持很多第三方库，对于开发深度学习项目很方便，验真算法速度快，很多开源算法也大多基于python实现。这时可能就会出现C++的代码借助python语言做一些图像处理（包括目标检测、姿态估计、目标跟踪等任务）的需求。","keywords":["通信","共享内存","socket","C++","python"],"_content":"\n# 引言\n本案例旨在实现跨语言（C++和python间）视频的实时通信。这一工作内容在实际工程中很常见。由于python语言支持很多第三方库，对于开发深度学习项目很方便，验真算法速度快，很多开源算法也大多基于python实现。这时可能就会出现C++的代码借助python语言做一些图像处理（包括目标检测、姿态估计、目标跟踪等任务）的需求。\n\n平台环境：\n- Win10\n- VS2019\n- OpenCV\n\n进程间通信方式：共享内存\n\n# 1.进程间通信\n\n进程间通信方式有很多种。工程上最常用的是**共享内存**和**socket机制**。前者效率高，基本思想就是开辟一块公共的内存空间，供两个或多个进程之间使用。为了标识这个公共空间，要给它起个名。但是共享内存的方式不支持多平台。而socket刚好就是支持多平台间进程通信的方式。当然这种方式也会慢一些。\n\n在本案例中，分别尝试了两种方式。虽然最终共享内存的方式写内存帧率只达到15fps左右，但是要比socket快了近20倍（大概0.5-1fps左右）。下面将介绍这两种机制的具体实现过程。\n\n# 2.基于共享内存的视频传输\n## 2.1 C++之间的通信\n### 2.1.1 接口函数\n首先验证C++之间能通信。这里使用的是[CreateFileMapping](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga)和[MapViewOfFile](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile)进行共享内存的创建和映射。\n\n其中[CreateFileMapping](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga)的接口为，参数含义详解请点击链接。\n```cpp\nHANDLE CreateFileMapping(\n  HANDLE                hFile,\n  LPSECURITY_ATTRIBUTES lpFileMappingAttributes,\n  DWORD                 flProtect,\n  DWORD                 dwMaximumSizeHigh,\n  DWORD                 dwMaximumSizeLow,\n  LPCSTR                lpName\n);\n```\n\n[MapViewOfFile](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile)的接口为\n```cpp\nLPVOID MapViewOfFile(\n  HANDLE hFileMappingObject,\n  DWORD  dwDesiredAccess,\n  DWORD  dwFileOffsetHigh,\n  DWORD  dwFileOffsetLow,\n  SIZE_T dwNumberOfBytesToMap\n);\n```\n### 2.1.2 创建数据格式和共享内存信息\n首先需要一个图像的头部\n```cpp\ntypedef struct {\n\tint width;\n\tint height;\n\tint type;\n}ImgInf;       //图像信息\n```\n由于sizeof(int)=4，所以这里ImgInf结构体大小为12B。在进行共享内存映射时，我们需要这个大小去做偏移量，找到图像数据。\n\n接下来要定义图像的数据信息\n```cpp\n#define FRAME_NUMBER         1               // 图像路数\n#define FRAME_W              1920\n#define FRAME_H              1080\n#define FRAME_W_H            FRAME_W*FRAME_H\n// 图像分辨率：彩色图（3通道）+图像信息结构体\n#define FRAME_SIZE           FRAME_W_H*sizeof(unsigned char)*3+sizeof(ImgInf)\n\n#define MEMORY_SIZE          FRAME_NUMBER*FRAME_SIZE\n```\n![图像数据空间分配](https://img-blog.csdnimg.cn/20201130102605383.PNG#pic_center)\n\n定义共享内存类SHAREDMEMORY\n```cpp\nclass SHAREDMEMORY\n{\npublic:\n\tSHAREDMEMORY();\n\t~SHAREDMEMORY();\n\n\t//void SendBox(TrackBox& BOX);\n\t//void RecBox(TrackBox& BOX);\n\t//void SendVectorBox(vector<TrackBox>& VTrackBox);\n\t//void RecieveVectorBox(vector<TrackBox>& VTrackBox);\n\tvoid SendMat(cv::Mat img, char indexAddress);\n\tcv::Mat  ReceiveMat(char indexAddress);\n\tvoid SendStr(const char data[]);  \n\tchar* ReceiveStr();\n\npublic:\n\tint state;\nprivate:\n\tHANDLE hShareMem;                               //共享内存句柄\n\tTCHAR sShareMemName[30] = TEXT(\"CppPytonSharedFrame\"); // 共享内存名称\n\tLPCTSTR pBuf;\t\n};\n```\n其中SendMat为图像数据发送，ReceiveMat为图像接收。\nSendStr为字符串发送，ReceiveStr为字符串接收。\n\n最后的**ShareMemory.h**文件如下：\n```cpp\n#pragma once\n// ShareMemory.h : 此文件包含共享内存数据定义、大小确定、位置分配、信息定义\n// Author : Jiejing.Ma\n// Update : 2020/11/27\n#ifndef ShareMemory_H\n#define ShareMemory_H\n\n#include <opencv2/core.hpp>\n#include <opencv2/videoio.hpp>\n#include <opencv2/highgui.hpp>\n#include <opencv2/imgproc.hpp>  // cv::Canny()\n#include <opencv2/opencv.hpp>\n\n#include <Windows.h>\n\n//=================================共享内存数据定义=================================\ntypedef struct {\n\tint width;\n\tint height;\n\tint type;\n}ImgInf;       //图像信息\n//=================================共享内存大小确定=================================\n// 为图像分配空间\n#define FRAME_NUMBER         1               // 图像路数\n#define FRAME_W              1920\n#define FRAME_H              1080\n#define FRAME_W_H            FRAME_W*FRAME_H\n// 图像分辨率：彩色图（3通道）+图像信息结构体\n#define FRAME_SIZE           FRAME_W_H*sizeof(unsigned char)*3+sizeof(ImgInf)\n\n#define MEMORY_SIZE          FRAME_NUMBER*FRAME_SIZE\n\n//=================================共享内存信息定义=================================\n#define INITSUCCESS      0\n#define CREATEMAPFAILED  1\n#define MAPVIEWFAILED    2\n\nclass SHAREDMEMORY\n{\npublic:\n\tSHAREDMEMORY();\n\t~SHAREDMEMORY();\n\tvoid SendMat(cv::Mat img, char indexAddress);\n\tcv::Mat  ReceiveMat(char indexAddress);\n\tvoid SendStr(const char data[]);\n\tchar* ReceiveStr();\n\npublic:\n\tint state;\nprivate:\n\tHANDLE hShareMem;                               //共享内存句柄\n\tTCHAR sShareMemName[30] = TEXT(\"ShareMedia\");   // 共享内存名称\n\tLPCTSTR pBuf;\t\n};\n\n#endif // !ShareMemory_H\n```\n对应的**ShareMemory.cpp**文件为类的实现。\n```cpp\n#pragma once \n// ShareMemory.cpp : 此文件包含信息定义SHAREDMEMOR类的实现\n// Author : MJJ\n// Update : 2020/11/27\n#ifndef ShareMemory_CPP\n#define ShareMemory_CPP\n\n#include \"ShareMemory.h\"\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\n/*************************************************************************************\nFuncName  :SHAREDMEMORY::~SHAREDMEMORY()\nDesc      :构造函数创建共享内存\nInput     :None\nOutput    :None\n**************************************************************************************/\nSHAREDMEMORY::SHAREDMEMORY() {\n\thShareMem = CreateFileMapping(\n\t\tINVALID_HANDLE_VALUE,  // use paging file\n\t\tNULL,                  //default security\n\t\tPAGE_READWRITE,        //read/write access\n\t\t0,                     // maximum object size(high-order DWORD)\n\t\tMEMORY_SIZE,           //maximum object size(low-order DWORD)\n\t\tsShareMemName);        //name of mapping object\n\n\tif (hShareMem) {\n\t\t//  映射对象视图，得到共享内存指针，设置数据\n\t\tpBuf = (LPTSTR)MapViewOfFile(\n\t\t\thShareMem,           //handle to map object\n\t\t\tFILE_MAP_ALL_ACCESS, // read/write permission\n\t\t\t0,\n\t\t\t0,\n\t\t\tMEMORY_SIZE);\n\t\tcout << \"memory size:\" << MEMORY_SIZE<< endl;\n\n\t\t// 若映射失败退出\n\t\tif (pBuf == NULL)\n\t\t{\n\t\t\tstd::cout << \"Could not map view of framebuffer file.\" << GetLastError() << std::endl;\n\t\t\tCloseHandle(hShareMem);\n\t\t\tstate = MAPVIEWFAILED;\n\t\t}\n\t}\n\telse\n\t{\n\t\tstd::cout << \"Could not create file mapping object.\" << GetLastError() << std::endl;\n\t\tstate = CREATEMAPFAILED;\n\t}\n\tstate = INITSUCCESS;\n}\n\n/*************************************************************************************\nFuncName  :SHAREDMEMORY::~SHAREDMEMORY()\nDesc      :析构函数释放\nInput     :None\nOutput    :None\n**************************************************************************************/\nSHAREDMEMORY::~SHAREDMEMORY() {\n\tstd::cout << \"unmap shared addr.\" << std::endl;\n\tUnmapViewOfFile(pBuf); //释放；\n\tCloseHandle(hShareMem);\n}\n\n/*************************************************************************************\nFuncName  :void SHAREDMEMORY::SendMat(cv::Mat img, char indexAddress)\nDesc      :发送Mat数据\nInput     :\n\tMat img               发送图像\n\tchar indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :None\n**************************************************************************************/\nvoid SHAREDMEMORY::SendMat(cv::Mat img, char indexAddress) {\n\tImgInf img_head;\n\timg_head.width = img.cols;\n\timg_head.height = img.rows;\n\timg_head.type = img.type();\n\n\tif (img_head.type == CV_64FC1) {\n\t\tmemcpy((char*)pBuf + indexAddress, &img_head, sizeof(ImgInf));\n\t\tmemcpy((char*)pBuf + indexAddress + sizeof(ImgInf),        // Address of dst\n\t\t\timg.data,                                              // Src data\n\t\t\timg.cols * img.rows * img.channels() * sizeof(double)  // size of data\n\t\t);\n\t}\n\telse\n\t{\n\t\tmemcpy((char*)pBuf + indexAddress, &img_head, sizeof(ImgInf));\n\t\tmemcpy((char*)pBuf + indexAddress + sizeof(ImgInf),        // Address of dst\n\t\t\timg.data,                                              // Src data\n\t\t\timg.cols * img.rows * img.channels()                   // size of data\n\t\t);\t\t\n\t}\n\tcout << \"write shared mem successful.\" << endl;\n}\n\n\n/*************************************************************************************\nFuncName  :cv::Mat SHAREDMEMORY::ReceiveMat(char indexAddress)\nDesc      :接收Mat数据\nInput     :\n\tchar indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :Mat图像\n**************************************************************************************/\ncv::Mat SHAREDMEMORY::ReceiveMat(char indexAddress)\n{\n\tImgInf img_head;\n\tcv::Mat img;\n\tmemcpy(&img_head, (char*)pBuf + indexAddress, sizeof(ImgInf));\n\timg.create(img_head.height, img_head.width, img_head.type);\n\tif (img_head.type == CV_64FC1)\n\t{\n\t\tmemcpy(img.data, (char*)pBuf + indexAddress + sizeof(ImgInf), img.cols * img.rows * img.channels() * sizeof(double));\n\t}\n\telse\n\t{\n\t\tmemcpy(img.data, (char*)pBuf + indexAddress + sizeof(ImgInf), img.cols * img.rows * img.channels());\n\t}\n\treturn img;\n}\n\n/*************************************************************************************\nFuncName  :void SHAREDMEMORY::SendStr(cv::Mat img, char indexAddress)\nDesc      :发送str数据\nInput     :\n\tMat img               发送图像\n\tchar indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :None\n**************************************************************************************/\nvoid SHAREDMEMORY::SendStr(const char data[]) {\n\tmemcpy((char*)pBuf, data, sizeof(data));\n\tcout << \"write shared mem successful.\" << endl;\n\tgetchar();\n}\n\n/*************************************************************************************\nFuncName  :void SHAREDMEMORY::ReceiveStr()\nDesc      :接收str数据\nInput     :None\nOutput    :获取的字符串\n**************************************************************************************/\nchar* SHAREDMEMORY::ReceiveStr(){\n\tchar* str= (char*)pBuf;\n\tcout << \"receive is:\"<< str << endl;\n\treturn str;\n}\n#endif // !ShareMemory_CPP\n```\n### 2.1.3 C++之间共享内存通信\n创建一个新的工程，导入上面两个文件，并创建**WriteMem.cpp**文件\n```cpp\n// WriteMem.cpp : 此文件为写共享内存\n// Author : Jiejing.Ma\n// Update : 2020/11/27\n\n#include <iostream>\n#include \"ShareMemory.h\"\n\nusing namespace std;\nusing namespace cv;\n\n// 读图片或视频\nvoid send_img(SHAREDMEMORY sharedsend)\n{\n\tint index = 0;\n\tint64 t0 = cv::getTickCount();;\n\tint64 t1 = 0;\n\tstring fps = \"\";\n\tint nFrames = 0;\n\t\n\tcv::Mat frame;\n\n\tcout << \"Opening video...\" << endl;\n\tVideoCapture cap(\"test.flv\");\n\twhile (cap.isOpened()) \n\t{\n\t\tcap >> frame;\n\t\tif (frame.empty())\n\t\t{\n\t\t\tstd::cerr << \"ERROR: Can't grab video frame.\" << endl;\n\t\t\tbreak;\n\t\t}\n\t\tresize(frame, frame, Size(FRAME_W, FRAME_H));\n\n\t\tnFrames++;\n\t\t\n\t\tif (!frame.empty()) {\n\t\t\tif (nFrames % 10 == 0)\n\t\t\t{\n\t\t\t\tconst int N = 10;\n\t\t\t\tint64 t1 = cv::getTickCount();\n\t\t\t\tfps = \" Send FPS:\" + to_string((double)getTickFrequency() * N / (t1 - t0)) + \"fps\";\t\n\t\t\t\tt0 = t1;\n\t\t\t}\n\t\t\tcv::putText(frame, fps, Point(100, 100), cv::FONT_HERSHEY_COMPLEX, 1, cv::Scalar(255, 255, 255),1);\n\t\t}\n\t\tsharedsend.SendMat(frame, index * FRAME_NUMBER);\n\t\t\n\n\t\tif ((waitKey(1) & 0xFF) == 'q') break;\n\t}\n}\n\n\nint main()\n{\n\tSHAREDMEMORY sharedmem;\n\t//char str[] = \"hello\";\n\tif (sharedmem.state == INITSUCCESS) send_img(sharedmem);\n\t//if (sharedmem.state == INITSUCCESS) sharedmem.SendStr(str);\n\n\treturn 0;\n}\n```\n\n创建一个新的工程，导入上面两个文件，并创建**ReadMem.cpp**文件\n```cpp\n// ReadMem.cpp : 此文件为读共享内存\n// Author : Jiejing.Ma\n// Update : 2020/11/27\n\n#include <Windows.h>  \n#include <iostream>\n#include \"ShareMemory.h\"\n#include <string>\n\nusing namespace std;\nusing namespace cv;\n\nint main(int argc, char** argv)\n{\n\tint index=0;\n\tSHAREDMEMORY sharemem;\n\tif (sharemem.state == INITSUCCESS) \n\t{\n\t\t// read video frame from shared memory.s\n\t\tint64 t0 = cv::getTickCount();;\n\t\tint64 t1 = 0;\n\t\tstring fps = \"\";\n\t\tint nFrames = 0;\n\t\tnamedWindow(\"ReadMemShow\", 0);\n\n\t\twhile (true)\n\t\t{\n\t\t\tnFrames++;\n\t\t\tMat frame = sharemem.RecieveMat(index * FRAME_NUMBER);\n\n\t\t\tif (!frame.empty()) {\n\t\t\t\tif (nFrames % 10 == 0)\n\t\t\t\t{\n\t\t\t\t\tconst int N = 10;\n\t\t\t\t\tint64 t1 = cv::getTickCount();\n\t\t\t\t\tfps = \" Average FPS:\" + to_string((double)getTickFrequency() * N / (t1 - t0)) + \"fps\";\n\t\t\t\t\tt0 = t1;\n\t\t\t\t}\n\t\t\t\tcv::putText(frame, fps, Point(100, 200), cv::FONT_HERSHEY_COMPLEX, 1, cv::Scalar(100, 200, 200),1);\n\t\t\t\timshow(\"ReadMemShow\", frame);\t\t\t\t\n\t\t\t}\n\t\t\tif((waitKey(1) & 0xFF) == 'q') break;\n\t\t}\n\t\t\n\t\t//char* str = sharemem.RecieveStr();\n\t}\n\tdestroyAllWindows();\n\treturn 0;\n}\n```\n同时开启两个工程，则可以接收视频了。\n\n### 2.1.4 C++之间共享内存通信视频测试结果\n这里看到，写共享内存速度为15fps，读共享内存速度为65fps（超实时），写速度主要的影响因素与opecv有关。如果优化，还需改视频编解码部分。\n![C++和python共享内存传视频测试结果](https://img-blog.csdnimg.cn/20201130204440444.png#pic_center)\n\n## 2.2 C++和python间视频通信\n这里以C++作为发送端，python作为接受端。逆向过程还有待测试。网上有教程提到python不能创建共享内存作为发送端，这种说法是错的。本人已测试过，只是发送数据都是字符串型，对于图像数据还有待研究。\n\n### 2.2.1 接口函数\n\n这里主要用到的是**mmap**和**numpy的frombuffer**.\n\n关于mmap，请参考[官网](http://doc.codingdict.com/python_352/library/mmap.html)的接口说明。十分详细，不再赘述。\n\nfrombuffer:\n\n```python\nnumpy.frombuffer(buffer, dtype=float, count=-1, offset=0)\n```\n>Interpret a buffer as a 1-dimensional array.\n\n>Parameters\nbufferbuffer_like\nAn object that exposes the buffer interface.\n\n>dtypedata-type, optional\nData-type of the returned array; default: float.\n\n>countint, optional\nNumber of items to read. -1 means all data in the buffer.\n\n>offsetint, optional\nStart reading the buffer from this offset (in bytes); default: 0.\n\n参考[官网](https://numpy.org/doc/stable/reference/generated/numpy.frombuffer.html)\n\n### 2.2.1 C++与python之间共享内存通信\n前面已经实现C++代码。不需要改动。只需启动写共享内存工程即可。\n\npython代码如下：\n```python\nimport mmap\nimport os\nimport cv2\nimport numpy as np\n\n# -----------------Define info in ShareMemory.h-----------------\nIMG_HEAD_OFFSET = 12\n# typedef struct {\n# \tint width;\n# \tint height;\n# \tint type;\n# }ImgInf;       //图像信息12字节\n\nFRAME_NUMBER = 1\nFRAME_W = 1920\nFRAME_H = 1080\nFRAME_W_H = FRAME_W * FRAME_H\nFRAME_SIZE = FRAME_W_H * 3\nMEMORY_SIZE = (FRAME_SIZE + IMG_HEAD_OFFSET) * FRAME_NUMBER\n\nsShareMemName = \"ShareMedia\"\n\nif __name__ == \"__main__\":\n    fpx = mmap.mmap(-1, FRAME_SIZE+IMG_HEAD_OFFSET, sShareMemName)\n\n    # Read img as numpy\n    cv2.namedWindow(\"python_sharedmem_show\",0)\n    t0 = cv2.getTickCount()\n    N = 50\n    nFrame = 0\n    fps = 0\n    while 1:\n        nFrame += 1\n        img = np.frombuffer(fpx, dtype=np.uint8)\n        img = img[IMG_HEAD_OFFSET:FRAME_SIZE+IMG_HEAD_OFFSET]\n        img = img.reshape((FRAME_H,FRAME_W,3))\n\n\t\t# Print Average  FPS\n        if nFrame % 50 == 0:\n            t1 = cv2.getTickCount()\n            fps = N*cv2.getTickFrequency() / (t1 - t0)\n            t0 = t1\n        cv2.putText(img, \"Average FPS:\" + str(fps) + \"fps\", (100, 200), cv2.FONT_HERSHEY_COMPLEX, 1, (100, 200, 200), 1)\n        cv2.imshow(\"python_sharedmem_show\", img)\n        img = None\n        if cv2.waitKey(1) & 0xFF == ord('q'):\n            break\n\n    cv2.destroyAllWindows()\n```\n\n# 3.基于Socket的视频传输\n这里是基于Linux开发的Socket通信。而共享内存是基于Windows平台。\n\n## 3.1 cpp端socket\ncppsocket.cpp\n```cpp\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n\n#include <errno.h>\n#include <string>\n#include <iostream>\n#include <vector>\n\n#include <opencv2/opencv.hpp>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n    // 定义socket信息\n    char *servInetAddr = \"192.168.113.173\";\n    int servPort = 8081;\n    int connfd;\n    struct sockaddr_in addr;\n    \n    // 创建socket\n    connfd = socket(AF_INET,SOCK_STREAM, 0);\n    if (connfd == -1)\n    {\n        cout<<\"socket创建失败\"<<endl;\n        exit(-1);\n    }\n\n    // 准备通信地址\n    addr.sin_family=AF_INET;\n    addr.sin_port=htons(servPort);\n    addr.sin_addr.s_addr = inet_addr(servInetAddr);\n\n    // bind\n    int res = connect(connfd,(struct sockaddr*)&addr,sizeof(addr));\n    if(res==-1)\n    {\n        cout<<\"bind连接失败\"<<endl;\n        exit(-1);\n    }\n    cout<<\"bind连接成功\"<<endl;\n\n    // 获取视频帧并发送\n    Mat img;\n    VideoCapture capture(\"./test.flv\");\n    vector<uchar> data_encode;\n\n    while(capture.isOpened()){\n        if(!capture.read(img)) break;\n\n        imencode(\".jpg\",img,data_encode);\n        int len_encode = data_encode.size();\n        string len = to_string(len_encode);\n        int length = len.length(); \n        for (int i=0;i<16-length;i++) len=len+' ';\n\n        // 发送数据\n        send(connfd,len.c_str(),strlen(len.c_str()),0);\n        char send_char[1];\n        for (int i=0;i<len_encode;i++)\n        {\n            send_char[0]=data_encode[i];\n            send(connfd,send_char,1,0);\n        }\n\n        // 接收返回信息\n        char recvBuf[32] = \"\";\n        if(recv(connfd, recvBuf,32,0)) cout<<recvBuf<<endl;\n    }\n\n    close(connfd);\n    return 0;\n\n}\n```\n## 3.2 python端\npysocket.py\n```python\nimport socket\nimport cv2\nimport numpy\nimport time\n\ndef recv_size(sock, count):\n    buf=b''\n    while count:\n        newbuf = sock.recv(count)\n        if not newbuf: return None\n        buf +=newbuf\n        count -= len(newbuf)\n    return buf\n\n\ndef recv_all(sock, count):\n    buf = b''\n    while count:\n        newbuf = sock.recv(1)\n        if not newbuf:return None\n        buf +=newbuf\n        count -= len(newbuf)\n    return buf\n\n# 创建socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# 准备通信地址\naddress = ('192.168.113.173',8081)\ns.bind(address)\ns.listen(True)\nprint('Waiting for images...')\n# 接受TCP链接并返回（conn, addr），其中conn是新的套接字对象，可以用来接收和发送数据，addr是链接客户端的地址。\nconn, addr = s.accept()\nn = 0\n\nwhile 1:\n    n +=1\n    length = recv_size(conn,16).decode()\n    t0=time.time()\n    if isinstance(length,str):  # 若成功接收指定大小信息，进一步接收整张图\n        string_data = recv_all(conn,int(length))\n        data = numpy.fromstring(string_data,dtype='uint8')\n        decimg = cv2.imdecode(data,1)\n\n        cv2.namedWindow('python-recv')\n        cv2.imshow('python-recv',decimg)\n\n        if cv2.waitKey(1) & 0xFF == ord('q'):\n            print(\"111111\")\n            break\n        t1 = time.time()\n        print('Image recieved successfully!fps:'+str(1/(t1-t0)))\n        conn.send('recieved messages!'.encode())\n        t0=t1\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\n\ns.close()\ncv2.destroyAllWindows()\n```\n## 3.3 CMakeList\nLinux 下编译CPP文件，这里使用CMakeList:\n```shell\ncmake_minimum_required(VERSION 3.0.0)\nproject(client VERSION 0.1.0)\n\ninclude(CTest)\nenable_testing()\n\n# find opencv and link\nfind_package(OpenCV REQUIRED)\nmessage(STATUS \"Opencv library status:\")\nmessage(STATUS \" version:${OpenCV_VERSION}\")\nmessage(STATUS \" libraries:${OpenCV_LIBS}\")\nmessage(STATUS \" include path:${OpenCV_INCLUDE_DIRS}\")\ninclude_directories(${OpenCV_INCLUDE_DIRS})\nlink_libraries(${OpenCV_LIBS})\n\nadd_executable(client cppsocket.cpp)\n\nset(CMAKE_CXX_FLAGE \"${CMAKE_CXX_FLAGE} -g\")\n```\n## 3.4 测试结果\n结果就是速度超级慢，大概一秒多一帧。\n\n# 4 结论\nC++和python之间通信，可以采用**C++调python**的方式。请参考之前的文章。[Ubuntu下C++调python](https://blog.csdn.net/weixin_38369492/article/details/110090225)\n这种方式，从架构的角度来讲，最简单。工程量和已有经验的角度，emm可能坑比较多。速度也应该最快（推测）\n\n也可以使用**进程间通信**。当然这个成本就高了。有两种方式，一是**共享内存**机制，一是**socket通信**。前者更快，但只能在一个平台上。后者慢，可以支持不同电脑间通信。\n\n最后关于基于共享内存方式，影响**速度**的主要是**写共享内存**，而这又与**opencv**读视频有关，与**视频编解码**有关。想要提高写内存速度，需要从底层修改视频编解码。可以参考**UE4**的相关插件解决。","source":"_posts/Communication/在C++与python间传视频帧.md","raw":"\n---\ntitle: 在C++与python间传视频帧\ndate: 2020-11-30 21:37:33\nauthor: 马捷径\nimg: https://img-blog.csdnimg.cn/20201130204440444.png\ntop: true\ncover: true\ncoverImg: https://img-blog.csdnimg.cn/20201130204440444.png\ntoc: true\nmathjax: true\nsummary: 本案例旨在实现跨语言（C++和python间）视频的实时通信。这一工作内容在实际工程中很常见。由于python语言支持很多第三方库，对于开发深度学习项目很方便，验真算法速度快，很多开源算法也大多基于python实现。这时可能就会出现C++的代码借助python语言做一些图像处理（包括目标检测、姿态估计、目标跟踪等任务）的需求。\nkeywords: \n  - 通信 \n  - 共享内存\n  - socket\n  - C++\n  - python\ncategories: Communication\ntags:\n  - 共享内存\n  - socket\n---\n\n# 引言\n本案例旨在实现跨语言（C++和python间）视频的实时通信。这一工作内容在实际工程中很常见。由于python语言支持很多第三方库，对于开发深度学习项目很方便，验真算法速度快，很多开源算法也大多基于python实现。这时可能就会出现C++的代码借助python语言做一些图像处理（包括目标检测、姿态估计、目标跟踪等任务）的需求。\n\n平台环境：\n- Win10\n- VS2019\n- OpenCV\n\n进程间通信方式：共享内存\n\n# 1.进程间通信\n\n进程间通信方式有很多种。工程上最常用的是**共享内存**和**socket机制**。前者效率高，基本思想就是开辟一块公共的内存空间，供两个或多个进程之间使用。为了标识这个公共空间，要给它起个名。但是共享内存的方式不支持多平台。而socket刚好就是支持多平台间进程通信的方式。当然这种方式也会慢一些。\n\n在本案例中，分别尝试了两种方式。虽然最终共享内存的方式写内存帧率只达到15fps左右，但是要比socket快了近20倍（大概0.5-1fps左右）。下面将介绍这两种机制的具体实现过程。\n\n# 2.基于共享内存的视频传输\n## 2.1 C++之间的通信\n### 2.1.1 接口函数\n首先验证C++之间能通信。这里使用的是[CreateFileMapping](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga)和[MapViewOfFile](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile)进行共享内存的创建和映射。\n\n其中[CreateFileMapping](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga)的接口为，参数含义详解请点击链接。\n```cpp\nHANDLE CreateFileMapping(\n  HANDLE                hFile,\n  LPSECURITY_ATTRIBUTES lpFileMappingAttributes,\n  DWORD                 flProtect,\n  DWORD                 dwMaximumSizeHigh,\n  DWORD                 dwMaximumSizeLow,\n  LPCSTR                lpName\n);\n```\n\n[MapViewOfFile](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile)的接口为\n```cpp\nLPVOID MapViewOfFile(\n  HANDLE hFileMappingObject,\n  DWORD  dwDesiredAccess,\n  DWORD  dwFileOffsetHigh,\n  DWORD  dwFileOffsetLow,\n  SIZE_T dwNumberOfBytesToMap\n);\n```\n### 2.1.2 创建数据格式和共享内存信息\n首先需要一个图像的头部\n```cpp\ntypedef struct {\n\tint width;\n\tint height;\n\tint type;\n}ImgInf;       //图像信息\n```\n由于sizeof(int)=4，所以这里ImgInf结构体大小为12B。在进行共享内存映射时，我们需要这个大小去做偏移量，找到图像数据。\n\n接下来要定义图像的数据信息\n```cpp\n#define FRAME_NUMBER         1               // 图像路数\n#define FRAME_W              1920\n#define FRAME_H              1080\n#define FRAME_W_H            FRAME_W*FRAME_H\n// 图像分辨率：彩色图（3通道）+图像信息结构体\n#define FRAME_SIZE           FRAME_W_H*sizeof(unsigned char)*3+sizeof(ImgInf)\n\n#define MEMORY_SIZE          FRAME_NUMBER*FRAME_SIZE\n```\n![图像数据空间分配](https://img-blog.csdnimg.cn/20201130102605383.PNG#pic_center)\n\n定义共享内存类SHAREDMEMORY\n```cpp\nclass SHAREDMEMORY\n{\npublic:\n\tSHAREDMEMORY();\n\t~SHAREDMEMORY();\n\n\t//void SendBox(TrackBox& BOX);\n\t//void RecBox(TrackBox& BOX);\n\t//void SendVectorBox(vector<TrackBox>& VTrackBox);\n\t//void RecieveVectorBox(vector<TrackBox>& VTrackBox);\n\tvoid SendMat(cv::Mat img, char indexAddress);\n\tcv::Mat  ReceiveMat(char indexAddress);\n\tvoid SendStr(const char data[]);  \n\tchar* ReceiveStr();\n\npublic:\n\tint state;\nprivate:\n\tHANDLE hShareMem;                               //共享内存句柄\n\tTCHAR sShareMemName[30] = TEXT(\"CppPytonSharedFrame\"); // 共享内存名称\n\tLPCTSTR pBuf;\t\n};\n```\n其中SendMat为图像数据发送，ReceiveMat为图像接收。\nSendStr为字符串发送，ReceiveStr为字符串接收。\n\n最后的**ShareMemory.h**文件如下：\n```cpp\n#pragma once\n// ShareMemory.h : 此文件包含共享内存数据定义、大小确定、位置分配、信息定义\n// Author : Jiejing.Ma\n// Update : 2020/11/27\n#ifndef ShareMemory_H\n#define ShareMemory_H\n\n#include <opencv2/core.hpp>\n#include <opencv2/videoio.hpp>\n#include <opencv2/highgui.hpp>\n#include <opencv2/imgproc.hpp>  // cv::Canny()\n#include <opencv2/opencv.hpp>\n\n#include <Windows.h>\n\n//=================================共享内存数据定义=================================\ntypedef struct {\n\tint width;\n\tint height;\n\tint type;\n}ImgInf;       //图像信息\n//=================================共享内存大小确定=================================\n// 为图像分配空间\n#define FRAME_NUMBER         1               // 图像路数\n#define FRAME_W              1920\n#define FRAME_H              1080\n#define FRAME_W_H            FRAME_W*FRAME_H\n// 图像分辨率：彩色图（3通道）+图像信息结构体\n#define FRAME_SIZE           FRAME_W_H*sizeof(unsigned char)*3+sizeof(ImgInf)\n\n#define MEMORY_SIZE          FRAME_NUMBER*FRAME_SIZE\n\n//=================================共享内存信息定义=================================\n#define INITSUCCESS      0\n#define CREATEMAPFAILED  1\n#define MAPVIEWFAILED    2\n\nclass SHAREDMEMORY\n{\npublic:\n\tSHAREDMEMORY();\n\t~SHAREDMEMORY();\n\tvoid SendMat(cv::Mat img, char indexAddress);\n\tcv::Mat  ReceiveMat(char indexAddress);\n\tvoid SendStr(const char data[]);\n\tchar* ReceiveStr();\n\npublic:\n\tint state;\nprivate:\n\tHANDLE hShareMem;                               //共享内存句柄\n\tTCHAR sShareMemName[30] = TEXT(\"ShareMedia\");   // 共享内存名称\n\tLPCTSTR pBuf;\t\n};\n\n#endif // !ShareMemory_H\n```\n对应的**ShareMemory.cpp**文件为类的实现。\n```cpp\n#pragma once \n// ShareMemory.cpp : 此文件包含信息定义SHAREDMEMOR类的实现\n// Author : MJJ\n// Update : 2020/11/27\n#ifndef ShareMemory_CPP\n#define ShareMemory_CPP\n\n#include \"ShareMemory.h\"\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\n/*************************************************************************************\nFuncName  :SHAREDMEMORY::~SHAREDMEMORY()\nDesc      :构造函数创建共享内存\nInput     :None\nOutput    :None\n**************************************************************************************/\nSHAREDMEMORY::SHAREDMEMORY() {\n\thShareMem = CreateFileMapping(\n\t\tINVALID_HANDLE_VALUE,  // use paging file\n\t\tNULL,                  //default security\n\t\tPAGE_READWRITE,        //read/write access\n\t\t0,                     // maximum object size(high-order DWORD)\n\t\tMEMORY_SIZE,           //maximum object size(low-order DWORD)\n\t\tsShareMemName);        //name of mapping object\n\n\tif (hShareMem) {\n\t\t//  映射对象视图，得到共享内存指针，设置数据\n\t\tpBuf = (LPTSTR)MapViewOfFile(\n\t\t\thShareMem,           //handle to map object\n\t\t\tFILE_MAP_ALL_ACCESS, // read/write permission\n\t\t\t0,\n\t\t\t0,\n\t\t\tMEMORY_SIZE);\n\t\tcout << \"memory size:\" << MEMORY_SIZE<< endl;\n\n\t\t// 若映射失败退出\n\t\tif (pBuf == NULL)\n\t\t{\n\t\t\tstd::cout << \"Could not map view of framebuffer file.\" << GetLastError() << std::endl;\n\t\t\tCloseHandle(hShareMem);\n\t\t\tstate = MAPVIEWFAILED;\n\t\t}\n\t}\n\telse\n\t{\n\t\tstd::cout << \"Could not create file mapping object.\" << GetLastError() << std::endl;\n\t\tstate = CREATEMAPFAILED;\n\t}\n\tstate = INITSUCCESS;\n}\n\n/*************************************************************************************\nFuncName  :SHAREDMEMORY::~SHAREDMEMORY()\nDesc      :析构函数释放\nInput     :None\nOutput    :None\n**************************************************************************************/\nSHAREDMEMORY::~SHAREDMEMORY() {\n\tstd::cout << \"unmap shared addr.\" << std::endl;\n\tUnmapViewOfFile(pBuf); //释放；\n\tCloseHandle(hShareMem);\n}\n\n/*************************************************************************************\nFuncName  :void SHAREDMEMORY::SendMat(cv::Mat img, char indexAddress)\nDesc      :发送Mat数据\nInput     :\n\tMat img               发送图像\n\tchar indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :None\n**************************************************************************************/\nvoid SHAREDMEMORY::SendMat(cv::Mat img, char indexAddress) {\n\tImgInf img_head;\n\timg_head.width = img.cols;\n\timg_head.height = img.rows;\n\timg_head.type = img.type();\n\n\tif (img_head.type == CV_64FC1) {\n\t\tmemcpy((char*)pBuf + indexAddress, &img_head, sizeof(ImgInf));\n\t\tmemcpy((char*)pBuf + indexAddress + sizeof(ImgInf),        // Address of dst\n\t\t\timg.data,                                              // Src data\n\t\t\timg.cols * img.rows * img.channels() * sizeof(double)  // size of data\n\t\t);\n\t}\n\telse\n\t{\n\t\tmemcpy((char*)pBuf + indexAddress, &img_head, sizeof(ImgInf));\n\t\tmemcpy((char*)pBuf + indexAddress + sizeof(ImgInf),        // Address of dst\n\t\t\timg.data,                                              // Src data\n\t\t\timg.cols * img.rows * img.channels()                   // size of data\n\t\t);\t\t\n\t}\n\tcout << \"write shared mem successful.\" << endl;\n}\n\n\n/*************************************************************************************\nFuncName  :cv::Mat SHAREDMEMORY::ReceiveMat(char indexAddress)\nDesc      :接收Mat数据\nInput     :\n\tchar indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :Mat图像\n**************************************************************************************/\ncv::Mat SHAREDMEMORY::ReceiveMat(char indexAddress)\n{\n\tImgInf img_head;\n\tcv::Mat img;\n\tmemcpy(&img_head, (char*)pBuf + indexAddress, sizeof(ImgInf));\n\timg.create(img_head.height, img_head.width, img_head.type);\n\tif (img_head.type == CV_64FC1)\n\t{\n\t\tmemcpy(img.data, (char*)pBuf + indexAddress + sizeof(ImgInf), img.cols * img.rows * img.channels() * sizeof(double));\n\t}\n\telse\n\t{\n\t\tmemcpy(img.data, (char*)pBuf + indexAddress + sizeof(ImgInf), img.cols * img.rows * img.channels());\n\t}\n\treturn img;\n}\n\n/*************************************************************************************\nFuncName  :void SHAREDMEMORY::SendStr(cv::Mat img, char indexAddress)\nDesc      :发送str数据\nInput     :\n\tMat img               发送图像\n\tchar indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :None\n**************************************************************************************/\nvoid SHAREDMEMORY::SendStr(const char data[]) {\n\tmemcpy((char*)pBuf, data, sizeof(data));\n\tcout << \"write shared mem successful.\" << endl;\n\tgetchar();\n}\n\n/*************************************************************************************\nFuncName  :void SHAREDMEMORY::ReceiveStr()\nDesc      :接收str数据\nInput     :None\nOutput    :获取的字符串\n**************************************************************************************/\nchar* SHAREDMEMORY::ReceiveStr(){\n\tchar* str= (char*)pBuf;\n\tcout << \"receive is:\"<< str << endl;\n\treturn str;\n}\n#endif // !ShareMemory_CPP\n```\n### 2.1.3 C++之间共享内存通信\n创建一个新的工程，导入上面两个文件，并创建**WriteMem.cpp**文件\n```cpp\n// WriteMem.cpp : 此文件为写共享内存\n// Author : Jiejing.Ma\n// Update : 2020/11/27\n\n#include <iostream>\n#include \"ShareMemory.h\"\n\nusing namespace std;\nusing namespace cv;\n\n// 读图片或视频\nvoid send_img(SHAREDMEMORY sharedsend)\n{\n\tint index = 0;\n\tint64 t0 = cv::getTickCount();;\n\tint64 t1 = 0;\n\tstring fps = \"\";\n\tint nFrames = 0;\n\t\n\tcv::Mat frame;\n\n\tcout << \"Opening video...\" << endl;\n\tVideoCapture cap(\"test.flv\");\n\twhile (cap.isOpened()) \n\t{\n\t\tcap >> frame;\n\t\tif (frame.empty())\n\t\t{\n\t\t\tstd::cerr << \"ERROR: Can't grab video frame.\" << endl;\n\t\t\tbreak;\n\t\t}\n\t\tresize(frame, frame, Size(FRAME_W, FRAME_H));\n\n\t\tnFrames++;\n\t\t\n\t\tif (!frame.empty()) {\n\t\t\tif (nFrames % 10 == 0)\n\t\t\t{\n\t\t\t\tconst int N = 10;\n\t\t\t\tint64 t1 = cv::getTickCount();\n\t\t\t\tfps = \" Send FPS:\" + to_string((double)getTickFrequency() * N / (t1 - t0)) + \"fps\";\t\n\t\t\t\tt0 = t1;\n\t\t\t}\n\t\t\tcv::putText(frame, fps, Point(100, 100), cv::FONT_HERSHEY_COMPLEX, 1, cv::Scalar(255, 255, 255),1);\n\t\t}\n\t\tsharedsend.SendMat(frame, index * FRAME_NUMBER);\n\t\t\n\n\t\tif ((waitKey(1) & 0xFF) == 'q') break;\n\t}\n}\n\n\nint main()\n{\n\tSHAREDMEMORY sharedmem;\n\t//char str[] = \"hello\";\n\tif (sharedmem.state == INITSUCCESS) send_img(sharedmem);\n\t//if (sharedmem.state == INITSUCCESS) sharedmem.SendStr(str);\n\n\treturn 0;\n}\n```\n\n创建一个新的工程，导入上面两个文件，并创建**ReadMem.cpp**文件\n```cpp\n// ReadMem.cpp : 此文件为读共享内存\n// Author : Jiejing.Ma\n// Update : 2020/11/27\n\n#include <Windows.h>  \n#include <iostream>\n#include \"ShareMemory.h\"\n#include <string>\n\nusing namespace std;\nusing namespace cv;\n\nint main(int argc, char** argv)\n{\n\tint index=0;\n\tSHAREDMEMORY sharemem;\n\tif (sharemem.state == INITSUCCESS) \n\t{\n\t\t// read video frame from shared memory.s\n\t\tint64 t0 = cv::getTickCount();;\n\t\tint64 t1 = 0;\n\t\tstring fps = \"\";\n\t\tint nFrames = 0;\n\t\tnamedWindow(\"ReadMemShow\", 0);\n\n\t\twhile (true)\n\t\t{\n\t\t\tnFrames++;\n\t\t\tMat frame = sharemem.RecieveMat(index * FRAME_NUMBER);\n\n\t\t\tif (!frame.empty()) {\n\t\t\t\tif (nFrames % 10 == 0)\n\t\t\t\t{\n\t\t\t\t\tconst int N = 10;\n\t\t\t\t\tint64 t1 = cv::getTickCount();\n\t\t\t\t\tfps = \" Average FPS:\" + to_string((double)getTickFrequency() * N / (t1 - t0)) + \"fps\";\n\t\t\t\t\tt0 = t1;\n\t\t\t\t}\n\t\t\t\tcv::putText(frame, fps, Point(100, 200), cv::FONT_HERSHEY_COMPLEX, 1, cv::Scalar(100, 200, 200),1);\n\t\t\t\timshow(\"ReadMemShow\", frame);\t\t\t\t\n\t\t\t}\n\t\t\tif((waitKey(1) & 0xFF) == 'q') break;\n\t\t}\n\t\t\n\t\t//char* str = sharemem.RecieveStr();\n\t}\n\tdestroyAllWindows();\n\treturn 0;\n}\n```\n同时开启两个工程，则可以接收视频了。\n\n### 2.1.4 C++之间共享内存通信视频测试结果\n这里看到，写共享内存速度为15fps，读共享内存速度为65fps（超实时），写速度主要的影响因素与opecv有关。如果优化，还需改视频编解码部分。\n![C++和python共享内存传视频测试结果](https://img-blog.csdnimg.cn/20201130204440444.png#pic_center)\n\n## 2.2 C++和python间视频通信\n这里以C++作为发送端，python作为接受端。逆向过程还有待测试。网上有教程提到python不能创建共享内存作为发送端，这种说法是错的。本人已测试过，只是发送数据都是字符串型，对于图像数据还有待研究。\n\n### 2.2.1 接口函数\n\n这里主要用到的是**mmap**和**numpy的frombuffer**.\n\n关于mmap，请参考[官网](http://doc.codingdict.com/python_352/library/mmap.html)的接口说明。十分详细，不再赘述。\n\nfrombuffer:\n\n```python\nnumpy.frombuffer(buffer, dtype=float, count=-1, offset=0)\n```\n>Interpret a buffer as a 1-dimensional array.\n\n>Parameters\nbufferbuffer_like\nAn object that exposes the buffer interface.\n\n>dtypedata-type, optional\nData-type of the returned array; default: float.\n\n>countint, optional\nNumber of items to read. -1 means all data in the buffer.\n\n>offsetint, optional\nStart reading the buffer from this offset (in bytes); default: 0.\n\n参考[官网](https://numpy.org/doc/stable/reference/generated/numpy.frombuffer.html)\n\n### 2.2.1 C++与python之间共享内存通信\n前面已经实现C++代码。不需要改动。只需启动写共享内存工程即可。\n\npython代码如下：\n```python\nimport mmap\nimport os\nimport cv2\nimport numpy as np\n\n# -----------------Define info in ShareMemory.h-----------------\nIMG_HEAD_OFFSET = 12\n# typedef struct {\n# \tint width;\n# \tint height;\n# \tint type;\n# }ImgInf;       //图像信息12字节\n\nFRAME_NUMBER = 1\nFRAME_W = 1920\nFRAME_H = 1080\nFRAME_W_H = FRAME_W * FRAME_H\nFRAME_SIZE = FRAME_W_H * 3\nMEMORY_SIZE = (FRAME_SIZE + IMG_HEAD_OFFSET) * FRAME_NUMBER\n\nsShareMemName = \"ShareMedia\"\n\nif __name__ == \"__main__\":\n    fpx = mmap.mmap(-1, FRAME_SIZE+IMG_HEAD_OFFSET, sShareMemName)\n\n    # Read img as numpy\n    cv2.namedWindow(\"python_sharedmem_show\",0)\n    t0 = cv2.getTickCount()\n    N = 50\n    nFrame = 0\n    fps = 0\n    while 1:\n        nFrame += 1\n        img = np.frombuffer(fpx, dtype=np.uint8)\n        img = img[IMG_HEAD_OFFSET:FRAME_SIZE+IMG_HEAD_OFFSET]\n        img = img.reshape((FRAME_H,FRAME_W,3))\n\n\t\t# Print Average  FPS\n        if nFrame % 50 == 0:\n            t1 = cv2.getTickCount()\n            fps = N*cv2.getTickFrequency() / (t1 - t0)\n            t0 = t1\n        cv2.putText(img, \"Average FPS:\" + str(fps) + \"fps\", (100, 200), cv2.FONT_HERSHEY_COMPLEX, 1, (100, 200, 200), 1)\n        cv2.imshow(\"python_sharedmem_show\", img)\n        img = None\n        if cv2.waitKey(1) & 0xFF == ord('q'):\n            break\n\n    cv2.destroyAllWindows()\n```\n\n# 3.基于Socket的视频传输\n这里是基于Linux开发的Socket通信。而共享内存是基于Windows平台。\n\n## 3.1 cpp端socket\ncppsocket.cpp\n```cpp\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n\n#include <errno.h>\n#include <string>\n#include <iostream>\n#include <vector>\n\n#include <opencv2/opencv.hpp>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n    // 定义socket信息\n    char *servInetAddr = \"192.168.113.173\";\n    int servPort = 8081;\n    int connfd;\n    struct sockaddr_in addr;\n    \n    // 创建socket\n    connfd = socket(AF_INET,SOCK_STREAM, 0);\n    if (connfd == -1)\n    {\n        cout<<\"socket创建失败\"<<endl;\n        exit(-1);\n    }\n\n    // 准备通信地址\n    addr.sin_family=AF_INET;\n    addr.sin_port=htons(servPort);\n    addr.sin_addr.s_addr = inet_addr(servInetAddr);\n\n    // bind\n    int res = connect(connfd,(struct sockaddr*)&addr,sizeof(addr));\n    if(res==-1)\n    {\n        cout<<\"bind连接失败\"<<endl;\n        exit(-1);\n    }\n    cout<<\"bind连接成功\"<<endl;\n\n    // 获取视频帧并发送\n    Mat img;\n    VideoCapture capture(\"./test.flv\");\n    vector<uchar> data_encode;\n\n    while(capture.isOpened()){\n        if(!capture.read(img)) break;\n\n        imencode(\".jpg\",img,data_encode);\n        int len_encode = data_encode.size();\n        string len = to_string(len_encode);\n        int length = len.length(); \n        for (int i=0;i<16-length;i++) len=len+' ';\n\n        // 发送数据\n        send(connfd,len.c_str(),strlen(len.c_str()),0);\n        char send_char[1];\n        for (int i=0;i<len_encode;i++)\n        {\n            send_char[0]=data_encode[i];\n            send(connfd,send_char,1,0);\n        }\n\n        // 接收返回信息\n        char recvBuf[32] = \"\";\n        if(recv(connfd, recvBuf,32,0)) cout<<recvBuf<<endl;\n    }\n\n    close(connfd);\n    return 0;\n\n}\n```\n## 3.2 python端\npysocket.py\n```python\nimport socket\nimport cv2\nimport numpy\nimport time\n\ndef recv_size(sock, count):\n    buf=b''\n    while count:\n        newbuf = sock.recv(count)\n        if not newbuf: return None\n        buf +=newbuf\n        count -= len(newbuf)\n    return buf\n\n\ndef recv_all(sock, count):\n    buf = b''\n    while count:\n        newbuf = sock.recv(1)\n        if not newbuf:return None\n        buf +=newbuf\n        count -= len(newbuf)\n    return buf\n\n# 创建socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# 准备通信地址\naddress = ('192.168.113.173',8081)\ns.bind(address)\ns.listen(True)\nprint('Waiting for images...')\n# 接受TCP链接并返回（conn, addr），其中conn是新的套接字对象，可以用来接收和发送数据，addr是链接客户端的地址。\nconn, addr = s.accept()\nn = 0\n\nwhile 1:\n    n +=1\n    length = recv_size(conn,16).decode()\n    t0=time.time()\n    if isinstance(length,str):  # 若成功接收指定大小信息，进一步接收整张图\n        string_data = recv_all(conn,int(length))\n        data = numpy.fromstring(string_data,dtype='uint8')\n        decimg = cv2.imdecode(data,1)\n\n        cv2.namedWindow('python-recv')\n        cv2.imshow('python-recv',decimg)\n\n        if cv2.waitKey(1) & 0xFF == ord('q'):\n            print(\"111111\")\n            break\n        t1 = time.time()\n        print('Image recieved successfully!fps:'+str(1/(t1-t0)))\n        conn.send('recieved messages!'.encode())\n        t0=t1\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\n\ns.close()\ncv2.destroyAllWindows()\n```\n## 3.3 CMakeList\nLinux 下编译CPP文件，这里使用CMakeList:\n```shell\ncmake_minimum_required(VERSION 3.0.0)\nproject(client VERSION 0.1.0)\n\ninclude(CTest)\nenable_testing()\n\n# find opencv and link\nfind_package(OpenCV REQUIRED)\nmessage(STATUS \"Opencv library status:\")\nmessage(STATUS \" version:${OpenCV_VERSION}\")\nmessage(STATUS \" libraries:${OpenCV_LIBS}\")\nmessage(STATUS \" include path:${OpenCV_INCLUDE_DIRS}\")\ninclude_directories(${OpenCV_INCLUDE_DIRS})\nlink_libraries(${OpenCV_LIBS})\n\nadd_executable(client cppsocket.cpp)\n\nset(CMAKE_CXX_FLAGE \"${CMAKE_CXX_FLAGE} -g\")\n```\n## 3.4 测试结果\n结果就是速度超级慢，大概一秒多一帧。\n\n# 4 结论\nC++和python之间通信，可以采用**C++调python**的方式。请参考之前的文章。[Ubuntu下C++调python](https://blog.csdn.net/weixin_38369492/article/details/110090225)\n这种方式，从架构的角度来讲，最简单。工程量和已有经验的角度，emm可能坑比较多。速度也应该最快（推测）\n\n也可以使用**进程间通信**。当然这个成本就高了。有两种方式，一是**共享内存**机制，一是**socket通信**。前者更快，但只能在一个平台上。后者慢，可以支持不同电脑间通信。\n\n最后关于基于共享内存方式，影响**速度**的主要是**写共享内存**，而这又与**opencv**读视频有关，与**视频编解码**有关。想要提高写内存速度，需要从底层修改视频编解码。可以参考**UE4**的相关插件解决。","slug":"Communication/在C++与python间传视频帧","published":1,"updated":"2020-11-30T13:55:43.644Z","_id":"cki4lrn540000z77ed6qcdn0v","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>本案例旨在实现跨语言（C++和python间）视频的实时通信。这一工作内容在实际工程中很常见。由于python语言支持很多第三方库，对于开发深度学习项目很方便，验真算法速度快，很多开源算法也大多基于python实现。这时可能就会出现C++的代码借助python语言做一些图像处理（包括目标检测、姿态估计、目标跟踪等任务）的需求。</p>\n<p>平台环境：</p>\n<ul>\n<li>Win10</li>\n<li>VS2019</li>\n<li>OpenCV</li>\n</ul>\n<p>进程间通信方式：共享内存</p>\n<h1 id=\"1-进程间通信\"><a href=\"#1-进程间通信\" class=\"headerlink\" title=\"1.进程间通信\"></a>1.进程间通信</h1><p>进程间通信方式有很多种。工程上最常用的是<strong>共享内存</strong>和<strong>socket机制</strong>。前者效率高，基本思想就是开辟一块公共的内存空间，供两个或多个进程之间使用。为了标识这个公共空间，要给它起个名。但是共享内存的方式不支持多平台。而socket刚好就是支持多平台间进程通信的方式。当然这种方式也会慢一些。</p>\n<p>在本案例中，分别尝试了两种方式。虽然最终共享内存的方式写内存帧率只达到15fps左右，但是要比socket快了近20倍（大概0.5-1fps左右）。下面将介绍这两种机制的具体实现过程。</p>\n<h1 id=\"2-基于共享内存的视频传输\"><a href=\"#2-基于共享内存的视频传输\" class=\"headerlink\" title=\"2.基于共享内存的视频传输\"></a>2.基于共享内存的视频传输</h1><h2 id=\"2-1-C-之间的通信\"><a href=\"#2-1-C-之间的通信\" class=\"headerlink\" title=\"2.1 C++之间的通信\"></a>2.1 C++之间的通信</h2><h3 id=\"2-1-1-接口函数\"><a href=\"#2-1-1-接口函数\" class=\"headerlink\" title=\"2.1.1 接口函数\"></a>2.1.1 接口函数</h3><p>首先验证C++之间能通信。这里使用的是<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga\">CreateFileMapping</a>和<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile\">MapViewOfFile</a>进行共享内存的创建和映射。</p>\n<p>其中<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga\">CreateFileMapping</a>的接口为，参数含义详解请点击链接。</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">HANDLE <span class=\"token function\">CreateFileMapping</span><span class=\"token punctuation\">(</span>\n  HANDLE                hFile<span class=\"token punctuation\">,</span>\n  LPSECURITY_ATTRIBUTES lpFileMappingAttributes<span class=\"token punctuation\">,</span>\n  DWORD                 flProtect<span class=\"token punctuation\">,</span>\n  DWORD                 dwMaximumSizeHigh<span class=\"token punctuation\">,</span>\n  DWORD                 dwMaximumSizeLow<span class=\"token punctuation\">,</span>\n  LPCSTR                lpName\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p><a href=\"https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile\">MapViewOfFile</a>的接口为</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">LPVOID <span class=\"token function\">MapViewOfFile</span><span class=\"token punctuation\">(</span>\n  HANDLE hFileMappingObject<span class=\"token punctuation\">,</span>\n  DWORD  dwDesiredAccess<span class=\"token punctuation\">,</span>\n  DWORD  dwFileOffsetHigh<span class=\"token punctuation\">,</span>\n  DWORD  dwFileOffsetLow<span class=\"token punctuation\">,</span>\n  SIZE_T dwNumberOfBytesToMap\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"2-1-2-创建数据格式和共享内存信息\"><a href=\"#2-1-2-创建数据格式和共享内存信息\" class=\"headerlink\" title=\"2.1.2 创建数据格式和共享内存信息\"></a>2.1.2 创建数据格式和共享内存信息</h3><p>首先需要一个图像的头部</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> width<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> height<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> type<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>ImgInf<span class=\"token punctuation\">;</span>       <span class=\"token comment\" spellcheck=\"true\">//图像信息</span></code></pre>\n<p>由于sizeof(int)=4，所以这里ImgInf结构体大小为12B。在进行共享内存映射时，我们需要这个大小去做偏移量，找到图像数据。</p>\n<p>接下来要定义图像的数据信息</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FRAME_NUMBER         1               </span><span class=\"token comment\" spellcheck=\"true\">// 图像路数</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FRAME_W              1920</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FRAME_H              1080</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FRAME_W_H            FRAME_W*FRAME_H</span>\n<span class=\"token comment\" spellcheck=\"true\">// 图像分辨率：彩色图（3通道）+图像信息结构体</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FRAME_SIZE           FRAME_W_H*sizeof(unsigned char)*3+sizeof(ImgInf)</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> MEMORY_SIZE          FRAME_NUMBER*FRAME_SIZE</span></code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201130102605383.PNG#pic_center\" alt=\"图像数据空间分配\"></p>\n<p>定义共享内存类SHAREDMEMORY</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SHAREDMEMORY</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">SHAREDMEMORY</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">SHAREDMEMORY</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//void SendBox(TrackBox&amp; BOX);</span>\n    <span class=\"token comment\" spellcheck=\"true\">//void RecBox(TrackBox&amp; BOX);</span>\n    <span class=\"token comment\" spellcheck=\"true\">//void SendVectorBox(vector&lt;TrackBox>&amp; VTrackBox);</span>\n    <span class=\"token comment\" spellcheck=\"true\">//void RecieveVectorBox(vector&lt;TrackBox>&amp; VTrackBox);</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">SendMat</span><span class=\"token punctuation\">(</span>cv<span class=\"token operator\">::</span>Mat img<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> indexAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cv<span class=\"token operator\">::</span>Mat  <span class=\"token function\">ReceiveMat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> indexAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">SendStr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> data<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> <span class=\"token function\">ReceiveStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> state<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    HANDLE hShareMem<span class=\"token punctuation\">;</span>                               <span class=\"token comment\" spellcheck=\"true\">//共享内存句柄</span>\n    TCHAR sShareMemName<span class=\"token punctuation\">[</span><span class=\"token number\">30</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">TEXT</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CppPytonSharedFrame\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 共享内存名称</span>\n    LPCTSTR pBuf<span class=\"token punctuation\">;</span>    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>其中SendMat为图像数据发送，ReceiveMat为图像接收。<br>SendStr为字符串发送，ReceiveStr为字符串接收。</p>\n<p>最后的<strong>ShareMemory.h</strong>文件如下：</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> once</span>\n<span class=\"token comment\" spellcheck=\"true\">// ShareMemory.h : 此文件包含共享内存数据定义、大小确定、位置分配、信息定义</span>\n<span class=\"token comment\" spellcheck=\"true\">// Author : Jiejing.Ma</span>\n<span class=\"token comment\" spellcheck=\"true\">// Update : 2020/11/27</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> ShareMemory_H</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ShareMemory_H</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;opencv2/core.hpp></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;opencv2/videoio.hpp></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;opencv2/highgui.hpp></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;opencv2/imgproc.hpp></span>  </span><span class=\"token comment\" spellcheck=\"true\">// cv::Canny()</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;opencv2/opencv.hpp></span></span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;Windows.h></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">//=================================共享内存数据定义=================================</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> width<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> height<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> type<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>ImgInf<span class=\"token punctuation\">;</span>       <span class=\"token comment\" spellcheck=\"true\">//图像信息</span>\n<span class=\"token comment\" spellcheck=\"true\">//=================================共享内存大小确定=================================</span>\n<span class=\"token comment\" spellcheck=\"true\">// 为图像分配空间</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FRAME_NUMBER         1               </span><span class=\"token comment\" spellcheck=\"true\">// 图像路数</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FRAME_W              1920</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FRAME_H              1080</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FRAME_W_H            FRAME_W*FRAME_H</span>\n<span class=\"token comment\" spellcheck=\"true\">// 图像分辨率：彩色图（3通道）+图像信息结构体</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FRAME_SIZE           FRAME_W_H*sizeof(unsigned char)*3+sizeof(ImgInf)</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> MEMORY_SIZE          FRAME_NUMBER*FRAME_SIZE</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//=================================共享内存信息定义=================================</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> INITSUCCESS      0</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> CREATEMAPFAILED  1</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> MAPVIEWFAILED    2</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SHAREDMEMORY</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">SHAREDMEMORY</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">SHAREDMEMORY</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">SendMat</span><span class=\"token punctuation\">(</span>cv<span class=\"token operator\">::</span>Mat img<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> indexAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cv<span class=\"token operator\">::</span>Mat  <span class=\"token function\">ReceiveMat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> indexAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">SendStr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> data<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> <span class=\"token function\">ReceiveStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> state<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    HANDLE hShareMem<span class=\"token punctuation\">;</span>                               <span class=\"token comment\" spellcheck=\"true\">//共享内存句柄</span>\n    TCHAR sShareMemName<span class=\"token punctuation\">[</span><span class=\"token number\">30</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">TEXT</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ShareMedia\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 共享内存名称</span>\n    LPCTSTR pBuf<span class=\"token punctuation\">;</span>    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span> </span><span class=\"token comment\" spellcheck=\"true\">// !ShareMemory_H</span></code></pre>\n<p>对应的<strong>ShareMemory.cpp</strong>文件为类的实现。</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> once </span>\n<span class=\"token comment\" spellcheck=\"true\">// ShareMemory.cpp : 此文件包含信息定义SHAREDMEMOR类的实现</span>\n<span class=\"token comment\" spellcheck=\"true\">// Author : MJJ</span>\n<span class=\"token comment\" spellcheck=\"true\">// Update : 2020/11/27</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> ShareMemory_CPP</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ShareMemory_CPP</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">\"ShareMemory.h\"</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> cv<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*************************************************************************************\nFuncName  :SHAREDMEMORY::~SHAREDMEMORY()\nDesc      :构造函数创建共享内存\nInput     :None\nOutput    :None\n**************************************************************************************/</span>\nSHAREDMEMORY<span class=\"token operator\">::</span><span class=\"token function\">SHAREDMEMORY</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    hShareMem <span class=\"token operator\">=</span> <span class=\"token function\">CreateFileMapping</span><span class=\"token punctuation\">(</span>\n        INVALID_HANDLE_VALUE<span class=\"token punctuation\">,</span>  <span class=\"token comment\" spellcheck=\"true\">// use paging file</span>\n        <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span>                  <span class=\"token comment\" spellcheck=\"true\">//default security</span>\n        PAGE_READWRITE<span class=\"token punctuation\">,</span>        <span class=\"token comment\" spellcheck=\"true\">//read/write access</span>\n        <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>                     <span class=\"token comment\" spellcheck=\"true\">// maximum object size(high-order DWORD)</span>\n        MEMORY_SIZE<span class=\"token punctuation\">,</span>           <span class=\"token comment\" spellcheck=\"true\">//maximum object size(low-order DWORD)</span>\n        sShareMemName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">//name of mapping object</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hShareMem<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//  映射对象视图，得到共享内存指针，设置数据</span>\n        pBuf <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>LPTSTR<span class=\"token punctuation\">)</span><span class=\"token function\">MapViewOfFile</span><span class=\"token punctuation\">(</span>\n            hShareMem<span class=\"token punctuation\">,</span>           <span class=\"token comment\" spellcheck=\"true\">//handle to map object</span>\n            FILE_MAP_ALL_ACCESS<span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// read/write permission</span>\n            <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n            <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n            MEMORY_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"memory size:\"</span> <span class=\"token operator\">&lt;&lt;</span> MEMORY_SIZE<span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 若映射失败退出</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pBuf <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Could not map view of framebuffer file.\"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">GetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">CloseHandle</span><span class=\"token punctuation\">(</span>hShareMem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            state <span class=\"token operator\">=</span> MAPVIEWFAILED<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">{</span>\n        std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Could not create file mapping object.\"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">GetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n        state <span class=\"token operator\">=</span> CREATEMAPFAILED<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    state <span class=\"token operator\">=</span> INITSUCCESS<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*************************************************************************************\nFuncName  :SHAREDMEMORY::~SHAREDMEMORY()\nDesc      :析构函数释放\nInput     :None\nOutput    :None\n**************************************************************************************/</span>\nSHAREDMEMORY<span class=\"token operator\">::</span><span class=\"token operator\">~</span><span class=\"token function\">SHAREDMEMORY</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"unmap shared addr.\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UnmapViewOfFile</span><span class=\"token punctuation\">(</span>pBuf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//释放；</span>\n    <span class=\"token function\">CloseHandle</span><span class=\"token punctuation\">(</span>hShareMem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*************************************************************************************\nFuncName  :void SHAREDMEMORY::SendMat(cv::Mat img, char indexAddress)\nDesc      :发送Mat数据\nInput     :\n    Mat img               发送图像\n    char indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :None\n**************************************************************************************/</span>\n<span class=\"token keyword\">void</span> SHAREDMEMORY<span class=\"token operator\">::</span><span class=\"token function\">SendMat</span><span class=\"token punctuation\">(</span>cv<span class=\"token operator\">::</span>Mat img<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> indexAddress<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ImgInf img_head<span class=\"token punctuation\">;</span>\n    img_head<span class=\"token punctuation\">.</span>width <span class=\"token operator\">=</span> img<span class=\"token punctuation\">.</span>cols<span class=\"token punctuation\">;</span>\n    img_head<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> img<span class=\"token punctuation\">.</span>rows<span class=\"token punctuation\">;</span>\n    img_head<span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> img<span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>img_head<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> CV_64FC1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pBuf <span class=\"token operator\">+</span> indexAddress<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>img_head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ImgInf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pBuf <span class=\"token operator\">+</span> indexAddress <span class=\"token operator\">+</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ImgInf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>        <span class=\"token comment\" spellcheck=\"true\">// Address of dst</span>\n            img<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span>                                              <span class=\"token comment\" spellcheck=\"true\">// Src data</span>\n            img<span class=\"token punctuation\">.</span>cols <span class=\"token operator\">*</span> img<span class=\"token punctuation\">.</span>rows <span class=\"token operator\">*</span> img<span class=\"token punctuation\">.</span><span class=\"token function\">channels</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// size of data</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pBuf <span class=\"token operator\">+</span> indexAddress<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>img_head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ImgInf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pBuf <span class=\"token operator\">+</span> indexAddress <span class=\"token operator\">+</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ImgInf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>        <span class=\"token comment\" spellcheck=\"true\">// Address of dst</span>\n            img<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span>                                              <span class=\"token comment\" spellcheck=\"true\">// Src data</span>\n            img<span class=\"token punctuation\">.</span>cols <span class=\"token operator\">*</span> img<span class=\"token punctuation\">.</span>rows <span class=\"token operator\">*</span> img<span class=\"token punctuation\">.</span><span class=\"token function\">channels</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                   <span class=\"token comment\" spellcheck=\"true\">// size of data</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"write shared mem successful.\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">/*************************************************************************************\nFuncName  :cv::Mat SHAREDMEMORY::ReceiveMat(char indexAddress)\nDesc      :接收Mat数据\nInput     :\n    char indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :Mat图像\n**************************************************************************************/</span>\ncv<span class=\"token operator\">::</span>Mat SHAREDMEMORY<span class=\"token operator\">::</span><span class=\"token function\">ReceiveMat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> indexAddress<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ImgInf img_head<span class=\"token punctuation\">;</span>\n    cv<span class=\"token operator\">::</span>Mat img<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>img_head<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pBuf <span class=\"token operator\">+</span> indexAddress<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ImgInf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    img<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>img_head<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">,</span> img_head<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> img_head<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>img_head<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> CV_64FC1<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pBuf <span class=\"token operator\">+</span> indexAddress <span class=\"token operator\">+</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ImgInf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> img<span class=\"token punctuation\">.</span>cols <span class=\"token operator\">*</span> img<span class=\"token punctuation\">.</span>rows <span class=\"token operator\">*</span> img<span class=\"token punctuation\">.</span><span class=\"token function\">channels</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pBuf <span class=\"token operator\">+</span> indexAddress <span class=\"token operator\">+</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ImgInf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> img<span class=\"token punctuation\">.</span>cols <span class=\"token operator\">*</span> img<span class=\"token punctuation\">.</span>rows <span class=\"token operator\">*</span> img<span class=\"token punctuation\">.</span><span class=\"token function\">channels</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> img<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*************************************************************************************\nFuncName  :void SHAREDMEMORY::SendStr(cv::Mat img, char indexAddress)\nDesc      :发送str数据\nInput     :\n    Mat img               发送图像\n    char indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :None\n**************************************************************************************/</span>\n<span class=\"token keyword\">void</span> SHAREDMEMORY<span class=\"token operator\">::</span><span class=\"token function\">SendStr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> data<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pBuf<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"write shared mem successful.\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">getchar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*************************************************************************************\nFuncName  :void SHAREDMEMORY::ReceiveStr()\nDesc      :接收str数据\nInput     :None\nOutput    :获取的字符串\n**************************************************************************************/</span>\n<span class=\"token keyword\">char</span><span class=\"token operator\">*</span> SHAREDMEMORY<span class=\"token operator\">::</span><span class=\"token function\">ReceiveStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> str<span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pBuf<span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"receive is:\"</span><span class=\"token operator\">&lt;&lt;</span> str <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> str<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span> </span><span class=\"token comment\" spellcheck=\"true\">// !ShareMemory_CPP</span></code></pre>\n<h3 id=\"2-1-3-C-之间共享内存通信\"><a href=\"#2-1-3-C-之间共享内存通信\" class=\"headerlink\" title=\"2.1.3 C++之间共享内存通信\"></a>2.1.3 C++之间共享内存通信</h3><p>创建一个新的工程，导入上面两个文件，并创建<strong>WriteMem.cpp</strong>文件</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// WriteMem.cpp : 此文件为写共享内存</span>\n<span class=\"token comment\" spellcheck=\"true\">// Author : Jiejing.Ma</span>\n<span class=\"token comment\" spellcheck=\"true\">// Update : 2020/11/27</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">\"ShareMemory.h\"</span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> cv<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 读图片或视频</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">send_img</span><span class=\"token punctuation\">(</span>SHAREDMEMORY sharedsend<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    int64 t0 <span class=\"token operator\">=</span> cv<span class=\"token operator\">::</span><span class=\"token function\">getTickCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n    int64 t1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    string fps <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> nFrames <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    cv<span class=\"token operator\">::</span>Mat frame<span class=\"token punctuation\">;</span>\n\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Opening video...\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    VideoCapture <span class=\"token function\">cap</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test.flv\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>cap<span class=\"token punctuation\">.</span><span class=\"token function\">isOpened</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{</span>\n        cap <span class=\"token operator\">>></span> frame<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>frame<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            std<span class=\"token operator\">::</span>cerr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"ERROR: Can't grab video frame.\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span>frame<span class=\"token punctuation\">,</span> frame<span class=\"token punctuation\">,</span> <span class=\"token function\">Size</span><span class=\"token punctuation\">(</span>FRAME_W<span class=\"token punctuation\">,</span> FRAME_H<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        nFrames<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>frame<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nFrames <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n                int64 t1 <span class=\"token operator\">=</span> cv<span class=\"token operator\">::</span><span class=\"token function\">getTickCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                fps <span class=\"token operator\">=</span> <span class=\"token string\">\" Send FPS:\"</span> <span class=\"token operator\">+</span> <span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span><span class=\"token function\">getTickFrequency</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> N <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">-</span> t0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"fps\"</span><span class=\"token punctuation\">;</span>    \n                t0 <span class=\"token operator\">=</span> t1<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            cv<span class=\"token operator\">::</span><span class=\"token function\">putText</span><span class=\"token punctuation\">(</span>frame<span class=\"token punctuation\">,</span> fps<span class=\"token punctuation\">,</span> <span class=\"token function\">Point</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> cv<span class=\"token operator\">::</span>FONT_HERSHEY_COMPLEX<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> cv<span class=\"token operator\">::</span><span class=\"token function\">Scalar</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span> <span class=\"token number\">255</span><span class=\"token punctuation\">,</span> <span class=\"token number\">255</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        sharedsend<span class=\"token punctuation\">.</span><span class=\"token function\">SendMat</span><span class=\"token punctuation\">(</span>frame<span class=\"token punctuation\">,</span> index <span class=\"token operator\">*</span> FRAME_NUMBER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">waitKey</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">'q'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    SHAREDMEMORY sharedmem<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//char str[] = \"hello\";</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sharedmem<span class=\"token punctuation\">.</span>state <span class=\"token operator\">==</span> INITSUCCESS<span class=\"token punctuation\">)</span> <span class=\"token function\">send_img</span><span class=\"token punctuation\">(</span>sharedmem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//if (sharedmem.state == INITSUCCESS) sharedmem.SendStr(str);</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>创建一个新的工程，导入上面两个文件，并创建<strong>ReadMem.cpp</strong>文件</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// ReadMem.cpp : 此文件为读共享内存</span>\n<span class=\"token comment\" spellcheck=\"true\">// Author : Jiejing.Ma</span>\n<span class=\"token comment\" spellcheck=\"true\">// Update : 2020/11/27</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;Windows.h></span>  </span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">\"ShareMemory.h\"</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> cv<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span> argv<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> index<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    SHAREDMEMORY sharemem<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sharemem<span class=\"token punctuation\">.</span>state <span class=\"token operator\">==</span> INITSUCCESS<span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// read video frame from shared memory.s</span>\n        int64 t0 <span class=\"token operator\">=</span> cv<span class=\"token operator\">::</span><span class=\"token function\">getTickCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        int64 t1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        string fps <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> nFrames <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">namedWindow</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ReadMemShow\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            nFrames<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            Mat frame <span class=\"token operator\">=</span> sharemem<span class=\"token punctuation\">.</span><span class=\"token function\">RecieveMat</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">*</span> FRAME_NUMBER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>frame<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nFrames <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n                    int64 t1 <span class=\"token operator\">=</span> cv<span class=\"token operator\">::</span><span class=\"token function\">getTickCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    fps <span class=\"token operator\">=</span> <span class=\"token string\">\" Average FPS:\"</span> <span class=\"token operator\">+</span> <span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span><span class=\"token function\">getTickFrequency</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> N <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">-</span> t0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"fps\"</span><span class=\"token punctuation\">;</span>\n                    t0 <span class=\"token operator\">=</span> t1<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                cv<span class=\"token operator\">::</span><span class=\"token function\">putText</span><span class=\"token punctuation\">(</span>frame<span class=\"token punctuation\">,</span> fps<span class=\"token punctuation\">,</span> <span class=\"token function\">Point</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> cv<span class=\"token operator\">::</span>FONT_HERSHEY_COMPLEX<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> cv<span class=\"token operator\">::</span><span class=\"token function\">Scalar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">imshow</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ReadMemShow\"</span><span class=\"token punctuation\">,</span> frame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                \n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">waitKey</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">'q'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//char* str = sharemem.RecieveStr();</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">destroyAllWindows</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>同时开启两个工程，则可以接收视频了。</p>\n<h3 id=\"2-1-4-C-之间共享内存通信视频测试结果\"><a href=\"#2-1-4-C-之间共享内存通信视频测试结果\" class=\"headerlink\" title=\"2.1.4 C++之间共享内存通信视频测试结果\"></a>2.1.4 C++之间共享内存通信视频测试结果</h3><p>这里看到，写共享内存速度为15fps，读共享内存速度为65fps（超实时），写速度主要的影响因素与opecv有关。如果优化，还需改视频编解码部分。<br><img src=\"https://img-blog.csdnimg.cn/20201130204440444.png#pic_center\" alt=\"C++和python共享内存传视频测试结果\"></p>\n<h2 id=\"2-2-C-和python间视频通信\"><a href=\"#2-2-C-和python间视频通信\" class=\"headerlink\" title=\"2.2 C++和python间视频通信\"></a>2.2 C++和python间视频通信</h2><p>这里以C++作为发送端，python作为接受端。逆向过程还有待测试。网上有教程提到python不能创建共享内存作为发送端，这种说法是错的。本人已测试过，只是发送数据都是字符串型，对于图像数据还有待研究。</p>\n<h3 id=\"2-2-1-接口函数\"><a href=\"#2-2-1-接口函数\" class=\"headerlink\" title=\"2.2.1 接口函数\"></a>2.2.1 接口函数</h3><p>这里主要用到的是<strong>mmap</strong>和<strong>numpy的frombuffer</strong>.</p>\n<p>关于mmap，请参考<a href=\"http://doc.codingdict.com/python_352/library/mmap.html\">官网</a>的接口说明。十分详细，不再赘述。</p>\n<p>frombuffer:</p>\n<pre class=\" language-python\"><code class=\"language-python\">numpy<span class=\"token punctuation\">.</span>frombuffer<span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> dtype<span class=\"token operator\">=</span>float<span class=\"token punctuation\">,</span> count<span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> offset<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></code></pre>\n<blockquote>\n<p>Interpret a buffer as a 1-dimensional array.</p>\n</blockquote>\n<blockquote>\n<p>Parameters<br>bufferbuffer_like<br>An object that exposes the buffer interface.</p>\n</blockquote>\n<blockquote>\n<p>dtypedata-type, optional<br>Data-type of the returned array; default: float.</p>\n</blockquote>\n<blockquote>\n<p>countint, optional<br>Number of items to read. -1 means all data in the buffer.</p>\n</blockquote>\n<blockquote>\n<p>offsetint, optional<br>Start reading the buffer from this offset (in bytes); default: 0.</p>\n</blockquote>\n<p>参考<a href=\"https://numpy.org/doc/stable/reference/generated/numpy.frombuffer.html\">官网</a></p>\n<h3 id=\"2-2-1-C-与python之间共享内存通信\"><a href=\"#2-2-1-C-与python之间共享内存通信\" class=\"headerlink\" title=\"2.2.1 C++与python之间共享内存通信\"></a>2.2.1 C++与python之间共享内存通信</h3><p>前面已经实现C++代码。不需要改动。只需启动写共享内存工程即可。</p>\n<p>python代码如下：</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> mmap\n<span class=\"token keyword\">import</span> os\n<span class=\"token keyword\">import</span> cv2\n<span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\n\n<span class=\"token comment\" spellcheck=\"true\"># -----------------Define info in ShareMemory.h-----------------</span>\nIMG_HEAD_OFFSET <span class=\"token operator\">=</span> <span class=\"token number\">12</span>\n<span class=\"token comment\" spellcheck=\"true\"># typedef struct {</span>\n<span class=\"token comment\" spellcheck=\"true\">#     int width;</span>\n<span class=\"token comment\" spellcheck=\"true\">#     int height;</span>\n<span class=\"token comment\" spellcheck=\"true\">#     int type;</span>\n<span class=\"token comment\" spellcheck=\"true\"># }ImgInf;       //图像信息12字节</span>\n\nFRAME_NUMBER <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\nFRAME_W <span class=\"token operator\">=</span> <span class=\"token number\">1920</span>\nFRAME_H <span class=\"token operator\">=</span> <span class=\"token number\">1080</span>\nFRAME_W_H <span class=\"token operator\">=</span> FRAME_W <span class=\"token operator\">*</span> FRAME_H\nFRAME_SIZE <span class=\"token operator\">=</span> FRAME_W_H <span class=\"token operator\">*</span> <span class=\"token number\">3</span>\nMEMORY_SIZE <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>FRAME_SIZE <span class=\"token operator\">+</span> IMG_HEAD_OFFSET<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> FRAME_NUMBER\n\nsShareMemName <span class=\"token operator\">=</span> <span class=\"token string\">\"ShareMedia\"</span>\n\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">\"__main__\"</span><span class=\"token punctuation\">:</span>\n    fpx <span class=\"token operator\">=</span> mmap<span class=\"token punctuation\">.</span>mmap<span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> FRAME_SIZE<span class=\"token operator\">+</span>IMG_HEAD_OFFSET<span class=\"token punctuation\">,</span> sShareMemName<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Read img as numpy</span>\n    cv2<span class=\"token punctuation\">.</span>namedWindow<span class=\"token punctuation\">(</span><span class=\"token string\">\"python_sharedmem_show\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    t0 <span class=\"token operator\">=</span> cv2<span class=\"token punctuation\">.</span>getTickCount<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    N <span class=\"token operator\">=</span> <span class=\"token number\">50</span>\n    nFrame <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    fps <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">while</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        nFrame <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        img <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>frombuffer<span class=\"token punctuation\">(</span>fpx<span class=\"token punctuation\">,</span> dtype<span class=\"token operator\">=</span>np<span class=\"token punctuation\">.</span>uint8<span class=\"token punctuation\">)</span>\n        img <span class=\"token operator\">=</span> img<span class=\"token punctuation\">[</span>IMG_HEAD_OFFSET<span class=\"token punctuation\">:</span>FRAME_SIZE<span class=\"token operator\">+</span>IMG_HEAD_OFFSET<span class=\"token punctuation\">]</span>\n        img <span class=\"token operator\">=</span> img<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>FRAME_H<span class=\"token punctuation\">,</span>FRAME_W<span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\"># Print Average  FPS</span>\n        <span class=\"token keyword\">if</span> nFrame <span class=\"token operator\">%</span> <span class=\"token number\">50</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            t1 <span class=\"token operator\">=</span> cv2<span class=\"token punctuation\">.</span>getTickCount<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            fps <span class=\"token operator\">=</span> N<span class=\"token operator\">*</span>cv2<span class=\"token punctuation\">.</span>getTickFrequency<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">-</span> t0<span class=\"token punctuation\">)</span>\n            t0 <span class=\"token operator\">=</span> t1\n        cv2<span class=\"token punctuation\">.</span>putText<span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Average FPS:\"</span> <span class=\"token operator\">+</span> str<span class=\"token punctuation\">(</span>fps<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"fps\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> cv2<span class=\"token punctuation\">.</span>FONT_HERSHEY_COMPLEX<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        cv2<span class=\"token punctuation\">.</span>imshow<span class=\"token punctuation\">(</span><span class=\"token string\">\"python_sharedmem_show\"</span><span class=\"token punctuation\">,</span> img<span class=\"token punctuation\">)</span>\n        img <span class=\"token operator\">=</span> None\n        <span class=\"token keyword\">if</span> cv2<span class=\"token punctuation\">.</span>waitKey<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xFF</span> <span class=\"token operator\">==</span> ord<span class=\"token punctuation\">(</span><span class=\"token string\">'q'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">break</span>\n\n    cv2<span class=\"token punctuation\">.</span>destroyAllWindows<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<h1 id=\"3-基于Socket的视频传输\"><a href=\"#3-基于Socket的视频传输\" class=\"headerlink\" title=\"3.基于Socket的视频传输\"></a>3.基于Socket的视频传输</h1><p>这里是基于Linux开发的Socket通信。而共享内存是基于Windows平台。</p>\n<h2 id=\"3-1-cpp端socket\"><a href=\"#3-1-cpp端socket\" class=\"headerlink\" title=\"3.1 cpp端socket\"></a>3.1 cpp端socket</h2><p>cppsocket.cpp</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/types.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/socket.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;netinet/in.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;arpa/inet.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;netdb.h></span></span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;errno.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;vector></span></span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;opencv2/opencv.hpp></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> cv<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>argv<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 定义socket信息</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>servInetAddr <span class=\"token operator\">=</span> <span class=\"token string\">\"192.168.113.173\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> servPort <span class=\"token operator\">=</span> <span class=\"token number\">8081</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> connfd<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> sockaddr_in addr<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建socket</span>\n    connfd <span class=\"token operator\">=</span> <span class=\"token function\">socket</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span>SOCK_STREAM<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>connfd <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"socket创建失败\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 准备通信地址</span>\n    addr<span class=\"token punctuation\">.</span>sin_family<span class=\"token operator\">=</span>AF_INET<span class=\"token punctuation\">;</span>\n    addr<span class=\"token punctuation\">.</span>sin_port<span class=\"token operator\">=</span><span class=\"token function\">htons</span><span class=\"token punctuation\">(</span>servPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    addr<span class=\"token punctuation\">.</span>sin_addr<span class=\"token punctuation\">.</span>s_addr <span class=\"token operator\">=</span> <span class=\"token function\">inet_addr</span><span class=\"token punctuation\">(</span>servInetAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// bind</span>\n    <span class=\"token keyword\">int</span> res <span class=\"token operator\">=</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>connfd<span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> sockaddr<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>addr<span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>res<span class=\"token operator\">==</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"bind连接失败\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"bind连接成功\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 获取视频帧并发送</span>\n    Mat img<span class=\"token punctuation\">;</span>\n    VideoCapture <span class=\"token function\">capture</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./test.flv\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    vector<span class=\"token operator\">&lt;</span>uchar<span class=\"token operator\">></span> data_encode<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>capture<span class=\"token punctuation\">.</span><span class=\"token function\">isOpened</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>capture<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">imencode</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".jpg\"</span><span class=\"token punctuation\">,</span>img<span class=\"token punctuation\">,</span>data_encode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> len_encode <span class=\"token operator\">=</span> data_encode<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        string len <span class=\"token operator\">=</span> <span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span>len_encode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> len<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">16</span><span class=\"token operator\">-</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> len<span class=\"token operator\">=</span>len<span class=\"token operator\">+</span><span class=\"token string\">' '</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 发送数据</span>\n        <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>connfd<span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">char</span> send_char<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>len_encode<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            send_char<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>data_encode<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>connfd<span class=\"token punctuation\">,</span>send_char<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 接收返回信息</span>\n        <span class=\"token keyword\">char</span> recvBuf<span class=\"token punctuation\">[</span><span class=\"token number\">32</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">recv</span><span class=\"token punctuation\">(</span>connfd<span class=\"token punctuation\">,</span> recvBuf<span class=\"token punctuation\">,</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> cout<span class=\"token operator\">&lt;&lt;</span>recvBuf<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>connfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"3-2-python端\"><a href=\"#3-2-python端\" class=\"headerlink\" title=\"3.2 python端\"></a>3.2 python端</h2><p>pysocket.py</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> socket\n<span class=\"token keyword\">import</span> cv2\n<span class=\"token keyword\">import</span> numpy\n<span class=\"token keyword\">import</span> time\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">recv_size</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    buf<span class=\"token operator\">=</span>b<span class=\"token string\">''</span>\n    <span class=\"token keyword\">while</span> count<span class=\"token punctuation\">:</span>\n        newbuf <span class=\"token operator\">=</span> sock<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token operator\">not</span> newbuf<span class=\"token punctuation\">:</span> <span class=\"token keyword\">return</span> None\n        buf <span class=\"token operator\">+=</span>newbuf\n        count <span class=\"token operator\">-=</span> len<span class=\"token punctuation\">(</span>newbuf<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> buf\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">recv_all</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    buf <span class=\"token operator\">=</span> b<span class=\"token string\">''</span>\n    <span class=\"token keyword\">while</span> count<span class=\"token punctuation\">:</span>\n        newbuf <span class=\"token operator\">=</span> sock<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token operator\">not</span> newbuf<span class=\"token punctuation\">:</span><span class=\"token keyword\">return</span> None\n        buf <span class=\"token operator\">+=</span>newbuf\n        count <span class=\"token operator\">-=</span> len<span class=\"token punctuation\">(</span>newbuf<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> buf\n\n<span class=\"token comment\" spellcheck=\"true\"># 创建socket</span>\ns <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">.</span>socket<span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">.</span>AF_INET<span class=\"token punctuation\">,</span> socket<span class=\"token punctuation\">.</span>SOCK_STREAM<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 准备通信地址</span>\naddress <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'192.168.113.173'</span><span class=\"token punctuation\">,</span><span class=\"token number\">8081</span><span class=\"token punctuation\">)</span>\ns<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span>\ns<span class=\"token punctuation\">.</span>listen<span class=\"token punctuation\">(</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Waiting for images...'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 接受TCP链接并返回（conn, addr），其中conn是新的套接字对象，可以用来接收和发送数据，addr是链接客户端的地址。</span>\nconn<span class=\"token punctuation\">,</span> addr <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>accept<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nn <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n    n <span class=\"token operator\">+=</span><span class=\"token number\">1</span>\n    length <span class=\"token operator\">=</span> recv_size<span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    t0<span class=\"token operator\">=</span>time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> isinstance<span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">,</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\" spellcheck=\"true\"># 若成功接收指定大小信息，进一步接收整张图</span>\n        string_data <span class=\"token operator\">=</span> recv_all<span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span>int<span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        data <span class=\"token operator\">=</span> numpy<span class=\"token punctuation\">.</span>fromstring<span class=\"token punctuation\">(</span>string_data<span class=\"token punctuation\">,</span>dtype<span class=\"token operator\">=</span><span class=\"token string\">'uint8'</span><span class=\"token punctuation\">)</span>\n        decimg <span class=\"token operator\">=</span> cv2<span class=\"token punctuation\">.</span>imdecode<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n        cv2<span class=\"token punctuation\">.</span>namedWindow<span class=\"token punctuation\">(</span><span class=\"token string\">'python-recv'</span><span class=\"token punctuation\">)</span>\n        cv2<span class=\"token punctuation\">.</span>imshow<span class=\"token punctuation\">(</span><span class=\"token string\">'python-recv'</span><span class=\"token punctuation\">,</span>decimg<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> cv2<span class=\"token punctuation\">.</span>waitKey<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xFF</span> <span class=\"token operator\">==</span> ord<span class=\"token punctuation\">(</span><span class=\"token string\">'q'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"111111\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">break</span>\n        t1 <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Image recieved successfully!fps:'</span><span class=\"token operator\">+</span>str<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token operator\">/</span><span class=\"token punctuation\">(</span>t1<span class=\"token operator\">-</span>t0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        conn<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span><span class=\"token string\">'recieved messages!'</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        t0<span class=\"token operator\">=</span>t1\n    <span class=\"token keyword\">if</span> cv2<span class=\"token punctuation\">.</span>waitKey<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xFF</span> <span class=\"token operator\">==</span> ord<span class=\"token punctuation\">(</span><span class=\"token string\">'q'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">break</span>\n\ns<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncv2<span class=\"token punctuation\">.</span>destroyAllWindows<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"3-3-CMakeList\"><a href=\"#3-3-CMakeList\" class=\"headerlink\" title=\"3.3 CMakeList\"></a>3.3 CMakeList</h2><p>Linux 下编译CPP文件，这里使用CMakeList:</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">cmake_minimum_required(VERSION 3.0.0)\nproject(client VERSION 0.1.0)\n\ninclude(CTest)\nenable_testing()\n\n# find opencv and link\nfind_package(OpenCV REQUIRED)\nmessage(STATUS \"Opencv library status:\")\nmessage(STATUS \" version:${OpenCV_VERSION}\")\nmessage(STATUS \" libraries:${OpenCV_LIBS}\")\nmessage(STATUS \" include path:${OpenCV_INCLUDE_DIRS}\")\ninclude_directories(${OpenCV_INCLUDE_DIRS})\nlink_libraries(${OpenCV_LIBS})\n\nadd_executable(client cppsocket.cpp)\n\nset(CMAKE_CXX_FLAGE \"${CMAKE_CXX_FLAGE} -g\")</code></pre>\n<h2 id=\"3-4-测试结果\"><a href=\"#3-4-测试结果\" class=\"headerlink\" title=\"3.4 测试结果\"></a>3.4 测试结果</h2><p>结果就是速度超级慢，大概一秒多一帧。</p>\n<h1 id=\"4-结论\"><a href=\"#4-结论\" class=\"headerlink\" title=\"4 结论\"></a>4 结论</h1><p>C++和python之间通信，可以采用<strong>C++调python</strong>的方式。请参考之前的文章。<a href=\"https://blog.csdn.net/weixin_38369492/article/details/110090225\">Ubuntu下C++调python</a><br>这种方式，从架构的角度来讲，最简单。工程量和已有经验的角度，emm可能坑比较多。速度也应该最快（推测）</p>\n<p>也可以使用<strong>进程间通信</strong>。当然这个成本就高了。有两种方式，一是<strong>共享内存</strong>机制，一是<strong>socket通信</strong>。前者更快，但只能在一个平台上。后者慢，可以支持不同电脑间通信。</p>\n<p>最后关于基于共享内存方式，影响<strong>速度</strong>的主要是<strong>写共享内存</strong>，而这又与<strong>opencv</strong>读视频有关，与<strong>视频编解码</strong>有关。想要提高写内存速度，需要从底层修改视频编解码。可以参考<strong>UE4</strong>的相关插件解决。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>本案例旨在实现跨语言（C++和python间）视频的实时通信。这一工作内容在实际工程中很常见。由于python语言支持很多第三方库，对于开发深度学习项目很方便，验真算法速度快，很多开源算法也大多基于python实现。这时可能就会出现C++的代码借助python语言做一些图像处理（包括目标检测、姿态估计、目标跟踪等任务）的需求。</p>\n<p>平台环境：</p>\n<ul>\n<li>Win10</li>\n<li>VS2019</li>\n<li>OpenCV</li>\n</ul>\n<p>进程间通信方式：共享内存</p>\n<h1 id=\"1-进程间通信\"><a href=\"#1-进程间通信\" class=\"headerlink\" title=\"1.进程间通信\"></a>1.进程间通信</h1><p>进程间通信方式有很多种。工程上最常用的是<strong>共享内存</strong>和<strong>socket机制</strong>。前者效率高，基本思想就是开辟一块公共的内存空间，供两个或多个进程之间使用。为了标识这个公共空间，要给它起个名。但是共享内存的方式不支持多平台。而socket刚好就是支持多平台间进程通信的方式。当然这种方式也会慢一些。</p>\n<p>在本案例中，分别尝试了两种方式。虽然最终共享内存的方式写内存帧率只达到15fps左右，但是要比socket快了近20倍（大概0.5-1fps左右）。下面将介绍这两种机制的具体实现过程。</p>\n<h1 id=\"2-基于共享内存的视频传输\"><a href=\"#2-基于共享内存的视频传输\" class=\"headerlink\" title=\"2.基于共享内存的视频传输\"></a>2.基于共享内存的视频传输</h1><h2 id=\"2-1-C-之间的通信\"><a href=\"#2-1-C-之间的通信\" class=\"headerlink\" title=\"2.1 C++之间的通信\"></a>2.1 C++之间的通信</h2><h3 id=\"2-1-1-接口函数\"><a href=\"#2-1-1-接口函数\" class=\"headerlink\" title=\"2.1.1 接口函数\"></a>2.1.1 接口函数</h3><p>首先验证C++之间能通信。这里使用的是<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga\">CreateFileMapping</a>和<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile\">MapViewOfFile</a>进行共享内存的创建和映射。</p>\n<p>其中<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga\">CreateFileMapping</a>的接口为，参数含义详解请点击链接。</p>\n<pre><code class=\"cpp\">HANDLE CreateFileMapping(\n  HANDLE                hFile,\n  LPSECURITY_ATTRIBUTES lpFileMappingAttributes,\n  DWORD                 flProtect,\n  DWORD                 dwMaximumSizeHigh,\n  DWORD                 dwMaximumSizeLow,\n  LPCSTR                lpName\n);</code></pre>\n<p><a href=\"https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile\">MapViewOfFile</a>的接口为</p>\n<pre><code class=\"cpp\">LPVOID MapViewOfFile(\n  HANDLE hFileMappingObject,\n  DWORD  dwDesiredAccess,\n  DWORD  dwFileOffsetHigh,\n  DWORD  dwFileOffsetLow,\n  SIZE_T dwNumberOfBytesToMap\n);</code></pre>\n<h3 id=\"2-1-2-创建数据格式和共享内存信息\"><a href=\"#2-1-2-创建数据格式和共享内存信息\" class=\"headerlink\" title=\"2.1.2 创建数据格式和共享内存信息\"></a>2.1.2 创建数据格式和共享内存信息</h3><p>首先需要一个图像的头部</p>\n<pre><code class=\"cpp\">typedef struct &#123;\n    int width;\n    int height;\n    int type;\n&#125;ImgInf;       //图像信息</code></pre>\n<p>由于sizeof(int)=4，所以这里ImgInf结构体大小为12B。在进行共享内存映射时，我们需要这个大小去做偏移量，找到图像数据。</p>\n<p>接下来要定义图像的数据信息</p>\n<pre><code class=\"cpp\">#define FRAME_NUMBER         1               // 图像路数\n#define FRAME_W              1920\n#define FRAME_H              1080\n#define FRAME_W_H            FRAME_W*FRAME_H\n// 图像分辨率：彩色图（3通道）+图像信息结构体\n#define FRAME_SIZE           FRAME_W_H*sizeof(unsigned char)*3+sizeof(ImgInf)\n\n#define MEMORY_SIZE          FRAME_NUMBER*FRAME_SIZE</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201130102605383.PNG#pic_center\" alt=\"图像数据空间分配\"></p>\n<p>定义共享内存类SHAREDMEMORY</p>\n<pre><code class=\"cpp\">class SHAREDMEMORY\n&#123;\npublic:\n    SHAREDMEMORY();\n    ~SHAREDMEMORY();\n\n    //void SendBox(TrackBox&amp; BOX);\n    //void RecBox(TrackBox&amp; BOX);\n    //void SendVectorBox(vector&lt;TrackBox&gt;&amp; VTrackBox);\n    //void RecieveVectorBox(vector&lt;TrackBox&gt;&amp; VTrackBox);\n    void SendMat(cv::Mat img, char indexAddress);\n    cv::Mat  ReceiveMat(char indexAddress);\n    void SendStr(const char data[]);  \n    char* ReceiveStr();\n\npublic:\n    int state;\nprivate:\n    HANDLE hShareMem;                               //共享内存句柄\n    TCHAR sShareMemName[30] = TEXT(&quot;CppPytonSharedFrame&quot;); // 共享内存名称\n    LPCTSTR pBuf;    \n&#125;;</code></pre>\n<p>其中SendMat为图像数据发送，ReceiveMat为图像接收。<br>SendStr为字符串发送，ReceiveStr为字符串接收。</p>\n<p>最后的<strong>ShareMemory.h</strong>文件如下：</p>\n<pre><code class=\"cpp\">#pragma once\n// ShareMemory.h : 此文件包含共享内存数据定义、大小确定、位置分配、信息定义\n// Author : Jiejing.Ma\n// Update : 2020/11/27\n#ifndef ShareMemory_H\n#define ShareMemory_H\n\n#include &lt;opencv2/core.hpp&gt;\n#include &lt;opencv2/videoio.hpp&gt;\n#include &lt;opencv2/highgui.hpp&gt;\n#include &lt;opencv2/imgproc.hpp&gt;  // cv::Canny()\n#include &lt;opencv2/opencv.hpp&gt;\n\n#include &lt;Windows.h&gt;\n\n//=================================共享内存数据定义=================================\ntypedef struct &#123;\n    int width;\n    int height;\n    int type;\n&#125;ImgInf;       //图像信息\n//=================================共享内存大小确定=================================\n// 为图像分配空间\n#define FRAME_NUMBER         1               // 图像路数\n#define FRAME_W              1920\n#define FRAME_H              1080\n#define FRAME_W_H            FRAME_W*FRAME_H\n// 图像分辨率：彩色图（3通道）+图像信息结构体\n#define FRAME_SIZE           FRAME_W_H*sizeof(unsigned char)*3+sizeof(ImgInf)\n\n#define MEMORY_SIZE          FRAME_NUMBER*FRAME_SIZE\n\n//=================================共享内存信息定义=================================\n#define INITSUCCESS      0\n#define CREATEMAPFAILED  1\n#define MAPVIEWFAILED    2\n\nclass SHAREDMEMORY\n&#123;\npublic:\n    SHAREDMEMORY();\n    ~SHAREDMEMORY();\n    void SendMat(cv::Mat img, char indexAddress);\n    cv::Mat  ReceiveMat(char indexAddress);\n    void SendStr(const char data[]);\n    char* ReceiveStr();\n\npublic:\n    int state;\nprivate:\n    HANDLE hShareMem;                               //共享内存句柄\n    TCHAR sShareMemName[30] = TEXT(&quot;ShareMedia&quot;);   // 共享内存名称\n    LPCTSTR pBuf;    \n&#125;;\n\n#endif // !ShareMemory_H</code></pre>\n<p>对应的<strong>ShareMemory.cpp</strong>文件为类的实现。</p>\n<pre><code class=\"cpp\">#pragma once \n// ShareMemory.cpp : 此文件包含信息定义SHAREDMEMOR类的实现\n// Author : MJJ\n// Update : 2020/11/27\n#ifndef ShareMemory_CPP\n#define ShareMemory_CPP\n\n#include &quot;ShareMemory.h&quot;\n#include &lt;iostream&gt;\n\nusing namespace cv;\nusing namespace std;\n\n/*************************************************************************************\nFuncName  :SHAREDMEMORY::~SHAREDMEMORY()\nDesc      :构造函数创建共享内存\nInput     :None\nOutput    :None\n**************************************************************************************/\nSHAREDMEMORY::SHAREDMEMORY() &#123;\n    hShareMem = CreateFileMapping(\n        INVALID_HANDLE_VALUE,  // use paging file\n        NULL,                  //default security\n        PAGE_READWRITE,        //read/write access\n        0,                     // maximum object size(high-order DWORD)\n        MEMORY_SIZE,           //maximum object size(low-order DWORD)\n        sShareMemName);        //name of mapping object\n\n    if (hShareMem) &#123;\n        //  映射对象视图，得到共享内存指针，设置数据\n        pBuf = (LPTSTR)MapViewOfFile(\n            hShareMem,           //handle to map object\n            FILE_MAP_ALL_ACCESS, // read/write permission\n            0,\n            0,\n            MEMORY_SIZE);\n        cout &lt;&lt; &quot;memory size:&quot; &lt;&lt; MEMORY_SIZE&lt;&lt; endl;\n\n        // 若映射失败退出\n        if (pBuf == NULL)\n        &#123;\n            std::cout &lt;&lt; &quot;Could not map view of framebuffer file.&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;\n            CloseHandle(hShareMem);\n            state = MAPVIEWFAILED;\n        &#125;\n    &#125;\n    else\n    &#123;\n        std::cout &lt;&lt; &quot;Could not create file mapping object.&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;\n        state = CREATEMAPFAILED;\n    &#125;\n    state = INITSUCCESS;\n&#125;\n\n/*************************************************************************************\nFuncName  :SHAREDMEMORY::~SHAREDMEMORY()\nDesc      :析构函数释放\nInput     :None\nOutput    :None\n**************************************************************************************/\nSHAREDMEMORY::~SHAREDMEMORY() &#123;\n    std::cout &lt;&lt; &quot;unmap shared addr.&quot; &lt;&lt; std::endl;\n    UnmapViewOfFile(pBuf); //释放；\n    CloseHandle(hShareMem);\n&#125;\n\n/*************************************************************************************\nFuncName  :void SHAREDMEMORY::SendMat(cv::Mat img, char indexAddress)\nDesc      :发送Mat数据\nInput     :\n    Mat img               发送图像\n    char indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :None\n**************************************************************************************/\nvoid SHAREDMEMORY::SendMat(cv::Mat img, char indexAddress) &#123;\n    ImgInf img_head;\n    img_head.width = img.cols;\n    img_head.height = img.rows;\n    img_head.type = img.type();\n\n    if (img_head.type == CV_64FC1) &#123;\n        memcpy((char*)pBuf + indexAddress, &amp;img_head, sizeof(ImgInf));\n        memcpy((char*)pBuf + indexAddress + sizeof(ImgInf),        // Address of dst\n            img.data,                                              // Src data\n            img.cols * img.rows * img.channels() * sizeof(double)  // size of data\n        );\n    &#125;\n    else\n    &#123;\n        memcpy((char*)pBuf + indexAddress, &amp;img_head, sizeof(ImgInf));\n        memcpy((char*)pBuf + indexAddress + sizeof(ImgInf),        // Address of dst\n            img.data,                                              // Src data\n            img.cols * img.rows * img.channels()                   // size of data\n        );        \n    &#125;\n    cout &lt;&lt; &quot;write shared mem successful.&quot; &lt;&lt; endl;\n&#125;\n\n\n/*************************************************************************************\nFuncName  :cv::Mat SHAREDMEMORY::ReceiveMat(char indexAddress)\nDesc      :接收Mat数据\nInput     :\n    char indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :Mat图像\n**************************************************************************************/\ncv::Mat SHAREDMEMORY::ReceiveMat(char indexAddress)\n&#123;\n    ImgInf img_head;\n    cv::Mat img;\n    memcpy(&amp;img_head, (char*)pBuf + indexAddress, sizeof(ImgInf));\n    img.create(img_head.height, img_head.width, img_head.type);\n    if (img_head.type == CV_64FC1)\n    &#123;\n        memcpy(img.data, (char*)pBuf + indexAddress + sizeof(ImgInf), img.cols * img.rows * img.channels() * sizeof(double));\n    &#125;\n    else\n    &#123;\n        memcpy(img.data, (char*)pBuf + indexAddress + sizeof(ImgInf), img.cols * img.rows * img.channels());\n    &#125;\n    return img;\n&#125;\n\n/*************************************************************************************\nFuncName  :void SHAREDMEMORY::SendStr(cv::Mat img, char indexAddress)\nDesc      :发送str数据\nInput     :\n    Mat img               发送图像\n    char indexAddress     共享内存中起始位置，若只有一路视频则无偏移\nOutput    :None\n**************************************************************************************/\nvoid SHAREDMEMORY::SendStr(const char data[]) &#123;\n    memcpy((char*)pBuf, data, sizeof(data));\n    cout &lt;&lt; &quot;write shared mem successful.&quot; &lt;&lt; endl;\n    getchar();\n&#125;\n\n/*************************************************************************************\nFuncName  :void SHAREDMEMORY::ReceiveStr()\nDesc      :接收str数据\nInput     :None\nOutput    :获取的字符串\n**************************************************************************************/\nchar* SHAREDMEMORY::ReceiveStr()&#123;\n    char* str= (char*)pBuf;\n    cout &lt;&lt; &quot;receive is:&quot;&lt;&lt; str &lt;&lt; endl;\n    return str;\n&#125;\n#endif // !ShareMemory_CPP</code></pre>\n<h3 id=\"2-1-3-C-之间共享内存通信\"><a href=\"#2-1-3-C-之间共享内存通信\" class=\"headerlink\" title=\"2.1.3 C++之间共享内存通信\"></a>2.1.3 C++之间共享内存通信</h3><p>创建一个新的工程，导入上面两个文件，并创建<strong>WriteMem.cpp</strong>文件</p>\n<pre><code class=\"cpp\">// WriteMem.cpp : 此文件为写共享内存\n// Author : Jiejing.Ma\n// Update : 2020/11/27\n\n#include &lt;iostream&gt;\n#include &quot;ShareMemory.h&quot;\n\nusing namespace std;\nusing namespace cv;\n\n// 读图片或视频\nvoid send_img(SHAREDMEMORY sharedsend)\n&#123;\n    int index = 0;\n    int64 t0 = cv::getTickCount();;\n    int64 t1 = 0;\n    string fps = &quot;&quot;;\n    int nFrames = 0;\n\n    cv::Mat frame;\n\n    cout &lt;&lt; &quot;Opening video...&quot; &lt;&lt; endl;\n    VideoCapture cap(&quot;test.flv&quot;);\n    while (cap.isOpened()) \n    &#123;\n        cap &gt;&gt; frame;\n        if (frame.empty())\n        &#123;\n            std::cerr &lt;&lt; &quot;ERROR: Can&#39;t grab video frame.&quot; &lt;&lt; endl;\n            break;\n        &#125;\n        resize(frame, frame, Size(FRAME_W, FRAME_H));\n\n        nFrames++;\n\n        if (!frame.empty()) &#123;\n            if (nFrames % 10 == 0)\n            &#123;\n                const int N = 10;\n                int64 t1 = cv::getTickCount();\n                fps = &quot; Send FPS:&quot; + to_string((double)getTickFrequency() * N / (t1 - t0)) + &quot;fps&quot;;    \n                t0 = t1;\n            &#125;\n            cv::putText(frame, fps, Point(100, 100), cv::FONT_HERSHEY_COMPLEX, 1, cv::Scalar(255, 255, 255),1);\n        &#125;\n        sharedsend.SendMat(frame, index * FRAME_NUMBER);\n\n\n        if ((waitKey(1) &amp; 0xFF) == &#39;q&#39;) break;\n    &#125;\n&#125;\n\n\nint main()\n&#123;\n    SHAREDMEMORY sharedmem;\n    //char str[] = &quot;hello&quot;;\n    if (sharedmem.state == INITSUCCESS) send_img(sharedmem);\n    //if (sharedmem.state == INITSUCCESS) sharedmem.SendStr(str);\n\n    return 0;\n&#125;</code></pre>\n<p>创建一个新的工程，导入上面两个文件，并创建<strong>ReadMem.cpp</strong>文件</p>\n<pre><code class=\"cpp\">// ReadMem.cpp : 此文件为读共享内存\n// Author : Jiejing.Ma\n// Update : 2020/11/27\n\n#include &lt;Windows.h&gt;  \n#include &lt;iostream&gt;\n#include &quot;ShareMemory.h&quot;\n#include &lt;string&gt;\n\nusing namespace std;\nusing namespace cv;\n\nint main(int argc, char** argv)\n&#123;\n    int index=0;\n    SHAREDMEMORY sharemem;\n    if (sharemem.state == INITSUCCESS) \n    &#123;\n        // read video frame from shared memory.s\n        int64 t0 = cv::getTickCount();;\n        int64 t1 = 0;\n        string fps = &quot;&quot;;\n        int nFrames = 0;\n        namedWindow(&quot;ReadMemShow&quot;, 0);\n\n        while (true)\n        &#123;\n            nFrames++;\n            Mat frame = sharemem.RecieveMat(index * FRAME_NUMBER);\n\n            if (!frame.empty()) &#123;\n                if (nFrames % 10 == 0)\n                &#123;\n                    const int N = 10;\n                    int64 t1 = cv::getTickCount();\n                    fps = &quot; Average FPS:&quot; + to_string((double)getTickFrequency() * N / (t1 - t0)) + &quot;fps&quot;;\n                    t0 = t1;\n                &#125;\n                cv::putText(frame, fps, Point(100, 200), cv::FONT_HERSHEY_COMPLEX, 1, cv::Scalar(100, 200, 200),1);\n                imshow(&quot;ReadMemShow&quot;, frame);                \n            &#125;\n            if((waitKey(1) &amp; 0xFF) == &#39;q&#39;) break;\n        &#125;\n\n        //char* str = sharemem.RecieveStr();\n    &#125;\n    destroyAllWindows();\n    return 0;\n&#125;</code></pre>\n<p>同时开启两个工程，则可以接收视频了。</p>\n<h3 id=\"2-1-4-C-之间共享内存通信视频测试结果\"><a href=\"#2-1-4-C-之间共享内存通信视频测试结果\" class=\"headerlink\" title=\"2.1.4 C++之间共享内存通信视频测试结果\"></a>2.1.4 C++之间共享内存通信视频测试结果</h3><p>这里看到，写共享内存速度为15fps，读共享内存速度为65fps（超实时），写速度主要的影响因素与opecv有关。如果优化，还需改视频编解码部分。<br><img src=\"https://img-blog.csdnimg.cn/20201130204440444.png#pic_center\" alt=\"C++和python共享内存传视频测试结果\"></p>\n<h2 id=\"2-2-C-和python间视频通信\"><a href=\"#2-2-C-和python间视频通信\" class=\"headerlink\" title=\"2.2 C++和python间视频通信\"></a>2.2 C++和python间视频通信</h2><p>这里以C++作为发送端，python作为接受端。逆向过程还有待测试。网上有教程提到python不能创建共享内存作为发送端，这种说法是错的。本人已测试过，只是发送数据都是字符串型，对于图像数据还有待研究。</p>\n<h3 id=\"2-2-1-接口函数\"><a href=\"#2-2-1-接口函数\" class=\"headerlink\" title=\"2.2.1 接口函数\"></a>2.2.1 接口函数</h3><p>这里主要用到的是<strong>mmap</strong>和<strong>numpy的frombuffer</strong>.</p>\n<p>关于mmap，请参考<a href=\"http://doc.codingdict.com/python_352/library/mmap.html\">官网</a>的接口说明。十分详细，不再赘述。</p>\n<p>frombuffer:</p>\n<pre><code class=\"python\">numpy.frombuffer(buffer, dtype=float, count=-1, offset=0)</code></pre>\n<blockquote>\n<p>Interpret a buffer as a 1-dimensional array.</p>\n</blockquote>\n<blockquote>\n<p>Parameters<br>bufferbuffer_like<br>An object that exposes the buffer interface.</p>\n</blockquote>\n<blockquote>\n<p>dtypedata-type, optional<br>Data-type of the returned array; default: float.</p>\n</blockquote>\n<blockquote>\n<p>countint, optional<br>Number of items to read. -1 means all data in the buffer.</p>\n</blockquote>\n<blockquote>\n<p>offsetint, optional<br>Start reading the buffer from this offset (in bytes); default: 0.</p>\n</blockquote>\n<p>参考<a href=\"https://numpy.org/doc/stable/reference/generated/numpy.frombuffer.html\">官网</a></p>\n<h3 id=\"2-2-1-C-与python之间共享内存通信\"><a href=\"#2-2-1-C-与python之间共享内存通信\" class=\"headerlink\" title=\"2.2.1 C++与python之间共享内存通信\"></a>2.2.1 C++与python之间共享内存通信</h3><p>前面已经实现C++代码。不需要改动。只需启动写共享内存工程即可。</p>\n<p>python代码如下：</p>\n<pre><code class=\"python\">import mmap\nimport os\nimport cv2\nimport numpy as np\n\n# -----------------Define info in ShareMemory.h-----------------\nIMG_HEAD_OFFSET = 12\n# typedef struct &#123;\n#     int width;\n#     int height;\n#     int type;\n# &#125;ImgInf;       //图像信息12字节\n\nFRAME_NUMBER = 1\nFRAME_W = 1920\nFRAME_H = 1080\nFRAME_W_H = FRAME_W * FRAME_H\nFRAME_SIZE = FRAME_W_H * 3\nMEMORY_SIZE = (FRAME_SIZE + IMG_HEAD_OFFSET) * FRAME_NUMBER\n\nsShareMemName = &quot;ShareMedia&quot;\n\nif __name__ == &quot;__main__&quot;:\n    fpx = mmap.mmap(-1, FRAME_SIZE+IMG_HEAD_OFFSET, sShareMemName)\n\n    # Read img as numpy\n    cv2.namedWindow(&quot;python_sharedmem_show&quot;,0)\n    t0 = cv2.getTickCount()\n    N = 50\n    nFrame = 0\n    fps = 0\n    while 1:\n        nFrame += 1\n        img = np.frombuffer(fpx, dtype=np.uint8)\n        img = img[IMG_HEAD_OFFSET:FRAME_SIZE+IMG_HEAD_OFFSET]\n        img = img.reshape((FRAME_H,FRAME_W,3))\n\n        # Print Average  FPS\n        if nFrame % 50 == 0:\n            t1 = cv2.getTickCount()\n            fps = N*cv2.getTickFrequency() / (t1 - t0)\n            t0 = t1\n        cv2.putText(img, &quot;Average FPS:&quot; + str(fps) + &quot;fps&quot;, (100, 200), cv2.FONT_HERSHEY_COMPLEX, 1, (100, 200, 200), 1)\n        cv2.imshow(&quot;python_sharedmem_show&quot;, img)\n        img = None\n        if cv2.waitKey(1) &amp; 0xFF == ord(&#39;q&#39;):\n            break\n\n    cv2.destroyAllWindows()</code></pre>\n<h1 id=\"3-基于Socket的视频传输\"><a href=\"#3-基于Socket的视频传输\" class=\"headerlink\" title=\"3.基于Socket的视频传输\"></a>3.基于Socket的视频传输</h1><p>这里是基于Linux开发的Socket通信。而共享内存是基于Windows平台。</p>\n<h2 id=\"3-1-cpp端socket\"><a href=\"#3-1-cpp端socket\" class=\"headerlink\" title=\"3.1 cpp端socket\"></a>3.1 cpp端socket</h2><p>cppsocket.cpp</p>\n<pre><code class=\"cpp\">#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;netdb.h&gt;\n\n#include &lt;errno.h&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#include &lt;opencv2/opencv.hpp&gt;\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char **argv)\n&#123;\n    // 定义socket信息\n    char *servInetAddr = &quot;192.168.113.173&quot;;\n    int servPort = 8081;\n    int connfd;\n    struct sockaddr_in addr;\n\n    // 创建socket\n    connfd = socket(AF_INET,SOCK_STREAM, 0);\n    if (connfd == -1)\n    &#123;\n        cout&lt;&lt;&quot;socket创建失败&quot;&lt;&lt;endl;\n        exit(-1);\n    &#125;\n\n    // 准备通信地址\n    addr.sin_family=AF_INET;\n    addr.sin_port=htons(servPort);\n    addr.sin_addr.s_addr = inet_addr(servInetAddr);\n\n    // bind\n    int res = connect(connfd,(struct sockaddr*)&amp;addr,sizeof(addr));\n    if(res==-1)\n    &#123;\n        cout&lt;&lt;&quot;bind连接失败&quot;&lt;&lt;endl;\n        exit(-1);\n    &#125;\n    cout&lt;&lt;&quot;bind连接成功&quot;&lt;&lt;endl;\n\n    // 获取视频帧并发送\n    Mat img;\n    VideoCapture capture(&quot;./test.flv&quot;);\n    vector&lt;uchar&gt; data_encode;\n\n    while(capture.isOpened())&#123;\n        if(!capture.read(img)) break;\n\n        imencode(&quot;.jpg&quot;,img,data_encode);\n        int len_encode = data_encode.size();\n        string len = to_string(len_encode);\n        int length = len.length(); \n        for (int i=0;i&lt;16-length;i++) len=len+&#39; &#39;;\n\n        // 发送数据\n        send(connfd,len.c_str(),strlen(len.c_str()),0);\n        char send_char[1];\n        for (int i=0;i&lt;len_encode;i++)\n        &#123;\n            send_char[0]=data_encode[i];\n            send(connfd,send_char,1,0);\n        &#125;\n\n        // 接收返回信息\n        char recvBuf[32] = &quot;&quot;;\n        if(recv(connfd, recvBuf,32,0)) cout&lt;&lt;recvBuf&lt;&lt;endl;\n    &#125;\n\n    close(connfd);\n    return 0;\n\n&#125;</code></pre>\n<h2 id=\"3-2-python端\"><a href=\"#3-2-python端\" class=\"headerlink\" title=\"3.2 python端\"></a>3.2 python端</h2><p>pysocket.py</p>\n<pre><code class=\"python\">import socket\nimport cv2\nimport numpy\nimport time\n\ndef recv_size(sock, count):\n    buf=b&#39;&#39;\n    while count:\n        newbuf = sock.recv(count)\n        if not newbuf: return None\n        buf +=newbuf\n        count -= len(newbuf)\n    return buf\n\n\ndef recv_all(sock, count):\n    buf = b&#39;&#39;\n    while count:\n        newbuf = sock.recv(1)\n        if not newbuf:return None\n        buf +=newbuf\n        count -= len(newbuf)\n    return buf\n\n# 创建socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# 准备通信地址\naddress = (&#39;192.168.113.173&#39;,8081)\ns.bind(address)\ns.listen(True)\nprint(&#39;Waiting for images...&#39;)\n# 接受TCP链接并返回（conn, addr），其中conn是新的套接字对象，可以用来接收和发送数据，addr是链接客户端的地址。\nconn, addr = s.accept()\nn = 0\n\nwhile 1:\n    n +=1\n    length = recv_size(conn,16).decode()\n    t0=time.time()\n    if isinstance(length,str):  # 若成功接收指定大小信息，进一步接收整张图\n        string_data = recv_all(conn,int(length))\n        data = numpy.fromstring(string_data,dtype=&#39;uint8&#39;)\n        decimg = cv2.imdecode(data,1)\n\n        cv2.namedWindow(&#39;python-recv&#39;)\n        cv2.imshow(&#39;python-recv&#39;,decimg)\n\n        if cv2.waitKey(1) &amp; 0xFF == ord(&#39;q&#39;):\n            print(&quot;111111&quot;)\n            break\n        t1 = time.time()\n        print(&#39;Image recieved successfully!fps:&#39;+str(1/(t1-t0)))\n        conn.send(&#39;recieved messages!&#39;.encode())\n        t0=t1\n    if cv2.waitKey(1) &amp; 0xFF == ord(&#39;q&#39;):\n        break\n\ns.close()\ncv2.destroyAllWindows()</code></pre>\n<h2 id=\"3-3-CMakeList\"><a href=\"#3-3-CMakeList\" class=\"headerlink\" title=\"3.3 CMakeList\"></a>3.3 CMakeList</h2><p>Linux 下编译CPP文件，这里使用CMakeList:</p>\n<pre><code class=\"shell\">cmake_minimum_required(VERSION 3.0.0)\nproject(client VERSION 0.1.0)\n\ninclude(CTest)\nenable_testing()\n\n# find opencv and link\nfind_package(OpenCV REQUIRED)\nmessage(STATUS &quot;Opencv library status:&quot;)\nmessage(STATUS &quot; version:$&#123;OpenCV_VERSION&#125;&quot;)\nmessage(STATUS &quot; libraries:$&#123;OpenCV_LIBS&#125;&quot;)\nmessage(STATUS &quot; include path:$&#123;OpenCV_INCLUDE_DIRS&#125;&quot;)\ninclude_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)\nlink_libraries($&#123;OpenCV_LIBS&#125;)\n\nadd_executable(client cppsocket.cpp)\n\nset(CMAKE_CXX_FLAGE &quot;$&#123;CMAKE_CXX_FLAGE&#125; -g&quot;)</code></pre>\n<h2 id=\"3-4-测试结果\"><a href=\"#3-4-测试结果\" class=\"headerlink\" title=\"3.4 测试结果\"></a>3.4 测试结果</h2><p>结果就是速度超级慢，大概一秒多一帧。</p>\n<h1 id=\"4-结论\"><a href=\"#4-结论\" class=\"headerlink\" title=\"4 结论\"></a>4 结论</h1><p>C++和python之间通信，可以采用<strong>C++调python</strong>的方式。请参考之前的文章。<a href=\"https://blog.csdn.net/weixin_38369492/article/details/110090225\">Ubuntu下C++调python</a><br>这种方式，从架构的角度来讲，最简单。工程量和已有经验的角度，emm可能坑比较多。速度也应该最快（推测）</p>\n<p>也可以使用<strong>进程间通信</strong>。当然这个成本就高了。有两种方式，一是<strong>共享内存</strong>机制，一是<strong>socket通信</strong>。前者更快，但只能在一个平台上。后者慢，可以支持不同电脑间通信。</p>\n<p>最后关于基于共享内存方式，影响<strong>速度</strong>的主要是<strong>写共享内存</strong>，而这又与<strong>opencv</strong>读视频有关，与<strong>视频编解码</strong>有关。想要提高写内存速度，需要从底层修改视频编解码。可以参考<strong>UE4</strong>的相关插件解决。</p>\n"},{"title":"Winsock创建socket server和client","date":"2020-12-14T12:37:14.000Z","author":"马捷径","img":"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=105906878,390165426&fm=26&gp=0.jpg","top":true,"cover":true,"coverImg":"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=105906878,390165426&fm=26&gp=0.jpg","toc":true,"mathjax":true,"summary":"深度理解在Win10上利用Winsock创建socket的服务端和客户端。","keywords":["通信","socket","Winsock","C++"],"_content":"\n\n\n本文详细介绍在Windows 10下利用Winsock创建socket server和client应用步骤和源码。项目源码可以到我的[github](https://github.com/MolianWH/CommutionTools/tree/main/Socket/SocketWin)上下载。在该仓库中，我准备将所有有关通信方式的源码做成工具包，便于以后开发直接使用。本文还可以在我的[CSND](https://blog.csdn.net/weixin_38369492/article/details/111032276)上查看。\n\n---\n\n\n## 1. 基本流程\n\n创建TCP/IP流的server/client通用步骤如下：\n\n### 1.1 Server和Client创建流程\n**Server**\n1. 初始化Winsock\n2. 创建socket\n3. 绑定socket\n4. 监听客户端socket\n5. 接受客户端连接请求\n6. 接收和发送数据\n7.  断开连接\n\n**Client**\n1. 初始化Winsock\n2. 创建socket\n3. 连接服务端\n4. 发送和接收数据\n5. 断开连接\n\n### 1.2 创建Winsock应用步骤\n创建一个最基础的Winsock应用需要以下几步\n\n1. 创建一个空项目\n2. 添加一个空的C++ source文件到项目中\n3. 引用Microsoft Windows SDK 的Include、Lib和Src目录\n4. 确保项目连接Winsock库文件：`#pragma comment(lib, Ws2_32.lib)`\n5. 编写Winsock应用程序。使用Winsock API需要包含两个头文件：**Winsock2.h**和**Ws2tcpip.h**。前者包含Winsock的大多数函数、结构体、定义；后者包含在WinSock 2中关于TCP/IP协议的用于检索IP地址的新函数和结构。\n\n通常一个Winsock应用的头部应该这样写：\n```cpp\n#include <WinSock2.h>\n#include <WS2tcpip.h>\n#include <stdio.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\nint main() {\n  return 0;\n}\n```\n\n> **Note**\n> - 如果使用ip helper APIs，需要包含Iphlpapi.h。且WinSock2.h需要在其前面。\n> - Winsock2.h包含了Windows.h一些核心内容，所以通常不需要再包含Windows.h了\n> - 如果要包含Windows.h，必须放在Winsock2.h前，并且要使用`#define WIN32_LEAN_AND_MEAN`。这是因为Windows.h中包含了Winsock.h（第一个版本），会和Winsock2.h冲突，使用该预定义会避免用Winsock.h\n\n所以一个升级版的头部应该这样写：\n\n```cpp\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif // !WIN32_LEAN_AND_MEAN\n\n#include <Windows.h>\n#include <WinSock2.h>  // socket\n#include <WS2tcpip.h>  // TCP/IP\n#include <iphlpapi.h>  // ip helper APIs\n#include <stdio.h>\n\n// Link to Ws2_32.lib\n#pragma comment(lib,\"Ws2_32.lib\")\n\nint main() {\n  return 0;\n}\n```\n\n### 1.3 初始化Winsock\n所有调用Winsock函数的进程(应用程序或DLL)必须在调用其他Winsock函数之前初始化Windows socket DLL再使用。这也确保了系统上支持Winsock。\n\n1. 创建WSADATA对象\n```cpp\n   WSADATA wsaData;\n```\n2. 调用WSAStartup，返回整数值，并通过该值检查错误。 \n ```cpp\n    // Initialize WinSock\n\tint iRes = WSAStartup(MAKEWORD(2, 2), &wasData);\n\tif (iRes != 0)\n\t{\n\t\t\tprintf(\"WSAStartup failed: %d\\n\" , iRes);\n\t\t\treturn 1;\n\t} \n```\n\n调用WSAStartup函数来启动WS2_32.dll的使用。\n\nWSADATA结构包含关于Windows套接字实现的信息。WSAStartup的MAKEWORD(2,2)参数在系统上请求Winsock的2.2版本，并将传递的版本设置为调用者可以使用的Windows套接字支持的最高版本。\n\n## 2. 创建server\n\n参考[1.1](#11_ServerClient_8)中的步骤，在[1.3](#13_Winsock_73)中已经说明了如何初始化Winsock，下面应该是创建server socket\n\n### 2.1 创建server socket\n\n1.  使用[getaddrinfo()](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo)确定sockaddr结构体值，getaddrinfo中使用[addrinfo](https://docs.microsoft.com/en-us/windows/win32/api/ws2def/ns-ws2def-addrinfoa)结构体。\n\n使用的信息包含以下内容：\n\n字段|作用|\n---|---\nAF_INET|指定IPv4地址族\nSOCK_STREAM|指定一个流套接字\nIPPROTO_TCP|指定TCP协议\nAI_PASSIVE|AI_PASSIVE标志表示调用者打算在调用bind函数时使用返回的套接字地址结构。当AI_PASSIVE标志被设置并且getaddrinfo函数的nodename参数是一个空指针时，套接字地址结构的IP地址部分被设置为IPv4地址INADDR_ANY或IPv6地址IN6ADDR_ANY_INIT。\n\n代码如下：\n```cpp\n   #define DEFAULT_PORT \"27015\"\n\n// 2. create server socket\n\taddrinfo* result = NULL, * ptr = NULL, hints;\n\n\tZeroMemory(&hints, sizeof(hints));\n\thints.ai_family = AF_INET;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\thints.ai_flags = AI_PASSIVE;\n\n\t// Resolve the local address and port to be used by the server\n\tiRes = getaddrinfo(NULL, DEFAULT_PORT, &hints, &result);\n\tif (iRes != 0)\n\t{\n\t\tprintf(\"getaddrinfo failed:%d\\n\",iRes);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n```\n\n<div id=\"refer-anchor-212\"></div>\n\n2. 创建SOCKET对象ListenSocket ，用来监听客户端连接请求。\n\n```cpp\nSOCKET ListenSocket = INVALID_SOCKET;\n```\n\n<div id=\"refer-anchor-213\"></div>\n\n3. 调用socket函数，返回值赋给ListenSocket 。\n\n对于server，使用getaddrinfo返回的第一个IP地址，该IP地址与在提示参数中指定的地址家族、套接字类型和协议相匹配\n\n如果想监听IPv6，ai_family = AF_INET6；\n\n如果想同时监听IPv4和IPv6，必须创建两个监听套接字，一个监听IPv6，一个监听IPv4。应用程序必须分别处理这两个套接字。\n\n```cpp\nListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);\n```\n\n<div id=\"refer-anchor-214\"></div>\n\n4. 检查错误，确保socket是一个有效的套接字\n\n```cpp\n\t// Check for errors to ensure that the socket is valid socket\n\tif (ListenSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"Error at socket():\"<< WSAGetLastError() << endl;\n\t\tfreeaddrinfo(result);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n```\n\n### 2.2 绑定socket\nserver如果要接收client连接请求，需要绑定一个网络地址。下面阐述如果绑定一个创建了IP地址和端口的socket。client使用IP地址和端口连接主机。\n\n1. bind并检查错误\n\nsockaddr结构保存有关地址家族、IP地址和端口号的信息。\n\n调用`bind()`，传递创建的socket和getaddrinfo函数返回的sockaddr结构作为参数。检查一般性错误。\n\n```cpp\n\t// 3. Bind socket\n\t// Setup the TCP listening socket\n\tiRes = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"bind failed with error: \" << WSAGetLastError() << endl;\n\t\tfreeaddrinfo(result);\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n```\n2. 释放存放地址信息的内存空间\n\n一旦绑定完成，getaddrinfo获取的地址信息就不在需要了，使用freeaddrinfo释放分配的内存。\n\n```cpp\n\t// free memory allocated by getaddrinfo() for address information\n\tfreeaddrinfo(result);\n```\n\n### 2.3 监听\nsocket绑定IP地址和端口后，需要监听该IP和端口发送的连接请求。\n\n调用`listen()`将创建的socket和待定的值(待定连接队列的最大长度)作为参数传递。在本例中，backlog参数被设置为SOMAXCONN。此值是一个特殊常量，指示此套接字的Winsock提供程序允许队列中挂起连接的最大合理数量。检查返回值是否有一般错误。\n\n### 2.4 接受连接请求\n\n监听时若收到连接请求，需处理该请求。\n\n1. 创建临时SOCKET对象ClientSocket接受client的连接\n\n```cpp\n// 5. Accepting a Connetion\n// Create temporary ClientSocket for accepting connetions from clients\nSOCKET ClientSocket = INVALID_SOCKET;\n```\n\n2. 通常server要监听多个客户端的连接请求。对一个高性能的server来说，需要使用多线程处理多客户端请求。\n\nWinsock有多种处理多客户端连接请求的技术。一种编程技术是创建一个连续循环，使用`listen()`检查连接请求(参见[2.3](#23__195))。如果出现连接请求，应用程序将调用`accept、AcceptEx或WSAAccept`函数，并将工作传递给另一个线程来处理请求。还可以使用其他几种编程技术。\n\n>**Note**\n>这个基本示例非常简单，并且不使用多线程。该示例还只侦听和接受单个连接。\n\n```cpp\n    // Accept a client socket\n\tClientSocket = accept(ListenSocket, NULL, NULL);\n\tif (ClientSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"accept failed: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n```\n\n### 2.5 接收好发送数据\n\n使用`recv()`和`send()`接收和发送消息\n```cpp\n#define DEFAULT_BUFLEN 512\n\n\t// 6. Receiving and Sending Data on the Server\n\tchar recvbuf[DEFAULT_BUFLEN];\n\tint iSendRes;\n\tint recvbuflen = DEFAULT_BUFLEN;\n\n\tiRes = 1;\n\t// Receive until the peer shuts down the connection\n\twhile (iRes > 0)\n\t{\n\t\tiRes = recv(ClientSocket, recvbuf, recvbuflen, 0);\n\t\tif (iRes > 0)\n\t\t{\n\t\t\tcout << \"Bytes received: \" << iRes << endl;\n\n\t\t\t// Echo the buffr back to the sender\n\t\t\tiSendRes = send(ClientSocket, recvbuf, iRes, 0);\n\t\t\tif (iSendRes == SOCKET_ERROR)\n\t\t\t{\n\t\t\t\tcout << \"send failed: \" << WSAGetLastError() << endl;\n\t\t\t\tclosesocket(ClientSocket);\n\t\t\t\tWSACleanup();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcout << \"Bytes sent: \" << iSendRes << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout <<\"recv failed: \" << WSAGetLastError() << endl;\n\t\t\tclosesocket(ClientSocket);\n\t\t\tWSACleanup();\n\t\t\treturn 1;\n\t\t}\n\t}\n```\n\n### 2.6 断开连接\n\n1. 当server完成向client发送数据时，可以调用`shutdown()`，指定`SD_SEND`来关闭套接字的发送端。这允许客户端释放此套接字的一些资源。服务器应用程序仍然可以接收套接字上的数据。\n```cpp\n\t// 7.Disconneting the Server\n\t// shutdown the send half of the connetiong since no more data will be sent\n\tiRes = shutdown(ClientSocket, SD_SEND);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"shutdown failed: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ClientSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n```\n\n2. 当客户端应用程序完成接收数据时，将调用`closesocket()`来关闭套接字。\n\n当客户端应用程序使用Windows套接字DLL完成时，WSACleanup函数被调用来释放资源。\n\n```cpp\n\t// cleanup\n\tclosesocket(ClientSocket);\n\tWSACleanup();\n\treturn 0;\n```\n\n## 3. 创建client\n与第2节大体相似。\n\n### 3.1 创建client socket\n\n1. 对于这个应用程序，Internet地址族是未指定的`AF_UNSPEC`，因此可以返回IPv6或IPv4地址。其余与[2.1](#21_server_socket_99)的1基本相同\n\n```cpp\nstruct addrinfo *result = NULL,\n                *ptr = NULL,\n                hints;\n\nZeroMemory( &hints, sizeof(hints) );\nhints.ai_family = AF_UNSPEC;\nhints.ai_socktype = SOCK_STREAM;\nhints.ai_protocol = IPPROTO_TCP;\n```\n\n2. 与[2.1](#21_server_socket_99)的1不同的是，请求在命令行中传递的服务器名称的IP地址。\n\n```cpp\n#define DEFAULT_PORT \"27015\"\n\n// Resolve the server address and port\niResult = getaddrinfo(argv[1], DEFAULT_PORT, &hints, &result);\nif (iResult != 0) {\n    printf(\"getaddrinfo failed: %d\\n\", iResult);\n    WSACleanup();\n    return 1;\n}\n```\n\n3. 同[2.1](#21_server_socket_99)的[2](#refer-anchor-212)\n\n```cpp\nSOCKET ConnectSocket = INVALID_SOCKET;\n```\n\n4. 同[2.1](#21_server_socket_99)的[3](#refer-anchor-213)\n\n```cpp\n// Attempt to connect to the first address returned by\n// the call to getaddrinfo\nptr=result;\n\n// Create a SOCKET for connecting to server\nConnectSocket = socket(ptr->ai_family, ptr->ai_socktype, \n    ptr->ai_protocol);\n```\n\n5. 同[2.1](#21_server_socket_99)的[4](#refer-anchor-214)\n\n```cpp\nif (ConnectSocket == INVALID_SOCKET) {\n    printf(\"Error at socket(): %ld\\n\", WSAGetLastError());\n    freeaddrinfo(result);\n    WSACleanup();\n    return 1;\n}\n```\n\n### 3.2 连接server\n\n客户端想要通信，需要连接server。\n\n调用`connect()`，设置参数为创建的socket和sockaddr结构，并检查错误。\n\n```cpp\n// Connect to server.\niResult = connect( ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);\nif (iResult == SOCKET_ERROR) {\n    closesocket(ConnectSocket);\n    ConnectSocket = INVALID_SOCKET;\n}\n\n// Should really try the next address returned by getaddrinfo\n// if the connect call failed\n// But for this simple example we just free the resources\n// returned by getaddrinfo and print an error message\n\nfreeaddrinfo(result);\n\nif (ConnectSocket == INVALID_SOCKET) {\n    printf(\"Unable to connect to server!\\n\");\n    WSACleanup();\n    return 1;\n}\n```\n\n在本例中，`getaddrinfo()`返回的第一个IP地址用于指定传递给连接的`sockaddr`结构。如果对第一个IP地址的连接调用失败，那么尝试从`getaddrinfo()`返回的链表中的下一个`addrinfo`结构。\n\nsockaddr结构中指定的信息包括:\n\n- 客户机将尝试连接到的服务器的IP地址。\n- 客户机将连接到的服务器端口号。当\n- 客户端调用`getaddrinfo()`时，该端口被指定为端口27015。\n\n### 3.3 发送接收数据\n\n```cpp#define DEFAULT_BUFLEN 512\nint recvbuflen = DEFAULT_BUFLEN;\n\nconst char *sendbuf = \"this is a test\";\nchar recvbuf[DEFAULT_BUFLEN];\n\nint iResult;\n\n// Send an initial buffer\niResult = send(ConnectSocket, sendbuf, (int) strlen(sendbuf), 0);\nif (iResult == SOCKET_ERROR) {\n    printf(\"send failed: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n}\n\nprintf(\"Bytes Sent: %ld\\n\", iResult);\n\n// shutdown the connection for sending since no more data will be sent\n// the client can still use the ConnectSocket for receiving data\niResult = shutdown(ConnectSocket, SD_SEND);\nif (iResult == SOCKET_ERROR) {\n    printf(\"shutdown failed: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n}\n\n// Receive data until the server closes the connection\ndo {\n    iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0);\n    if (iResult > 0)\n        printf(\"Bytes received: %d\\n\", iResult);\n    else if (iResult == 0)\n        printf(\"Connection closed\\n\");\n    else\n        printf(\"recv failed: %d\\n\", WSAGetLastError());\n} while (iResult > 0);\n```\n\n### 3.4 断开连接\n同[2.6](#26__280)\n\n## 4. 完整应用代码\n### 4.1 Server\n```cpp\n// FileName: server.cpp\n// Description: Create server socket application\n// Author: Jiejing.Ma\n// Update: 2020/12/11\n\n#undef UNICODE\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif // !WIN32_LEAN_AND_MEAN\n\n#include <Windows.h>\n#include <WinSock2.h>  // socket\n#include <WS2tcpip.h>  // TCP/IP\n#include <iphlpapi.h>  // ip helper APIs\n#include <stdlib.h>\n#include <iostream>\n\n// Link to Ws2_32.lib\n#pragma comment(lib,\"Ws2_32.lib\")\n\n#define DEFAULT_BUFLEN 512\n#define DEFAULT_PORT \"27015\"\n\nusing namespace std;\n\nint main()\n{\n\tWSADATA wasData;\n\tint iRes;\n\n\t// Create a SOCKET object to listen for client connections\n\tSOCKET ListenSocket = INVALID_SOCKET;\n\t// Create temporary ClientSocket for accepting connetions from clients\n\tSOCKET ClientSocket = INVALID_SOCKET;\n\n\taddrinfo* result = NULL;\n\taddrinfo hints;\n\n\tchar recvbuf[DEFAULT_BUFLEN];\n\tint iSendRes;\n\tint recvbuflen = DEFAULT_BUFLEN;\n\n\t// 1. Initialize WinSock\n\tiRes = WSAStartup(MAKEWORD(2, 2), &wasData);\n\tif (iRes != 0)\n\t{\n\t\tcout << \"WSAStartup failed: \" << iRes << endl;\n\t\treturn 1;\n\t}\n\n\t// 2. Create server socket\n\tZeroMemory(&hints, sizeof(hints));\n\thints.ai_family = AF_INET;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\thints.ai_flags = AI_PASSIVE;\n\n\t// Resolve the local address and port to be used by the server\n\tiRes = getaddrinfo(NULL, DEFAULT_PORT, &hints, &result);\n\tif (iRes != 0)\n\t{\n\t\tcout << \"getaddrinfo failed: \" << iRes << endl;\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// Create a SOCKET for connecting to server\n\tListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);\n\t// Check for errors to ensure that the socket is valid socket\n\tif (ListenSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"Error at socket():\"<< WSAGetLastError() << endl;\n\t\tfreeaddrinfo(result);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// 3. Bind socket\n\t// Setup the TCP listening socket\n\tiRes = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"bind failed with error: \" << WSAGetLastError() << endl;\n\t\tfreeaddrinfo(result);\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\t// free memory allocated by getaddrinfo() for address information\n\tfreeaddrinfo(result);\n\n\t// 4. Listening on a Socket\n\tif (listen(ListenSocket, SOMAXCONN) == SOCKET_ERROR)\n\t{\n\t\tcout << \"Listen failed with error: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// 5. Accepting a Connetion\n\t// Accept a client socket\n\tClientSocket = accept(ListenSocket, NULL, NULL);\n\tif (ClientSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"accept failed: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// No longer need server socket\n\tclosesocket(ListenSocket);\n\n\t// 6. Receiving and Sending Data on the Server\n\tiRes = 1;\n\t// Receive until the peer shuts down the connection\n\twhile (iRes > 0)\n\t{\n\t\tiRes = recv(ClientSocket, recvbuf, recvbuflen, 0);\n\t\tif (iRes > 0)\n\t\t{\n\t\t\tcout << \"Bytes received: \" << iRes << endl;\n\n\t\t\t// Echo the buffr back to the sender\n\t\t\tiSendRes = send(ClientSocket, recvbuf, iRes, 0);\n\t\t\tif (iSendRes == SOCKET_ERROR)\n\t\t\t{\n\t\t\t\tcout << \"send failed: \" << WSAGetLastError() << endl;\n\t\t\t\tclosesocket(ClientSocket);\n\t\t\t\tWSACleanup();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcout << \"Bytes sent: \" << iSendRes << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout <<\"recv failed: \" << WSAGetLastError() << endl;\n\t\t\tclosesocket(ClientSocket);\n\t\t\tWSACleanup();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// 7.Disconneting the Server\n\t// shutdown the send half of the connetiong since no more data will be sent\n\tiRes = shutdown(ClientSocket, SD_SEND);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"shutdown failed: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ClientSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// cleanup\n\tclosesocket(ClientSocket);\n\tWSACleanup();\n\n\treturn 0;\n}\n```\n\n### 4.2 Client\n\n```cpp\n// FileName: client.cpp\n// Description: Create client socket application\n// Author: Jiejing.Ma\n// Update: 2020/12/11\n\n#undef UNICODE\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif // !WIN32_LEAN_AND_MEAN\n\n#include <Windows.h>\n#include <WinSock2.h>\n#include <WS2tcpip.h>\n#include <iphlpapi.h>\n#include <iostream>\n\n// Need to link with Ws2_32.li, Mswsock.lib, Advapi32.lib\n#pragma comment(lib,\"Ws2_32.lib\")\n#pragma comment(lib,\"Mswsock.lib\")\n#pragma comment(lib,\"Advapi32.lib\")\n\n#define DEFAULT_BUFLEN 512\n#define DEFAULT_PORT \"27015\"\n\nusing namespace std;\n\nint main(int argc,char ** argv)\n{\n\tWSADATA wsaData;\n\tint iRes;\n\n\tSOCKET ConnectSocket  = INVALID_SOCKET;\n\n\taddrinfo hints;\n\taddrinfo* result = NULL, *ptr=NULL;\n\n\tconst char *sendbuf=\"hello\";\n\tchar recvbuf[DEFAULT_BUFLEN];\n\tint recvbuflen = DEFAULT_BUFLEN;\n\n\t// 1. Initialize WinSock\n\tiRes = WSAStartup(MAKEWORD(2, 2), &wsaData);\n\tif (iRes != 0)\n\t{\n\t\tcout << \"WSAStartup failed: \" << iRes << endl;\n\t\treturn 1;\n\t}\n\n\t// 2. Create socket\n\tZeroMemory(&hints, sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_protocol = IPPROTO_TCP;\n\thints.ai_socktype = SOCK_STREAM;\n\n\t// Resolve the server address and port\n\tiRes = getaddrinfo(argv[1], DEFAULT_PORT, &hints, &result);\n\tif (iRes != 0)\n\t{\n\t\tcout << \"getaddrinfo failed:\" << iRes << endl;\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// Attempt to connect to an address until one succeeds\n\tfor (ptr = result; ptr != NULL; ptr = ptr->ai_next)\n\t{\n\t\t// Create a SOCKET for connecting to server\t\n\t\tConnectSocket  = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\n\t\tif (ConnectSocket  == INVALID_SOCKET)\n\t\t{\n\t\t\tcout << \"Error at socket():\" << WSAGetLastError() << endl;\n\t\t\tWSACleanup();\n\t\t\treturn 1;\n\t\t}\n\n\t\t// 3.Connect to Server\n\t\tiRes = connect(ConnectSocket , ptr->ai_addr, (int)ptr->ai_addrlen);\n\t\tif (iRes == SOCKET_ERROR)\n\t\t{\n\t\t\tclosesocket(ConnectSocket );\n\t\t\tConnectSocket  = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfreeaddrinfo(result);\n\n\tif (ConnectSocket  == INVALID_SOCKET)\n\t{\n\t\tcout << \"Unable to connect to server!\" << endl;\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\t// 4. Send and Receive data\n\t// Send an initial buffer\n\tiRes = send(ConnectSocket , sendbuf, (int)strlen(sendbuf), 0);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"send faild: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ConnectSocket );\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\tcout << \"Bytes sent: \" << iRes << endl;\n\n\t// shutdown the connection for sending since no more data will be sent\n\t// the client can still use the ConnectSocket for receiving data\n\tiRes = shutdown(ConnectSocket , SD_SEND);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"shutdown failed: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ConnectSocket );\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\tiRes = 1;\n\twhile (iRes>0)\n\t{\n\t\tiRes = recv(ConnectSocket , recvbuf, recvbuflen, 0);\n\t\tif (iRes > 0)\n\t\t\tprintf(\"Bytes received: %d\\n\", iRes);\n\t\telse if (iRes == 0)\n\t\t\tprintf(\"Connection closed\\n\");\n\t\telse\n\t\t\tprintf(\"recv failed: %d\\n\", WSAGetLastError());\n\t}\n\n\t// 5. Disconnect\n\t// cleanup\n\tclosesocket(ConnectSocket );\n\tWSACleanup();\n\n\treturn 0;\n}\n```","source":"_posts/Communication/Winsock创建socket server和client.md","raw":"\n---\ntitle: Winsock创建socket server和client\ndate: 2020-12-14 20:37:14\nauthor: 马捷径\nimg: https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=105906878,390165426&fm=26&gp=0.jpg\ntop: true\ncover: true\ncoverImg: https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=105906878,390165426&fm=26&gp=0.jpg\ntoc: true\nmathjax: true\nsummary: 深度理解在Win10上利用Winsock创建socket的服务端和客户端。\nkeywords: \n  - 通信 \n  - socket\n  - Winsock\n  - C++\ncategories: Communication\ntags:\n  - socket\n---\n\n\n\n本文详细介绍在Windows 10下利用Winsock创建socket server和client应用步骤和源码。项目源码可以到我的[github](https://github.com/MolianWH/CommutionTools/tree/main/Socket/SocketWin)上下载。在该仓库中，我准备将所有有关通信方式的源码做成工具包，便于以后开发直接使用。本文还可以在我的[CSND](https://blog.csdn.net/weixin_38369492/article/details/111032276)上查看。\n\n---\n\n\n## 1. 基本流程\n\n创建TCP/IP流的server/client通用步骤如下：\n\n### 1.1 Server和Client创建流程\n**Server**\n1. 初始化Winsock\n2. 创建socket\n3. 绑定socket\n4. 监听客户端socket\n5. 接受客户端连接请求\n6. 接收和发送数据\n7.  断开连接\n\n**Client**\n1. 初始化Winsock\n2. 创建socket\n3. 连接服务端\n4. 发送和接收数据\n5. 断开连接\n\n### 1.2 创建Winsock应用步骤\n创建一个最基础的Winsock应用需要以下几步\n\n1. 创建一个空项目\n2. 添加一个空的C++ source文件到项目中\n3. 引用Microsoft Windows SDK 的Include、Lib和Src目录\n4. 确保项目连接Winsock库文件：`#pragma comment(lib, Ws2_32.lib)`\n5. 编写Winsock应用程序。使用Winsock API需要包含两个头文件：**Winsock2.h**和**Ws2tcpip.h**。前者包含Winsock的大多数函数、结构体、定义；后者包含在WinSock 2中关于TCP/IP协议的用于检索IP地址的新函数和结构。\n\n通常一个Winsock应用的头部应该这样写：\n```cpp\n#include <WinSock2.h>\n#include <WS2tcpip.h>\n#include <stdio.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\nint main() {\n  return 0;\n}\n```\n\n> **Note**\n> - 如果使用ip helper APIs，需要包含Iphlpapi.h。且WinSock2.h需要在其前面。\n> - Winsock2.h包含了Windows.h一些核心内容，所以通常不需要再包含Windows.h了\n> - 如果要包含Windows.h，必须放在Winsock2.h前，并且要使用`#define WIN32_LEAN_AND_MEAN`。这是因为Windows.h中包含了Winsock.h（第一个版本），会和Winsock2.h冲突，使用该预定义会避免用Winsock.h\n\n所以一个升级版的头部应该这样写：\n\n```cpp\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif // !WIN32_LEAN_AND_MEAN\n\n#include <Windows.h>\n#include <WinSock2.h>  // socket\n#include <WS2tcpip.h>  // TCP/IP\n#include <iphlpapi.h>  // ip helper APIs\n#include <stdio.h>\n\n// Link to Ws2_32.lib\n#pragma comment(lib,\"Ws2_32.lib\")\n\nint main() {\n  return 0;\n}\n```\n\n### 1.3 初始化Winsock\n所有调用Winsock函数的进程(应用程序或DLL)必须在调用其他Winsock函数之前初始化Windows socket DLL再使用。这也确保了系统上支持Winsock。\n\n1. 创建WSADATA对象\n```cpp\n   WSADATA wsaData;\n```\n2. 调用WSAStartup，返回整数值，并通过该值检查错误。 \n ```cpp\n    // Initialize WinSock\n\tint iRes = WSAStartup(MAKEWORD(2, 2), &wasData);\n\tif (iRes != 0)\n\t{\n\t\t\tprintf(\"WSAStartup failed: %d\\n\" , iRes);\n\t\t\treturn 1;\n\t} \n```\n\n调用WSAStartup函数来启动WS2_32.dll的使用。\n\nWSADATA结构包含关于Windows套接字实现的信息。WSAStartup的MAKEWORD(2,2)参数在系统上请求Winsock的2.2版本，并将传递的版本设置为调用者可以使用的Windows套接字支持的最高版本。\n\n## 2. 创建server\n\n参考[1.1](#11_ServerClient_8)中的步骤，在[1.3](#13_Winsock_73)中已经说明了如何初始化Winsock，下面应该是创建server socket\n\n### 2.1 创建server socket\n\n1.  使用[getaddrinfo()](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo)确定sockaddr结构体值，getaddrinfo中使用[addrinfo](https://docs.microsoft.com/en-us/windows/win32/api/ws2def/ns-ws2def-addrinfoa)结构体。\n\n使用的信息包含以下内容：\n\n字段|作用|\n---|---\nAF_INET|指定IPv4地址族\nSOCK_STREAM|指定一个流套接字\nIPPROTO_TCP|指定TCP协议\nAI_PASSIVE|AI_PASSIVE标志表示调用者打算在调用bind函数时使用返回的套接字地址结构。当AI_PASSIVE标志被设置并且getaddrinfo函数的nodename参数是一个空指针时，套接字地址结构的IP地址部分被设置为IPv4地址INADDR_ANY或IPv6地址IN6ADDR_ANY_INIT。\n\n代码如下：\n```cpp\n   #define DEFAULT_PORT \"27015\"\n\n// 2. create server socket\n\taddrinfo* result = NULL, * ptr = NULL, hints;\n\n\tZeroMemory(&hints, sizeof(hints));\n\thints.ai_family = AF_INET;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\thints.ai_flags = AI_PASSIVE;\n\n\t// Resolve the local address and port to be used by the server\n\tiRes = getaddrinfo(NULL, DEFAULT_PORT, &hints, &result);\n\tif (iRes != 0)\n\t{\n\t\tprintf(\"getaddrinfo failed:%d\\n\",iRes);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n```\n\n<div id=\"refer-anchor-212\"></div>\n\n2. 创建SOCKET对象ListenSocket ，用来监听客户端连接请求。\n\n```cpp\nSOCKET ListenSocket = INVALID_SOCKET;\n```\n\n<div id=\"refer-anchor-213\"></div>\n\n3. 调用socket函数，返回值赋给ListenSocket 。\n\n对于server，使用getaddrinfo返回的第一个IP地址，该IP地址与在提示参数中指定的地址家族、套接字类型和协议相匹配\n\n如果想监听IPv6，ai_family = AF_INET6；\n\n如果想同时监听IPv4和IPv6，必须创建两个监听套接字，一个监听IPv6，一个监听IPv4。应用程序必须分别处理这两个套接字。\n\n```cpp\nListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);\n```\n\n<div id=\"refer-anchor-214\"></div>\n\n4. 检查错误，确保socket是一个有效的套接字\n\n```cpp\n\t// Check for errors to ensure that the socket is valid socket\n\tif (ListenSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"Error at socket():\"<< WSAGetLastError() << endl;\n\t\tfreeaddrinfo(result);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n```\n\n### 2.2 绑定socket\nserver如果要接收client连接请求，需要绑定一个网络地址。下面阐述如果绑定一个创建了IP地址和端口的socket。client使用IP地址和端口连接主机。\n\n1. bind并检查错误\n\nsockaddr结构保存有关地址家族、IP地址和端口号的信息。\n\n调用`bind()`，传递创建的socket和getaddrinfo函数返回的sockaddr结构作为参数。检查一般性错误。\n\n```cpp\n\t// 3. Bind socket\n\t// Setup the TCP listening socket\n\tiRes = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"bind failed with error: \" << WSAGetLastError() << endl;\n\t\tfreeaddrinfo(result);\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n```\n2. 释放存放地址信息的内存空间\n\n一旦绑定完成，getaddrinfo获取的地址信息就不在需要了，使用freeaddrinfo释放分配的内存。\n\n```cpp\n\t// free memory allocated by getaddrinfo() for address information\n\tfreeaddrinfo(result);\n```\n\n### 2.3 监听\nsocket绑定IP地址和端口后，需要监听该IP和端口发送的连接请求。\n\n调用`listen()`将创建的socket和待定的值(待定连接队列的最大长度)作为参数传递。在本例中，backlog参数被设置为SOMAXCONN。此值是一个特殊常量，指示此套接字的Winsock提供程序允许队列中挂起连接的最大合理数量。检查返回值是否有一般错误。\n\n### 2.4 接受连接请求\n\n监听时若收到连接请求，需处理该请求。\n\n1. 创建临时SOCKET对象ClientSocket接受client的连接\n\n```cpp\n// 5. Accepting a Connetion\n// Create temporary ClientSocket for accepting connetions from clients\nSOCKET ClientSocket = INVALID_SOCKET;\n```\n\n2. 通常server要监听多个客户端的连接请求。对一个高性能的server来说，需要使用多线程处理多客户端请求。\n\nWinsock有多种处理多客户端连接请求的技术。一种编程技术是创建一个连续循环，使用`listen()`检查连接请求(参见[2.3](#23__195))。如果出现连接请求，应用程序将调用`accept、AcceptEx或WSAAccept`函数，并将工作传递给另一个线程来处理请求。还可以使用其他几种编程技术。\n\n>**Note**\n>这个基本示例非常简单，并且不使用多线程。该示例还只侦听和接受单个连接。\n\n```cpp\n    // Accept a client socket\n\tClientSocket = accept(ListenSocket, NULL, NULL);\n\tif (ClientSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"accept failed: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n```\n\n### 2.5 接收好发送数据\n\n使用`recv()`和`send()`接收和发送消息\n```cpp\n#define DEFAULT_BUFLEN 512\n\n\t// 6. Receiving and Sending Data on the Server\n\tchar recvbuf[DEFAULT_BUFLEN];\n\tint iSendRes;\n\tint recvbuflen = DEFAULT_BUFLEN;\n\n\tiRes = 1;\n\t// Receive until the peer shuts down the connection\n\twhile (iRes > 0)\n\t{\n\t\tiRes = recv(ClientSocket, recvbuf, recvbuflen, 0);\n\t\tif (iRes > 0)\n\t\t{\n\t\t\tcout << \"Bytes received: \" << iRes << endl;\n\n\t\t\t// Echo the buffr back to the sender\n\t\t\tiSendRes = send(ClientSocket, recvbuf, iRes, 0);\n\t\t\tif (iSendRes == SOCKET_ERROR)\n\t\t\t{\n\t\t\t\tcout << \"send failed: \" << WSAGetLastError() << endl;\n\t\t\t\tclosesocket(ClientSocket);\n\t\t\t\tWSACleanup();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcout << \"Bytes sent: \" << iSendRes << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout <<\"recv failed: \" << WSAGetLastError() << endl;\n\t\t\tclosesocket(ClientSocket);\n\t\t\tWSACleanup();\n\t\t\treturn 1;\n\t\t}\n\t}\n```\n\n### 2.6 断开连接\n\n1. 当server完成向client发送数据时，可以调用`shutdown()`，指定`SD_SEND`来关闭套接字的发送端。这允许客户端释放此套接字的一些资源。服务器应用程序仍然可以接收套接字上的数据。\n```cpp\n\t// 7.Disconneting the Server\n\t// shutdown the send half of the connetiong since no more data will be sent\n\tiRes = shutdown(ClientSocket, SD_SEND);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"shutdown failed: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ClientSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n```\n\n2. 当客户端应用程序完成接收数据时，将调用`closesocket()`来关闭套接字。\n\n当客户端应用程序使用Windows套接字DLL完成时，WSACleanup函数被调用来释放资源。\n\n```cpp\n\t// cleanup\n\tclosesocket(ClientSocket);\n\tWSACleanup();\n\treturn 0;\n```\n\n## 3. 创建client\n与第2节大体相似。\n\n### 3.1 创建client socket\n\n1. 对于这个应用程序，Internet地址族是未指定的`AF_UNSPEC`，因此可以返回IPv6或IPv4地址。其余与[2.1](#21_server_socket_99)的1基本相同\n\n```cpp\nstruct addrinfo *result = NULL,\n                *ptr = NULL,\n                hints;\n\nZeroMemory( &hints, sizeof(hints) );\nhints.ai_family = AF_UNSPEC;\nhints.ai_socktype = SOCK_STREAM;\nhints.ai_protocol = IPPROTO_TCP;\n```\n\n2. 与[2.1](#21_server_socket_99)的1不同的是，请求在命令行中传递的服务器名称的IP地址。\n\n```cpp\n#define DEFAULT_PORT \"27015\"\n\n// Resolve the server address and port\niResult = getaddrinfo(argv[1], DEFAULT_PORT, &hints, &result);\nif (iResult != 0) {\n    printf(\"getaddrinfo failed: %d\\n\", iResult);\n    WSACleanup();\n    return 1;\n}\n```\n\n3. 同[2.1](#21_server_socket_99)的[2](#refer-anchor-212)\n\n```cpp\nSOCKET ConnectSocket = INVALID_SOCKET;\n```\n\n4. 同[2.1](#21_server_socket_99)的[3](#refer-anchor-213)\n\n```cpp\n// Attempt to connect to the first address returned by\n// the call to getaddrinfo\nptr=result;\n\n// Create a SOCKET for connecting to server\nConnectSocket = socket(ptr->ai_family, ptr->ai_socktype, \n    ptr->ai_protocol);\n```\n\n5. 同[2.1](#21_server_socket_99)的[4](#refer-anchor-214)\n\n```cpp\nif (ConnectSocket == INVALID_SOCKET) {\n    printf(\"Error at socket(): %ld\\n\", WSAGetLastError());\n    freeaddrinfo(result);\n    WSACleanup();\n    return 1;\n}\n```\n\n### 3.2 连接server\n\n客户端想要通信，需要连接server。\n\n调用`connect()`，设置参数为创建的socket和sockaddr结构，并检查错误。\n\n```cpp\n// Connect to server.\niResult = connect( ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);\nif (iResult == SOCKET_ERROR) {\n    closesocket(ConnectSocket);\n    ConnectSocket = INVALID_SOCKET;\n}\n\n// Should really try the next address returned by getaddrinfo\n// if the connect call failed\n// But for this simple example we just free the resources\n// returned by getaddrinfo and print an error message\n\nfreeaddrinfo(result);\n\nif (ConnectSocket == INVALID_SOCKET) {\n    printf(\"Unable to connect to server!\\n\");\n    WSACleanup();\n    return 1;\n}\n```\n\n在本例中，`getaddrinfo()`返回的第一个IP地址用于指定传递给连接的`sockaddr`结构。如果对第一个IP地址的连接调用失败，那么尝试从`getaddrinfo()`返回的链表中的下一个`addrinfo`结构。\n\nsockaddr结构中指定的信息包括:\n\n- 客户机将尝试连接到的服务器的IP地址。\n- 客户机将连接到的服务器端口号。当\n- 客户端调用`getaddrinfo()`时，该端口被指定为端口27015。\n\n### 3.3 发送接收数据\n\n```cpp#define DEFAULT_BUFLEN 512\nint recvbuflen = DEFAULT_BUFLEN;\n\nconst char *sendbuf = \"this is a test\";\nchar recvbuf[DEFAULT_BUFLEN];\n\nint iResult;\n\n// Send an initial buffer\niResult = send(ConnectSocket, sendbuf, (int) strlen(sendbuf), 0);\nif (iResult == SOCKET_ERROR) {\n    printf(\"send failed: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n}\n\nprintf(\"Bytes Sent: %ld\\n\", iResult);\n\n// shutdown the connection for sending since no more data will be sent\n// the client can still use the ConnectSocket for receiving data\niResult = shutdown(ConnectSocket, SD_SEND);\nif (iResult == SOCKET_ERROR) {\n    printf(\"shutdown failed: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n}\n\n// Receive data until the server closes the connection\ndo {\n    iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0);\n    if (iResult > 0)\n        printf(\"Bytes received: %d\\n\", iResult);\n    else if (iResult == 0)\n        printf(\"Connection closed\\n\");\n    else\n        printf(\"recv failed: %d\\n\", WSAGetLastError());\n} while (iResult > 0);\n```\n\n### 3.4 断开连接\n同[2.6](#26__280)\n\n## 4. 完整应用代码\n### 4.1 Server\n```cpp\n// FileName: server.cpp\n// Description: Create server socket application\n// Author: Jiejing.Ma\n// Update: 2020/12/11\n\n#undef UNICODE\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif // !WIN32_LEAN_AND_MEAN\n\n#include <Windows.h>\n#include <WinSock2.h>  // socket\n#include <WS2tcpip.h>  // TCP/IP\n#include <iphlpapi.h>  // ip helper APIs\n#include <stdlib.h>\n#include <iostream>\n\n// Link to Ws2_32.lib\n#pragma comment(lib,\"Ws2_32.lib\")\n\n#define DEFAULT_BUFLEN 512\n#define DEFAULT_PORT \"27015\"\n\nusing namespace std;\n\nint main()\n{\n\tWSADATA wasData;\n\tint iRes;\n\n\t// Create a SOCKET object to listen for client connections\n\tSOCKET ListenSocket = INVALID_SOCKET;\n\t// Create temporary ClientSocket for accepting connetions from clients\n\tSOCKET ClientSocket = INVALID_SOCKET;\n\n\taddrinfo* result = NULL;\n\taddrinfo hints;\n\n\tchar recvbuf[DEFAULT_BUFLEN];\n\tint iSendRes;\n\tint recvbuflen = DEFAULT_BUFLEN;\n\n\t// 1. Initialize WinSock\n\tiRes = WSAStartup(MAKEWORD(2, 2), &wasData);\n\tif (iRes != 0)\n\t{\n\t\tcout << \"WSAStartup failed: \" << iRes << endl;\n\t\treturn 1;\n\t}\n\n\t// 2. Create server socket\n\tZeroMemory(&hints, sizeof(hints));\n\thints.ai_family = AF_INET;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\thints.ai_flags = AI_PASSIVE;\n\n\t// Resolve the local address and port to be used by the server\n\tiRes = getaddrinfo(NULL, DEFAULT_PORT, &hints, &result);\n\tif (iRes != 0)\n\t{\n\t\tcout << \"getaddrinfo failed: \" << iRes << endl;\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// Create a SOCKET for connecting to server\n\tListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);\n\t// Check for errors to ensure that the socket is valid socket\n\tif (ListenSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"Error at socket():\"<< WSAGetLastError() << endl;\n\t\tfreeaddrinfo(result);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// 3. Bind socket\n\t// Setup the TCP listening socket\n\tiRes = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"bind failed with error: \" << WSAGetLastError() << endl;\n\t\tfreeaddrinfo(result);\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\t// free memory allocated by getaddrinfo() for address information\n\tfreeaddrinfo(result);\n\n\t// 4. Listening on a Socket\n\tif (listen(ListenSocket, SOMAXCONN) == SOCKET_ERROR)\n\t{\n\t\tcout << \"Listen failed with error: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// 5. Accepting a Connetion\n\t// Accept a client socket\n\tClientSocket = accept(ListenSocket, NULL, NULL);\n\tif (ClientSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"accept failed: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// No longer need server socket\n\tclosesocket(ListenSocket);\n\n\t// 6. Receiving and Sending Data on the Server\n\tiRes = 1;\n\t// Receive until the peer shuts down the connection\n\twhile (iRes > 0)\n\t{\n\t\tiRes = recv(ClientSocket, recvbuf, recvbuflen, 0);\n\t\tif (iRes > 0)\n\t\t{\n\t\t\tcout << \"Bytes received: \" << iRes << endl;\n\n\t\t\t// Echo the buffr back to the sender\n\t\t\tiSendRes = send(ClientSocket, recvbuf, iRes, 0);\n\t\t\tif (iSendRes == SOCKET_ERROR)\n\t\t\t{\n\t\t\t\tcout << \"send failed: \" << WSAGetLastError() << endl;\n\t\t\t\tclosesocket(ClientSocket);\n\t\t\t\tWSACleanup();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcout << \"Bytes sent: \" << iSendRes << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout <<\"recv failed: \" << WSAGetLastError() << endl;\n\t\t\tclosesocket(ClientSocket);\n\t\t\tWSACleanup();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// 7.Disconneting the Server\n\t// shutdown the send half of the connetiong since no more data will be sent\n\tiRes = shutdown(ClientSocket, SD_SEND);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"shutdown failed: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ClientSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// cleanup\n\tclosesocket(ClientSocket);\n\tWSACleanup();\n\n\treturn 0;\n}\n```\n\n### 4.2 Client\n\n```cpp\n// FileName: client.cpp\n// Description: Create client socket application\n// Author: Jiejing.Ma\n// Update: 2020/12/11\n\n#undef UNICODE\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif // !WIN32_LEAN_AND_MEAN\n\n#include <Windows.h>\n#include <WinSock2.h>\n#include <WS2tcpip.h>\n#include <iphlpapi.h>\n#include <iostream>\n\n// Need to link with Ws2_32.li, Mswsock.lib, Advapi32.lib\n#pragma comment(lib,\"Ws2_32.lib\")\n#pragma comment(lib,\"Mswsock.lib\")\n#pragma comment(lib,\"Advapi32.lib\")\n\n#define DEFAULT_BUFLEN 512\n#define DEFAULT_PORT \"27015\"\n\nusing namespace std;\n\nint main(int argc,char ** argv)\n{\n\tWSADATA wsaData;\n\tint iRes;\n\n\tSOCKET ConnectSocket  = INVALID_SOCKET;\n\n\taddrinfo hints;\n\taddrinfo* result = NULL, *ptr=NULL;\n\n\tconst char *sendbuf=\"hello\";\n\tchar recvbuf[DEFAULT_BUFLEN];\n\tint recvbuflen = DEFAULT_BUFLEN;\n\n\t// 1. Initialize WinSock\n\tiRes = WSAStartup(MAKEWORD(2, 2), &wsaData);\n\tif (iRes != 0)\n\t{\n\t\tcout << \"WSAStartup failed: \" << iRes << endl;\n\t\treturn 1;\n\t}\n\n\t// 2. Create socket\n\tZeroMemory(&hints, sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_protocol = IPPROTO_TCP;\n\thints.ai_socktype = SOCK_STREAM;\n\n\t// Resolve the server address and port\n\tiRes = getaddrinfo(argv[1], DEFAULT_PORT, &hints, &result);\n\tif (iRes != 0)\n\t{\n\t\tcout << \"getaddrinfo failed:\" << iRes << endl;\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// Attempt to connect to an address until one succeeds\n\tfor (ptr = result; ptr != NULL; ptr = ptr->ai_next)\n\t{\n\t\t// Create a SOCKET for connecting to server\t\n\t\tConnectSocket  = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\n\t\tif (ConnectSocket  == INVALID_SOCKET)\n\t\t{\n\t\t\tcout << \"Error at socket():\" << WSAGetLastError() << endl;\n\t\t\tWSACleanup();\n\t\t\treturn 1;\n\t\t}\n\n\t\t// 3.Connect to Server\n\t\tiRes = connect(ConnectSocket , ptr->ai_addr, (int)ptr->ai_addrlen);\n\t\tif (iRes == SOCKET_ERROR)\n\t\t{\n\t\t\tclosesocket(ConnectSocket );\n\t\t\tConnectSocket  = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfreeaddrinfo(result);\n\n\tif (ConnectSocket  == INVALID_SOCKET)\n\t{\n\t\tcout << \"Unable to connect to server!\" << endl;\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\t// 4. Send and Receive data\n\t// Send an initial buffer\n\tiRes = send(ConnectSocket , sendbuf, (int)strlen(sendbuf), 0);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"send faild: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ConnectSocket );\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\tcout << \"Bytes sent: \" << iRes << endl;\n\n\t// shutdown the connection for sending since no more data will be sent\n\t// the client can still use the ConnectSocket for receiving data\n\tiRes = shutdown(ConnectSocket , SD_SEND);\n\tif (iRes == SOCKET_ERROR)\n\t{\n\t\tcout << \"shutdown failed: \" << WSAGetLastError() << endl;\n\t\tclosesocket(ConnectSocket );\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\tiRes = 1;\n\twhile (iRes>0)\n\t{\n\t\tiRes = recv(ConnectSocket , recvbuf, recvbuflen, 0);\n\t\tif (iRes > 0)\n\t\t\tprintf(\"Bytes received: %d\\n\", iRes);\n\t\telse if (iRes == 0)\n\t\t\tprintf(\"Connection closed\\n\");\n\t\telse\n\t\t\tprintf(\"recv failed: %d\\n\", WSAGetLastError());\n\t}\n\n\t// 5. Disconnect\n\t// cleanup\n\tclosesocket(ConnectSocket );\n\tWSACleanup();\n\n\treturn 0;\n}\n```","slug":"Communication/Winsock创建socket server和client","published":1,"updated":"2020-12-14T12:37:40.807Z","_id":"ckioje2me0000af7ebyqkgz19","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文详细介绍在Windows 10下利用Winsock创建socket server和client应用步骤和源码。项目源码可以到我的<a href=\"https://github.com/MolianWH/CommutionTools/tree/main/Socket/SocketWin\">github</a>上下载。在该仓库中，我准备将所有有关通信方式的源码做成工具包，便于以后开发直接使用。本文还可以在我的<a href=\"https://blog.csdn.net/weixin_38369492/article/details/111032276\">CSND</a>上查看。</p>\n<hr>\n<h2 id=\"1-基本流程\"><a href=\"#1-基本流程\" class=\"headerlink\" title=\"1. 基本流程\"></a>1. 基本流程</h2><p>创建TCP/IP流的server/client通用步骤如下：</p>\n<h3 id=\"1-1-Server和Client创建流程\"><a href=\"#1-1-Server和Client创建流程\" class=\"headerlink\" title=\"1.1 Server和Client创建流程\"></a>1.1 Server和Client创建流程</h3><p><strong>Server</strong></p>\n<ol>\n<li>初始化Winsock</li>\n<li>创建socket</li>\n<li>绑定socket</li>\n<li>监听客户端socket</li>\n<li>接受客户端连接请求</li>\n<li>接收和发送数据</li>\n<li> 断开连接</li>\n</ol>\n<p><strong>Client</strong></p>\n<ol>\n<li>初始化Winsock</li>\n<li>创建socket</li>\n<li>连接服务端</li>\n<li>发送和接收数据</li>\n<li>断开连接</li>\n</ol>\n<h3 id=\"1-2-创建Winsock应用步骤\"><a href=\"#1-2-创建Winsock应用步骤\" class=\"headerlink\" title=\"1.2 创建Winsock应用步骤\"></a>1.2 创建Winsock应用步骤</h3><p>创建一个最基础的Winsock应用需要以下几步</p>\n<ol>\n<li>创建一个空项目</li>\n<li>添加一个空的C++ source文件到项目中</li>\n<li>引用Microsoft Windows SDK 的Include、Lib和Src目录</li>\n<li>确保项目连接Winsock库文件：<code>#pragma comment(lib, Ws2_32.lib)</code></li>\n<li>编写Winsock应用程序。使用Winsock API需要包含两个头文件：<strong>Winsock2.h</strong>和<strong>Ws2tcpip.h</strong>。前者包含Winsock的大多数函数、结构体、定义；后者包含在WinSock 2中关于TCP/IP协议的用于检索IP地址的新函数和结构。</li>\n</ol>\n<p>通常一个Winsock应用的头部应该这样写：</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;WinSock2.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;WS2tcpip.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> comment(lib, \"Ws2_32.lib\")</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<blockquote>\n<p><strong>Note</strong></p>\n<ul>\n<li>如果使用ip helper APIs，需要包含Iphlpapi.h。且WinSock2.h需要在其前面。</li>\n<li>Winsock2.h包含了Windows.h一些核心内容，所以通常不需要再包含Windows.h了</li>\n<li>如果要包含Windows.h，必须放在Winsock2.h前，并且要使用<code>#define WIN32_LEAN_AND_MEAN</code>。这是因为Windows.h中包含了Winsock.h（第一个版本），会和Winsock2.h冲突，使用该预定义会避免用Winsock.h</li>\n</ul>\n</blockquote>\n<p>所以一个升级版的头部应该这样写：</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> WIN32_LEAN_AND_MEAN</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> WIN32_LEAN_AND_MEAN</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span> </span><span class=\"token comment\" spellcheck=\"true\">// !WIN32_LEAN_AND_MEAN</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;Windows.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;WinSock2.h></span>  </span><span class=\"token comment\" spellcheck=\"true\">// socket</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;WS2tcpip.h></span>  </span><span class=\"token comment\" spellcheck=\"true\">// TCP/IP</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iphlpapi.h></span>  </span><span class=\"token comment\" spellcheck=\"true\">// ip helper APIs</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Link to Ws2_32.lib</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> comment(lib,\"Ws2_32.lib\")</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"1-3-初始化Winsock\"><a href=\"#1-3-初始化Winsock\" class=\"headerlink\" title=\"1.3 初始化Winsock\"></a>1.3 初始化Winsock</h3><p>所有调用Winsock函数的进程(应用程序或DLL)必须在调用其他Winsock函数之前初始化Windows socket DLL再使用。这也确保了系统上支持Winsock。</p>\n<ol>\n<li>创建WSADATA对象<pre class=\" language-cpp\"><code class=\"language-cpp\">WSADATA wsaData<span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li>调用WSAStartup，返回整数值，并通过该值检查错误。 <pre class=\" language-cpp\"><code class=\"language-cpp\"> <span class=\"token comment\" spellcheck=\"true\">// Initialize WinSock</span>\n <span class=\"token keyword\">int</span> iRes <span class=\"token operator\">=</span> <span class=\"token function\">WSAStartup</span><span class=\"token punctuation\">(</span><span class=\"token function\">MAKEWORD</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>wasData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{</span>\n         <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"WSAStartup failed: %d\\n\"</span> <span class=\"token punctuation\">,</span> iRes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span> </code></pre>\n</li>\n</ol>\n<p>调用WSAStartup函数来启动WS2_32.dll的使用。</p>\n<p>WSADATA结构包含关于Windows套接字实现的信息。WSAStartup的MAKEWORD(2,2)参数在系统上请求Winsock的2.2版本，并将传递的版本设置为调用者可以使用的Windows套接字支持的最高版本。</p>\n<h2 id=\"2-创建server\"><a href=\"#2-创建server\" class=\"headerlink\" title=\"2. 创建server\"></a>2. 创建server</h2><p>参考<a href=\"#11_ServerClient_8\">1.1</a>中的步骤，在<a href=\"#13_Winsock_73\">1.3</a>中已经说明了如何初始化Winsock，下面应该是创建server socket</p>\n<h3 id=\"2-1-创建server-socket\"><a href=\"#2-1-创建server-socket\" class=\"headerlink\" title=\"2.1 创建server socket\"></a>2.1 创建server socket</h3><ol>\n<li> 使用<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo\">getaddrinfo()</a>确定sockaddr结构体值，getaddrinfo中使用<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/ws2def/ns-ws2def-addrinfoa\">addrinfo</a>结构体。</li>\n</ol>\n<p>使用的信息包含以下内容：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AF_INET</td>\n<td>指定IPv4地址族</td>\n</tr>\n<tr>\n<td>SOCK_STREAM</td>\n<td>指定一个流套接字</td>\n</tr>\n<tr>\n<td>IPPROTO_TCP</td>\n<td>指定TCP协议</td>\n</tr>\n<tr>\n<td>AI_PASSIVE</td>\n<td>AI_PASSIVE标志表示调用者打算在调用bind函数时使用返回的套接字地址结构。当AI_PASSIVE标志被设置并且getaddrinfo函数的nodename参数是一个空指针时，套接字地址结构的IP地址部分被设置为IPv4地址INADDR_ANY或IPv6地址IN6ADDR_ANY_INIT。</td>\n</tr>\n</tbody></table>\n<p>代码如下：</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">   <span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> DEFAULT_PORT \"27015\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 2. create server socket</span>\n    addrinfo<span class=\"token operator\">*</span> result <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span> ptr <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> hints<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">ZeroMemory</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>hints<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>hints<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_family <span class=\"token operator\">=</span> AF_INET<span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_socktype <span class=\"token operator\">=</span> SOCK_STREAM<span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_protocol <span class=\"token operator\">=</span> IPPROTO_TCP<span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_flags <span class=\"token operator\">=</span> AI_PASSIVE<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Resolve the local address and port to be used by the server</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token function\">getaddrinfo</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> DEFAULT_PORT<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>hints<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"getaddrinfo failed:%d\\n\"</span><span class=\"token punctuation\">,</span>iRes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<div id=\"refer-anchor-212\"></div>\n\n<ol start=\"2\">\n<li>创建SOCKET对象ListenSocket ，用来监听客户端连接请求。</li>\n</ol>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">SOCKET ListenSocket <span class=\"token operator\">=</span> INVALID_SOCKET<span class=\"token punctuation\">;</span></code></pre>\n<div id=\"refer-anchor-213\"></div>\n\n<ol start=\"3\">\n<li>调用socket函数，返回值赋给ListenSocket 。</li>\n</ol>\n<p>对于server，使用getaddrinfo返回的第一个IP地址，该IP地址与在提示参数中指定的地址家族、套接字类型和协议相匹配</p>\n<p>如果想监听IPv6，ai_family = AF_INET6；</p>\n<p>如果想同时监听IPv4和IPv6，必须创建两个监听套接字，一个监听IPv6，一个监听IPv4。应用程序必须分别处理这两个套接字。</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">ListenSocket <span class=\"token operator\">=</span> <span class=\"token function\">socket</span><span class=\"token punctuation\">(</span>result<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_family<span class=\"token punctuation\">,</span> result<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_socktype<span class=\"token punctuation\">,</span> result<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_protocol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<div id=\"refer-anchor-214\"></div>\n\n<ol start=\"4\">\n<li>检查错误，确保socket是一个有效的套接字</li>\n</ol>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">    <span class=\"token comment\" spellcheck=\"true\">// Check for errors to ensure that the socket is valid socket</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ListenSocket <span class=\"token operator\">==</span> INVALID_SOCKET<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Error at socket():\"</span><span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">freeaddrinfo</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"2-2-绑定socket\"><a href=\"#2-2-绑定socket\" class=\"headerlink\" title=\"2.2 绑定socket\"></a>2.2 绑定socket</h3><p>server如果要接收client连接请求，需要绑定一个网络地址。下面阐述如果绑定一个创建了IP地址和端口的socket。client使用IP地址和端口连接主机。</p>\n<ol>\n<li>bind并检查错误</li>\n</ol>\n<p>sockaddr结构保存有关地址家族、IP地址和端口号的信息。</p>\n<p>调用<code>bind()</code>，传递创建的socket和getaddrinfo函数返回的sockaddr结构作为参数。检查一般性错误。</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">    <span class=\"token comment\" spellcheck=\"true\">// 3. Bind socket</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Setup the TCP listening socket</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">,</span> result<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_addr<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>result<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_addrlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"bind failed with error: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">freeaddrinfo</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<ol start=\"2\">\n<li>释放存放地址信息的内存空间</li>\n</ol>\n<p>一旦绑定完成，getaddrinfo获取的地址信息就不在需要了，使用freeaddrinfo释放分配的内存。</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">    <span class=\"token comment\" spellcheck=\"true\">// free memory allocated by getaddrinfo() for address information</span>\n    <span class=\"token function\">freeaddrinfo</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"2-3-监听\"><a href=\"#2-3-监听\" class=\"headerlink\" title=\"2.3 监听\"></a>2.3 监听</h3><p>socket绑定IP地址和端口后，需要监听该IP和端口发送的连接请求。</p>\n<p>调用<code>listen()</code>将创建的socket和待定的值(待定连接队列的最大长度)作为参数传递。在本例中，backlog参数被设置为SOMAXCONN。此值是一个特殊常量，指示此套接字的Winsock提供程序允许队列中挂起连接的最大合理数量。检查返回值是否有一般错误。</p>\n<h3 id=\"2-4-接受连接请求\"><a href=\"#2-4-接受连接请求\" class=\"headerlink\" title=\"2.4 接受连接请求\"></a>2.4 接受连接请求</h3><p>监听时若收到连接请求，需处理该请求。</p>\n<ol>\n<li>创建临时SOCKET对象ClientSocket接受client的连接</li>\n</ol>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// 5. Accepting a Connetion</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create temporary ClientSocket for accepting connetions from clients</span>\nSOCKET ClientSocket <span class=\"token operator\">=</span> INVALID_SOCKET<span class=\"token punctuation\">;</span></code></pre>\n<ol start=\"2\">\n<li>通常server要监听多个客户端的连接请求。对一个高性能的server来说，需要使用多线程处理多客户端请求。</li>\n</ol>\n<p>Winsock有多种处理多客户端连接请求的技术。一种编程技术是创建一个连续循环，使用<code>listen()</code>检查连接请求(参见<a href=\"#23__195\">2.3</a>)。如果出现连接请求，应用程序将调用<code>accept、AcceptEx或WSAAccept</code>函数，并将工作传递给另一个线程来处理请求。还可以使用其他几种编程技术。</p>\n<blockquote>\n<p><strong>Note</strong><br>这个基本示例非常简单，并且不使用多线程。该示例还只侦听和接受单个连接。</p>\n</blockquote>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">    <span class=\"token comment\" spellcheck=\"true\">// Accept a client socket</span>\n    ClientSocket <span class=\"token operator\">=</span> <span class=\"token function\">accept</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ClientSocket <span class=\"token operator\">==</span> INVALID_SOCKET<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"accept failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"2-5-接收好发送数据\"><a href=\"#2-5-接收好发送数据\" class=\"headerlink\" title=\"2.5 接收好发送数据\"></a>2.5 接收好发送数据</h3><p>使用<code>recv()</code>和<code>send()</code>接收和发送消息</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> DEFAULT_BUFLEN 512</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 6. Receiving and Sending Data on the Server</span>\n    <span class=\"token keyword\">char</span> recvbuf<span class=\"token punctuation\">[</span>DEFAULT_BUFLEN<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> iSendRes<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> recvbuflen <span class=\"token operator\">=</span> DEFAULT_BUFLEN<span class=\"token punctuation\">;</span>\n\n    iRes <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Receive until the peer shuts down the connection</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        iRes <span class=\"token operator\">=</span> <span class=\"token function\">recv</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">,</span> recvbuf<span class=\"token punctuation\">,</span> recvbuflen<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Bytes received: \"</span> <span class=\"token operator\">&lt;&lt;</span> iRes <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// Echo the buffr back to the sender</span>\n            iSendRes <span class=\"token operator\">=</span> <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">,</span> recvbuf<span class=\"token punctuation\">,</span> iRes<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iSendRes <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"send failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n                <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Bytes sent: \"</span> <span class=\"token operator\">&lt;&lt;</span> iSendRes <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            cout <span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"recv failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"2-6-断开连接\"><a href=\"#2-6-断开连接\" class=\"headerlink\" title=\"2.6 断开连接\"></a>2.6 断开连接</h3><ol>\n<li><p>当server完成向client发送数据时，可以调用<code>shutdown()</code>，指定<code>SD_SEND</code>来关闭套接字的发送端。这允许客户端释放此套接字的一些资源。服务器应用程序仍然可以接收套接字上的数据。</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"> <span class=\"token comment\" spellcheck=\"true\">// 7.Disconneting the Server</span>\n <span class=\"token comment\" spellcheck=\"true\">// shutdown the send half of the connetiong since no more data will be sent</span>\n iRes <span class=\"token operator\">=</span> <span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">,</span> SD_SEND<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{</span>\n     cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"shutdown failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n     <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>当客户端应用程序完成接收数据时，将调用<code>closesocket()</code>来关闭套接字。</p>\n</li>\n</ol>\n<p>当客户端应用程序使用Windows套接字DLL完成时，WSACleanup函数被调用来释放资源。</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">    <span class=\"token comment\" spellcheck=\"true\">// cleanup</span>\n    <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"3-创建client\"><a href=\"#3-创建client\" class=\"headerlink\" title=\"3. 创建client\"></a>3. 创建client</h2><p>与第2节大体相似。</p>\n<h3 id=\"3-1-创建client-socket\"><a href=\"#3-1-创建client-socket\" class=\"headerlink\" title=\"3.1 创建client socket\"></a>3.1 创建client socket</h3><ol>\n<li>对于这个应用程序，Internet地址族是未指定的<code>AF_UNSPEC</code>，因此可以返回IPv6或IPv4地址。其余与<a href=\"#21_server_socket_99\">2.1</a>的1基本相同</li>\n</ol>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> addrinfo <span class=\"token operator\">*</span>result <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span>\n                <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span>\n                hints<span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">ZeroMemory</span><span class=\"token punctuation\">(</span> <span class=\"token operator\">&amp;</span>hints<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>hints<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nhints<span class=\"token punctuation\">.</span>ai_family <span class=\"token operator\">=</span> AF_UNSPEC<span class=\"token punctuation\">;</span>\nhints<span class=\"token punctuation\">.</span>ai_socktype <span class=\"token operator\">=</span> SOCK_STREAM<span class=\"token punctuation\">;</span>\nhints<span class=\"token punctuation\">.</span>ai_protocol <span class=\"token operator\">=</span> IPPROTO_TCP<span class=\"token punctuation\">;</span></code></pre>\n<ol start=\"2\">\n<li>与<a href=\"#21_server_socket_99\">2.1</a>的1不同的是，请求在命令行中传递的服务器名称的IP地址。</li>\n</ol>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> DEFAULT_PORT \"27015\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Resolve the server address and port</span>\niResult <span class=\"token operator\">=</span> <span class=\"token function\">getaddrinfo</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> DEFAULT_PORT<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>hints<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iResult <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"getaddrinfo failed: %d\\n\"</span><span class=\"token punctuation\">,</span> iResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ol start=\"3\">\n<li>同<a href=\"#21_server_socket_99\">2.1</a>的<a href=\"#refer-anchor-212\">2</a></li>\n</ol>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">SOCKET ConnectSocket <span class=\"token operator\">=</span> INVALID_SOCKET<span class=\"token punctuation\">;</span></code></pre>\n<ol start=\"4\">\n<li>同<a href=\"#21_server_socket_99\">2.1</a>的<a href=\"#refer-anchor-213\">3</a></li>\n</ol>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// Attempt to connect to the first address returned by</span>\n<span class=\"token comment\" spellcheck=\"true\">// the call to getaddrinfo</span>\nptr<span class=\"token operator\">=</span>result<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Create a SOCKET for connecting to server</span>\nConnectSocket <span class=\"token operator\">=</span> <span class=\"token function\">socket</span><span class=\"token punctuation\">(</span>ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_family<span class=\"token punctuation\">,</span> ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_socktype<span class=\"token punctuation\">,</span> \n    ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_protocol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<ol start=\"5\">\n<li>同<a href=\"#21_server_socket_99\">2.1</a>的<a href=\"#refer-anchor-214\">4</a></li>\n</ol>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ConnectSocket <span class=\"token operator\">==</span> INVALID_SOCKET<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error at socket(): %ld\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">freeaddrinfo</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"3-2-连接server\"><a href=\"#3-2-连接server\" class=\"headerlink\" title=\"3.2 连接server\"></a>3.2 连接server</h3><p>客户端想要通信，需要连接server。</p>\n<p>调用<code>connect()</code>，设置参数为创建的socket和sockaddr结构，并检查错误。</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// Connect to server.</span>\niResult <span class=\"token operator\">=</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span> ConnectSocket<span class=\"token punctuation\">,</span> ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_addr<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_addrlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iResult <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ConnectSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ConnectSocket <span class=\"token operator\">=</span> INVALID_SOCKET<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Should really try the next address returned by getaddrinfo</span>\n<span class=\"token comment\" spellcheck=\"true\">// if the connect call failed</span>\n<span class=\"token comment\" spellcheck=\"true\">// But for this simple example we just free the resources</span>\n<span class=\"token comment\" spellcheck=\"true\">// returned by getaddrinfo and print an error message</span>\n\n<span class=\"token function\">freeaddrinfo</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ConnectSocket <span class=\"token operator\">==</span> INVALID_SOCKET<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unable to connect to server!\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>在本例中，<code>getaddrinfo()</code>返回的第一个IP地址用于指定传递给连接的<code>sockaddr</code>结构。如果对第一个IP地址的连接调用失败，那么尝试从<code>getaddrinfo()</code>返回的链表中的下一个<code>addrinfo</code>结构。</p>\n<p>sockaddr结构中指定的信息包括:</p>\n<ul>\n<li>客户机将尝试连接到的服务器的IP地址。</li>\n<li>客户机将连接到的服务器端口号。当</li>\n<li>客户端调用<code>getaddrinfo()</code>时，该端口被指定为端口27015。</li>\n</ul>\n<h3 id=\"3-3-发送接收数据\"><a href=\"#3-3-发送接收数据\" class=\"headerlink\" title=\"3.3 发送接收数据\"></a>3.3 发送接收数据</h3><pre class=\" language-cpp#define\"><code class=\"language-cpp#define\">int recvbuflen = DEFAULT_BUFLEN;\n\nconst char *sendbuf = \"this is a test\";\nchar recvbuf[DEFAULT_BUFLEN];\n\nint iResult;\n\n// Send an initial buffer\niResult = send(ConnectSocket, sendbuf, (int) strlen(sendbuf), 0);\nif (iResult == SOCKET_ERROR) {\n    printf(\"send failed: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n}\n\nprintf(\"Bytes Sent: %ld\\n\", iResult);\n\n// shutdown the connection for sending since no more data will be sent\n// the client can still use the ConnectSocket for receiving data\niResult = shutdown(ConnectSocket, SD_SEND);\nif (iResult == SOCKET_ERROR) {\n    printf(\"shutdown failed: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n}\n\n// Receive data until the server closes the connection\ndo {\n    iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0);\n    if (iResult > 0)\n        printf(\"Bytes received: %d\\n\", iResult);\n    else if (iResult == 0)\n        printf(\"Connection closed\\n\");\n    else\n        printf(\"recv failed: %d\\n\", WSAGetLastError());\n} while (iResult > 0);</code></pre>\n<h3 id=\"3-4-断开连接\"><a href=\"#3-4-断开连接\" class=\"headerlink\" title=\"3.4 断开连接\"></a>3.4 断开连接</h3><p>同<a href=\"#26__280\">2.6</a></p>\n<h2 id=\"4-完整应用代码\"><a href=\"#4-完整应用代码\" class=\"headerlink\" title=\"4. 完整应用代码\"></a>4. 完整应用代码</h2><h3 id=\"4-1-Server\"><a href=\"#4-1-Server\" class=\"headerlink\" title=\"4.1 Server\"></a>4.1 Server</h3><pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// FileName: server.cpp</span>\n<span class=\"token comment\" spellcheck=\"true\">// Description: Create server socket application</span>\n<span class=\"token comment\" spellcheck=\"true\">// Author: Jiejing.Ma</span>\n<span class=\"token comment\" spellcheck=\"true\">// Update: 2020/12/11</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">undef</span> UNICODE</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> WIN32_LEAN_AND_MEAN</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> WIN32_LEAN_AND_MEAN</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span> </span><span class=\"token comment\" spellcheck=\"true\">// !WIN32_LEAN_AND_MEAN</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;Windows.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;WinSock2.h></span>  </span><span class=\"token comment\" spellcheck=\"true\">// socket</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;WS2tcpip.h></span>  </span><span class=\"token comment\" spellcheck=\"true\">// TCP/IP</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iphlpapi.h></span>  </span><span class=\"token comment\" spellcheck=\"true\">// ip helper APIs</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Link to Ws2_32.lib</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> comment(lib,\"Ws2_32.lib\")</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> DEFAULT_BUFLEN 512</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> DEFAULT_PORT \"27015\"</span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    WSADATA wasData<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> iRes<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Create a SOCKET object to listen for client connections</span>\n    SOCKET ListenSocket <span class=\"token operator\">=</span> INVALID_SOCKET<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Create temporary ClientSocket for accepting connetions from clients</span>\n    SOCKET ClientSocket <span class=\"token operator\">=</span> INVALID_SOCKET<span class=\"token punctuation\">;</span>\n\n    addrinfo<span class=\"token operator\">*</span> result <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    addrinfo hints<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">char</span> recvbuf<span class=\"token punctuation\">[</span>DEFAULT_BUFLEN<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> iSendRes<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> recvbuflen <span class=\"token operator\">=</span> DEFAULT_BUFLEN<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 1. Initialize WinSock</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token function\">WSAStartup</span><span class=\"token punctuation\">(</span><span class=\"token function\">MAKEWORD</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>wasData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"WSAStartup failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> iRes <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 2. Create server socket</span>\n    <span class=\"token function\">ZeroMemory</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>hints<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>hints<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_family <span class=\"token operator\">=</span> AF_INET<span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_socktype <span class=\"token operator\">=</span> SOCK_STREAM<span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_protocol <span class=\"token operator\">=</span> IPPROTO_TCP<span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_flags <span class=\"token operator\">=</span> AI_PASSIVE<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Resolve the local address and port to be used by the server</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token function\">getaddrinfo</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> DEFAULT_PORT<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>hints<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"getaddrinfo failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> iRes <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Create a SOCKET for connecting to server</span>\n    ListenSocket <span class=\"token operator\">=</span> <span class=\"token function\">socket</span><span class=\"token punctuation\">(</span>result<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_family<span class=\"token punctuation\">,</span> result<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_socktype<span class=\"token punctuation\">,</span> result<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_protocol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Check for errors to ensure that the socket is valid socket</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ListenSocket <span class=\"token operator\">==</span> INVALID_SOCKET<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Error at socket():\"</span><span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">freeaddrinfo</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 3. Bind socket</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Setup the TCP listening socket</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">,</span> result<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_addr<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>result<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_addrlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"bind failed with error: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">freeaddrinfo</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// free memory allocated by getaddrinfo() for address information</span>\n    <span class=\"token function\">freeaddrinfo</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 4. Listening on a Socket</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">,</span> SOMAXCONN<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Listen failed with error: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 5. Accepting a Connetion</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Accept a client socket</span>\n    ClientSocket <span class=\"token operator\">=</span> <span class=\"token function\">accept</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ClientSocket <span class=\"token operator\">==</span> INVALID_SOCKET<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"accept failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// No longer need server socket</span>\n    <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ListenSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 6. Receiving and Sending Data on the Server</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Receive until the peer shuts down the connection</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        iRes <span class=\"token operator\">=</span> <span class=\"token function\">recv</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">,</span> recvbuf<span class=\"token punctuation\">,</span> recvbuflen<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Bytes received: \"</span> <span class=\"token operator\">&lt;&lt;</span> iRes <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// Echo the buffr back to the sender</span>\n            iSendRes <span class=\"token operator\">=</span> <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">,</span> recvbuf<span class=\"token punctuation\">,</span> iRes<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iSendRes <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"send failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n                <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Bytes sent: \"</span> <span class=\"token operator\">&lt;&lt;</span> iSendRes <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            cout <span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"recv failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 7.Disconneting the Server</span>\n    <span class=\"token comment\" spellcheck=\"true\">// shutdown the send half of the connetiong since no more data will be sent</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">,</span> SD_SEND<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"shutdown failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// cleanup</span>\n    <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ClientSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"4-2-Client\"><a href=\"#4-2-Client\" class=\"headerlink\" title=\"4.2 Client\"></a>4.2 Client</h3><pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// FileName: client.cpp</span>\n<span class=\"token comment\" spellcheck=\"true\">// Description: Create client socket application</span>\n<span class=\"token comment\" spellcheck=\"true\">// Author: Jiejing.Ma</span>\n<span class=\"token comment\" spellcheck=\"true\">// Update: 2020/12/11</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">undef</span> UNICODE</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> WIN32_LEAN_AND_MEAN</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> WIN32_LEAN_AND_MEAN</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span> </span><span class=\"token comment\" spellcheck=\"true\">// !WIN32_LEAN_AND_MEAN</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;Windows.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;WinSock2.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;WS2tcpip.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iphlpapi.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Need to link with Ws2_32.li, Mswsock.lib, Advapi32.lib</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> comment(lib,\"Ws2_32.lib\")</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> comment(lib,\"Mswsock.lib\")</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> comment(lib,\"Advapi32.lib\")</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> DEFAULT_BUFLEN 512</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> DEFAULT_PORT \"27015\"</span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span> argv<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    WSADATA wsaData<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> iRes<span class=\"token punctuation\">;</span>\n\n    SOCKET ConnectSocket  <span class=\"token operator\">=</span> INVALID_SOCKET<span class=\"token punctuation\">;</span>\n\n    addrinfo hints<span class=\"token punctuation\">;</span>\n    addrinfo<span class=\"token operator\">*</span> result <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>ptr<span class=\"token operator\">=</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>sendbuf<span class=\"token operator\">=</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> recvbuf<span class=\"token punctuation\">[</span>DEFAULT_BUFLEN<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> recvbuflen <span class=\"token operator\">=</span> DEFAULT_BUFLEN<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 1. Initialize WinSock</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token function\">WSAStartup</span><span class=\"token punctuation\">(</span><span class=\"token function\">MAKEWORD</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>wsaData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"WSAStartup failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> iRes <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 2. Create socket</span>\n    <span class=\"token function\">ZeroMemory</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>hints<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>hints<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_family <span class=\"token operator\">=</span> AF_UNSPEC<span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_protocol <span class=\"token operator\">=</span> IPPROTO_TCP<span class=\"token punctuation\">;</span>\n    hints<span class=\"token punctuation\">.</span>ai_socktype <span class=\"token operator\">=</span> SOCK_STREAM<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Resolve the server address and port</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token function\">getaddrinfo</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> DEFAULT_PORT<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>hints<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"getaddrinfo failed:\"</span> <span class=\"token operator\">&lt;&lt;</span> iRes <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Attempt to connect to an address until one succeeds</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>ptr <span class=\"token operator\">=</span> result<span class=\"token punctuation\">;</span> ptr <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> ptr <span class=\"token operator\">=</span> ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_next<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Create a SOCKET for connecting to server    </span>\n        ConnectSocket  <span class=\"token operator\">=</span> <span class=\"token function\">socket</span><span class=\"token punctuation\">(</span>ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_family<span class=\"token punctuation\">,</span> ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_socktype<span class=\"token punctuation\">,</span> ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_protocol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ConnectSocket  <span class=\"token operator\">==</span> INVALID_SOCKET<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Error at socket():\"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 3.Connect to Server</span>\n        iRes <span class=\"token operator\">=</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>ConnectSocket <span class=\"token punctuation\">,</span> ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_addr<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>ptr<span class=\"token operator\">-</span><span class=\"token operator\">></span>ai_addrlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ConnectSocket <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            ConnectSocket  <span class=\"token operator\">=</span> INVALID_SOCKET<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">freeaddrinfo</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ConnectSocket  <span class=\"token operator\">==</span> INVALID_SOCKET<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Unable to connect to server!\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 4. Send and Receive data</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Send an initial buffer</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>ConnectSocket <span class=\"token punctuation\">,</span> sendbuf<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>sendbuf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"send faild: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ConnectSocket <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Bytes sent: \"</span> <span class=\"token operator\">&lt;&lt;</span> iRes <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// shutdown the connection for sending since no more data will be sent</span>\n    <span class=\"token comment\" spellcheck=\"true\">// the client can still use the ConnectSocket for receiving data</span>\n    iRes <span class=\"token operator\">=</span> <span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span>ConnectSocket <span class=\"token punctuation\">,</span> SD_SEND<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"shutdown failed: \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ConnectSocket <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    iRes <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iRes<span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        iRes <span class=\"token operator\">=</span> <span class=\"token function\">recv</span><span class=\"token punctuation\">(</span>ConnectSocket <span class=\"token punctuation\">,</span> recvbuf<span class=\"token punctuation\">,</span> recvbuflen<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Bytes received: %d\\n\"</span><span class=\"token punctuation\">,</span> iRes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iRes <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Connection closed\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"recv failed: %d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">WSAGetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 5. Disconnect</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cleanup</span>\n    <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>ConnectSocket <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">WSACleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/11/09/B7xRsI.jpg","name":"GitHub","introduction":"My github page","url":"https://github.com/MolianWH","title":"前去学习"},{"avatar":"https://s1.ax1x.com/2020/11/09/B75YnJ.jpg","name":"MoL-CSDN","introduction":"Just for fun","url":"https://me.csdn.net/weixin_38369492","title":"前去学习"}]}},"excerpt":"","more":"<p>本文详细介绍在Windows 10下利用Winsock创建socket server和client应用步骤和源码。项目源码可以到我的<a href=\"https://github.com/MolianWH/CommutionTools/tree/main/Socket/SocketWin\">github</a>上下载。在该仓库中，我准备将所有有关通信方式的源码做成工具包，便于以后开发直接使用。本文还可以在我的<a href=\"https://blog.csdn.net/weixin_38369492/article/details/111032276\">CSND</a>上查看。</p>\n<hr>\n<h2 id=\"1-基本流程\"><a href=\"#1-基本流程\" class=\"headerlink\" title=\"1. 基本流程\"></a>1. 基本流程</h2><p>创建TCP/IP流的server/client通用步骤如下：</p>\n<h3 id=\"1-1-Server和Client创建流程\"><a href=\"#1-1-Server和Client创建流程\" class=\"headerlink\" title=\"1.1 Server和Client创建流程\"></a>1.1 Server和Client创建流程</h3><p><strong>Server</strong></p>\n<ol>\n<li>初始化Winsock</li>\n<li>创建socket</li>\n<li>绑定socket</li>\n<li>监听客户端socket</li>\n<li>接受客户端连接请求</li>\n<li>接收和发送数据</li>\n<li> 断开连接</li>\n</ol>\n<p><strong>Client</strong></p>\n<ol>\n<li>初始化Winsock</li>\n<li>创建socket</li>\n<li>连接服务端</li>\n<li>发送和接收数据</li>\n<li>断开连接</li>\n</ol>\n<h3 id=\"1-2-创建Winsock应用步骤\"><a href=\"#1-2-创建Winsock应用步骤\" class=\"headerlink\" title=\"1.2 创建Winsock应用步骤\"></a>1.2 创建Winsock应用步骤</h3><p>创建一个最基础的Winsock应用需要以下几步</p>\n<ol>\n<li>创建一个空项目</li>\n<li>添加一个空的C++ source文件到项目中</li>\n<li>引用Microsoft Windows SDK 的Include、Lib和Src目录</li>\n<li>确保项目连接Winsock库文件：<code>#pragma comment(lib, Ws2_32.lib)</code></li>\n<li>编写Winsock应用程序。使用Winsock API需要包含两个头文件：<strong>Winsock2.h</strong>和<strong>Ws2tcpip.h</strong>。前者包含Winsock的大多数函数、结构体、定义；后者包含在WinSock 2中关于TCP/IP协议的用于检索IP地址的新函数和结构。</li>\n</ol>\n<p>通常一个Winsock应用的头部应该这样写：</p>\n<pre><code class=\"cpp\">#include &lt;WinSock2.h&gt;\n#include &lt;WS2tcpip.h&gt;\n#include &lt;stdio.h&gt;\n\n#pragma comment(lib, &quot;Ws2_32.lib&quot;)\n\nint main() &#123;\n  return 0;\n&#125;</code></pre>\n<blockquote>\n<p><strong>Note</strong></p>\n<ul>\n<li>如果使用ip helper APIs，需要包含Iphlpapi.h。且WinSock2.h需要在其前面。</li>\n<li>Winsock2.h包含了Windows.h一些核心内容，所以通常不需要再包含Windows.h了</li>\n<li>如果要包含Windows.h，必须放在Winsock2.h前，并且要使用<code>#define WIN32_LEAN_AND_MEAN</code>。这是因为Windows.h中包含了Winsock.h（第一个版本），会和Winsock2.h冲突，使用该预定义会避免用Winsock.h</li>\n</ul>\n</blockquote>\n<p>所以一个升级版的头部应该这样写：</p>\n<pre><code class=\"cpp\">#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif // !WIN32_LEAN_AND_MEAN\n\n#include &lt;Windows.h&gt;\n#include &lt;WinSock2.h&gt;  // socket\n#include &lt;WS2tcpip.h&gt;  // TCP/IP\n#include &lt;iphlpapi.h&gt;  // ip helper APIs\n#include &lt;stdio.h&gt;\n\n// Link to Ws2_32.lib\n#pragma comment(lib,&quot;Ws2_32.lib&quot;)\n\nint main() &#123;\n  return 0;\n&#125;</code></pre>\n<h3 id=\"1-3-初始化Winsock\"><a href=\"#1-3-初始化Winsock\" class=\"headerlink\" title=\"1.3 初始化Winsock\"></a>1.3 初始化Winsock</h3><p>所有调用Winsock函数的进程(应用程序或DLL)必须在调用其他Winsock函数之前初始化Windows socket DLL再使用。这也确保了系统上支持Winsock。</p>\n<ol>\n<li>创建WSADATA对象<pre><code class=\"cpp\">WSADATA wsaData;</code></pre>\n</li>\n<li>调用WSAStartup，返回整数值，并通过该值检查错误。 <pre><code class=\"cpp\"> // Initialize WinSock\n int iRes = WSAStartup(MAKEWORD(2, 2), &amp;wasData);\n if (iRes != 0)\n &#123;\n         printf(&quot;WSAStartup failed: %d\\n&quot; , iRes);\n         return 1;\n &#125; </code></pre>\n</li>\n</ol>\n<p>调用WSAStartup函数来启动WS2_32.dll的使用。</p>\n<p>WSADATA结构包含关于Windows套接字实现的信息。WSAStartup的MAKEWORD(2,2)参数在系统上请求Winsock的2.2版本，并将传递的版本设置为调用者可以使用的Windows套接字支持的最高版本。</p>\n<h2 id=\"2-创建server\"><a href=\"#2-创建server\" class=\"headerlink\" title=\"2. 创建server\"></a>2. 创建server</h2><p>参考<a href=\"#11_ServerClient_8\">1.1</a>中的步骤，在<a href=\"#13_Winsock_73\">1.3</a>中已经说明了如何初始化Winsock，下面应该是创建server socket</p>\n<h3 id=\"2-1-创建server-socket\"><a href=\"#2-1-创建server-socket\" class=\"headerlink\" title=\"2.1 创建server socket\"></a>2.1 创建server socket</h3><ol>\n<li> 使用<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo\">getaddrinfo()</a>确定sockaddr结构体值，getaddrinfo中使用<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/ws2def/ns-ws2def-addrinfoa\">addrinfo</a>结构体。</li>\n</ol>\n<p>使用的信息包含以下内容：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AF_INET</td>\n<td>指定IPv4地址族</td>\n</tr>\n<tr>\n<td>SOCK_STREAM</td>\n<td>指定一个流套接字</td>\n</tr>\n<tr>\n<td>IPPROTO_TCP</td>\n<td>指定TCP协议</td>\n</tr>\n<tr>\n<td>AI_PASSIVE</td>\n<td>AI_PASSIVE标志表示调用者打算在调用bind函数时使用返回的套接字地址结构。当AI_PASSIVE标志被设置并且getaddrinfo函数的nodename参数是一个空指针时，套接字地址结构的IP地址部分被设置为IPv4地址INADDR_ANY或IPv6地址IN6ADDR_ANY_INIT。</td>\n</tr>\n</tbody></table>\n<p>代码如下：</p>\n<pre><code class=\"cpp\">   #define DEFAULT_PORT &quot;27015&quot;\n\n// 2. create server socket\n    addrinfo* result = NULL, * ptr = NULL, hints;\n\n    ZeroMemory(&amp;hints, sizeof(hints));\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n    hints.ai_flags = AI_PASSIVE;\n\n    // Resolve the local address and port to be used by the server\n    iRes = getaddrinfo(NULL, DEFAULT_PORT, &amp;hints, &amp;result);\n    if (iRes != 0)\n    &#123;\n        printf(&quot;getaddrinfo failed:%d\\n&quot;,iRes);\n        WSACleanup();\n        return 1;\n    &#125;</code></pre>\n<div id=\"refer-anchor-212\"></div>\n\n<ol start=\"2\">\n<li>创建SOCKET对象ListenSocket ，用来监听客户端连接请求。</li>\n</ol>\n<pre><code class=\"cpp\">SOCKET ListenSocket = INVALID_SOCKET;</code></pre>\n<div id=\"refer-anchor-213\"></div>\n\n<ol start=\"3\">\n<li>调用socket函数，返回值赋给ListenSocket 。</li>\n</ol>\n<p>对于server，使用getaddrinfo返回的第一个IP地址，该IP地址与在提示参数中指定的地址家族、套接字类型和协议相匹配</p>\n<p>如果想监听IPv6，ai_family = AF_INET6；</p>\n<p>如果想同时监听IPv4和IPv6，必须创建两个监听套接字，一个监听IPv6，一个监听IPv4。应用程序必须分别处理这两个套接字。</p>\n<pre><code class=\"cpp\">ListenSocket = socket(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol);</code></pre>\n<div id=\"refer-anchor-214\"></div>\n\n<ol start=\"4\">\n<li>检查错误，确保socket是一个有效的套接字</li>\n</ol>\n<pre><code class=\"cpp\">    // Check for errors to ensure that the socket is valid socket\n    if (ListenSocket == INVALID_SOCKET)\n    &#123;\n        cout &lt;&lt; &quot;Error at socket():&quot;&lt;&lt; WSAGetLastError() &lt;&lt; endl;\n        freeaddrinfo(result);\n        WSACleanup();\n        return 1;\n    &#125;</code></pre>\n<h3 id=\"2-2-绑定socket\"><a href=\"#2-2-绑定socket\" class=\"headerlink\" title=\"2.2 绑定socket\"></a>2.2 绑定socket</h3><p>server如果要接收client连接请求，需要绑定一个网络地址。下面阐述如果绑定一个创建了IP地址和端口的socket。client使用IP地址和端口连接主机。</p>\n<ol>\n<li>bind并检查错误</li>\n</ol>\n<p>sockaddr结构保存有关地址家族、IP地址和端口号的信息。</p>\n<p>调用<code>bind()</code>，传递创建的socket和getaddrinfo函数返回的sockaddr结构作为参数。检查一般性错误。</p>\n<pre><code class=\"cpp\">    // 3. Bind socket\n    // Setup the TCP listening socket\n    iRes = bind(ListenSocket, result-&gt;ai_addr, (int)result-&gt;ai_addrlen);\n    if (iRes == SOCKET_ERROR)\n    &#123;\n        cout &lt;&lt; &quot;bind failed with error: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n        freeaddrinfo(result);\n        closesocket(ListenSocket);\n        WSACleanup();\n        return 1;\n    &#125;</code></pre>\n<ol start=\"2\">\n<li>释放存放地址信息的内存空间</li>\n</ol>\n<p>一旦绑定完成，getaddrinfo获取的地址信息就不在需要了，使用freeaddrinfo释放分配的内存。</p>\n<pre><code class=\"cpp\">    // free memory allocated by getaddrinfo() for address information\n    freeaddrinfo(result);</code></pre>\n<h3 id=\"2-3-监听\"><a href=\"#2-3-监听\" class=\"headerlink\" title=\"2.3 监听\"></a>2.3 监听</h3><p>socket绑定IP地址和端口后，需要监听该IP和端口发送的连接请求。</p>\n<p>调用<code>listen()</code>将创建的socket和待定的值(待定连接队列的最大长度)作为参数传递。在本例中，backlog参数被设置为SOMAXCONN。此值是一个特殊常量，指示此套接字的Winsock提供程序允许队列中挂起连接的最大合理数量。检查返回值是否有一般错误。</p>\n<h3 id=\"2-4-接受连接请求\"><a href=\"#2-4-接受连接请求\" class=\"headerlink\" title=\"2.4 接受连接请求\"></a>2.4 接受连接请求</h3><p>监听时若收到连接请求，需处理该请求。</p>\n<ol>\n<li>创建临时SOCKET对象ClientSocket接受client的连接</li>\n</ol>\n<pre><code class=\"cpp\">// 5. Accepting a Connetion\n// Create temporary ClientSocket for accepting connetions from clients\nSOCKET ClientSocket = INVALID_SOCKET;</code></pre>\n<ol start=\"2\">\n<li>通常server要监听多个客户端的连接请求。对一个高性能的server来说，需要使用多线程处理多客户端请求。</li>\n</ol>\n<p>Winsock有多种处理多客户端连接请求的技术。一种编程技术是创建一个连续循环，使用<code>listen()</code>检查连接请求(参见<a href=\"#23__195\">2.3</a>)。如果出现连接请求，应用程序将调用<code>accept、AcceptEx或WSAAccept</code>函数，并将工作传递给另一个线程来处理请求。还可以使用其他几种编程技术。</p>\n<blockquote>\n<p><strong>Note</strong><br>这个基本示例非常简单，并且不使用多线程。该示例还只侦听和接受单个连接。</p>\n</blockquote>\n<pre><code class=\"cpp\">    // Accept a client socket\n    ClientSocket = accept(ListenSocket, NULL, NULL);\n    if (ClientSocket == INVALID_SOCKET)\n    &#123;\n        cout &lt;&lt; &quot;accept failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n        closesocket(ListenSocket);\n        WSACleanup();\n        return 1;\n    &#125;</code></pre>\n<h3 id=\"2-5-接收好发送数据\"><a href=\"#2-5-接收好发送数据\" class=\"headerlink\" title=\"2.5 接收好发送数据\"></a>2.5 接收好发送数据</h3><p>使用<code>recv()</code>和<code>send()</code>接收和发送消息</p>\n<pre><code class=\"cpp\">#define DEFAULT_BUFLEN 512\n\n    // 6. Receiving and Sending Data on the Server\n    char recvbuf[DEFAULT_BUFLEN];\n    int iSendRes;\n    int recvbuflen = DEFAULT_BUFLEN;\n\n    iRes = 1;\n    // Receive until the peer shuts down the connection\n    while (iRes &gt; 0)\n    &#123;\n        iRes = recv(ClientSocket, recvbuf, recvbuflen, 0);\n        if (iRes &gt; 0)\n        &#123;\n            cout &lt;&lt; &quot;Bytes received: &quot; &lt;&lt; iRes &lt;&lt; endl;\n\n            // Echo the buffr back to the sender\n            iSendRes = send(ClientSocket, recvbuf, iRes, 0);\n            if (iSendRes == SOCKET_ERROR)\n            &#123;\n                cout &lt;&lt; &quot;send failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n                closesocket(ClientSocket);\n                WSACleanup();\n                return 1;\n            &#125;\n            cout &lt;&lt; &quot;Bytes sent: &quot; &lt;&lt; iSendRes &lt;&lt; endl;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt;&quot;recv failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n            closesocket(ClientSocket);\n            WSACleanup();\n            return 1;\n        &#125;\n    &#125;</code></pre>\n<h3 id=\"2-6-断开连接\"><a href=\"#2-6-断开连接\" class=\"headerlink\" title=\"2.6 断开连接\"></a>2.6 断开连接</h3><ol>\n<li><p>当server完成向client发送数据时，可以调用<code>shutdown()</code>，指定<code>SD_SEND</code>来关闭套接字的发送端。这允许客户端释放此套接字的一些资源。服务器应用程序仍然可以接收套接字上的数据。</p>\n<pre><code class=\"cpp\"> // 7.Disconneting the Server\n // shutdown the send half of the connetiong since no more data will be sent\n iRes = shutdown(ClientSocket, SD_SEND);\n if (iRes == SOCKET_ERROR)\n &#123;\n     cout &lt;&lt; &quot;shutdown failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n     closesocket(ClientSocket);\n     WSACleanup();\n     return 1;\n &#125;</code></pre>\n</li>\n<li><p>当客户端应用程序完成接收数据时，将调用<code>closesocket()</code>来关闭套接字。</p>\n</li>\n</ol>\n<p>当客户端应用程序使用Windows套接字DLL完成时，WSACleanup函数被调用来释放资源。</p>\n<pre><code class=\"cpp\">    // cleanup\n    closesocket(ClientSocket);\n    WSACleanup();\n    return 0;</code></pre>\n<h2 id=\"3-创建client\"><a href=\"#3-创建client\" class=\"headerlink\" title=\"3. 创建client\"></a>3. 创建client</h2><p>与第2节大体相似。</p>\n<h3 id=\"3-1-创建client-socket\"><a href=\"#3-1-创建client-socket\" class=\"headerlink\" title=\"3.1 创建client socket\"></a>3.1 创建client socket</h3><ol>\n<li>对于这个应用程序，Internet地址族是未指定的<code>AF_UNSPEC</code>，因此可以返回IPv6或IPv4地址。其余与<a href=\"#21_server_socket_99\">2.1</a>的1基本相同</li>\n</ol>\n<pre><code class=\"cpp\">struct addrinfo *result = NULL,\n                *ptr = NULL,\n                hints;\n\nZeroMemory( &amp;hints, sizeof(hints) );\nhints.ai_family = AF_UNSPEC;\nhints.ai_socktype = SOCK_STREAM;\nhints.ai_protocol = IPPROTO_TCP;</code></pre>\n<ol start=\"2\">\n<li>与<a href=\"#21_server_socket_99\">2.1</a>的1不同的是，请求在命令行中传递的服务器名称的IP地址。</li>\n</ol>\n<pre><code class=\"cpp\">#define DEFAULT_PORT &quot;27015&quot;\n\n// Resolve the server address and port\niResult = getaddrinfo(argv[1], DEFAULT_PORT, &amp;hints, &amp;result);\nif (iResult != 0) &#123;\n    printf(&quot;getaddrinfo failed: %d\\n&quot;, iResult);\n    WSACleanup();\n    return 1;\n&#125;</code></pre>\n<ol start=\"3\">\n<li>同<a href=\"#21_server_socket_99\">2.1</a>的<a href=\"#refer-anchor-212\">2</a></li>\n</ol>\n<pre><code class=\"cpp\">SOCKET ConnectSocket = INVALID_SOCKET;</code></pre>\n<ol start=\"4\">\n<li>同<a href=\"#21_server_socket_99\">2.1</a>的<a href=\"#refer-anchor-213\">3</a></li>\n</ol>\n<pre><code class=\"cpp\">// Attempt to connect to the first address returned by\n// the call to getaddrinfo\nptr=result;\n\n// Create a SOCKET for connecting to server\nConnectSocket = socket(ptr-&gt;ai_family, ptr-&gt;ai_socktype, \n    ptr-&gt;ai_protocol);</code></pre>\n<ol start=\"5\">\n<li>同<a href=\"#21_server_socket_99\">2.1</a>的<a href=\"#refer-anchor-214\">4</a></li>\n</ol>\n<pre><code class=\"cpp\">if (ConnectSocket == INVALID_SOCKET) &#123;\n    printf(&quot;Error at socket(): %ld\\n&quot;, WSAGetLastError());\n    freeaddrinfo(result);\n    WSACleanup();\n    return 1;\n&#125;</code></pre>\n<h3 id=\"3-2-连接server\"><a href=\"#3-2-连接server\" class=\"headerlink\" title=\"3.2 连接server\"></a>3.2 连接server</h3><p>客户端想要通信，需要连接server。</p>\n<p>调用<code>connect()</code>，设置参数为创建的socket和sockaddr结构，并检查错误。</p>\n<pre><code class=\"cpp\">// Connect to server.\niResult = connect( ConnectSocket, ptr-&gt;ai_addr, (int)ptr-&gt;ai_addrlen);\nif (iResult == SOCKET_ERROR) &#123;\n    closesocket(ConnectSocket);\n    ConnectSocket = INVALID_SOCKET;\n&#125;\n\n// Should really try the next address returned by getaddrinfo\n// if the connect call failed\n// But for this simple example we just free the resources\n// returned by getaddrinfo and print an error message\n\nfreeaddrinfo(result);\n\nif (ConnectSocket == INVALID_SOCKET) &#123;\n    printf(&quot;Unable to connect to server!\\n&quot;);\n    WSACleanup();\n    return 1;\n&#125;</code></pre>\n<p>在本例中，<code>getaddrinfo()</code>返回的第一个IP地址用于指定传递给连接的<code>sockaddr</code>结构。如果对第一个IP地址的连接调用失败，那么尝试从<code>getaddrinfo()</code>返回的链表中的下一个<code>addrinfo</code>结构。</p>\n<p>sockaddr结构中指定的信息包括:</p>\n<ul>\n<li>客户机将尝试连接到的服务器的IP地址。</li>\n<li>客户机将连接到的服务器端口号。当</li>\n<li>客户端调用<code>getaddrinfo()</code>时，该端口被指定为端口27015。</li>\n</ul>\n<h3 id=\"3-3-发送接收数据\"><a href=\"#3-3-发送接收数据\" class=\"headerlink\" title=\"3.3 发送接收数据\"></a>3.3 发送接收数据</h3><pre><code class=\"cpp#define\">int recvbuflen = DEFAULT_BUFLEN;\n\nconst char *sendbuf = &quot;this is a test&quot;;\nchar recvbuf[DEFAULT_BUFLEN];\n\nint iResult;\n\n// Send an initial buffer\niResult = send(ConnectSocket, sendbuf, (int) strlen(sendbuf), 0);\nif (iResult == SOCKET_ERROR) &#123;\n    printf(&quot;send failed: %d\\n&quot;, WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n&#125;\n\nprintf(&quot;Bytes Sent: %ld\\n&quot;, iResult);\n\n// shutdown the connection for sending since no more data will be sent\n// the client can still use the ConnectSocket for receiving data\niResult = shutdown(ConnectSocket, SD_SEND);\nif (iResult == SOCKET_ERROR) &#123;\n    printf(&quot;shutdown failed: %d\\n&quot;, WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n&#125;\n\n// Receive data until the server closes the connection\ndo &#123;\n    iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0);\n    if (iResult &gt; 0)\n        printf(&quot;Bytes received: %d\\n&quot;, iResult);\n    else if (iResult == 0)\n        printf(&quot;Connection closed\\n&quot;);\n    else\n        printf(&quot;recv failed: %d\\n&quot;, WSAGetLastError());\n&#125; while (iResult &gt; 0);</code></pre>\n<h3 id=\"3-4-断开连接\"><a href=\"#3-4-断开连接\" class=\"headerlink\" title=\"3.4 断开连接\"></a>3.4 断开连接</h3><p>同<a href=\"#26__280\">2.6</a></p>\n<h2 id=\"4-完整应用代码\"><a href=\"#4-完整应用代码\" class=\"headerlink\" title=\"4. 完整应用代码\"></a>4. 完整应用代码</h2><h3 id=\"4-1-Server\"><a href=\"#4-1-Server\" class=\"headerlink\" title=\"4.1 Server\"></a>4.1 Server</h3><pre><code class=\"cpp\">// FileName: server.cpp\n// Description: Create server socket application\n// Author: Jiejing.Ma\n// Update: 2020/12/11\n\n#undef UNICODE\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif // !WIN32_LEAN_AND_MEAN\n\n#include &lt;Windows.h&gt;\n#include &lt;WinSock2.h&gt;  // socket\n#include &lt;WS2tcpip.h&gt;  // TCP/IP\n#include &lt;iphlpapi.h&gt;  // ip helper APIs\n#include &lt;stdlib.h&gt;\n#include &lt;iostream&gt;\n\n// Link to Ws2_32.lib\n#pragma comment(lib,&quot;Ws2_32.lib&quot;)\n\n#define DEFAULT_BUFLEN 512\n#define DEFAULT_PORT &quot;27015&quot;\n\nusing namespace std;\n\nint main()\n&#123;\n    WSADATA wasData;\n    int iRes;\n\n    // Create a SOCKET object to listen for client connections\n    SOCKET ListenSocket = INVALID_SOCKET;\n    // Create temporary ClientSocket for accepting connetions from clients\n    SOCKET ClientSocket = INVALID_SOCKET;\n\n    addrinfo* result = NULL;\n    addrinfo hints;\n\n    char recvbuf[DEFAULT_BUFLEN];\n    int iSendRes;\n    int recvbuflen = DEFAULT_BUFLEN;\n\n    // 1. Initialize WinSock\n    iRes = WSAStartup(MAKEWORD(2, 2), &amp;wasData);\n    if (iRes != 0)\n    &#123;\n        cout &lt;&lt; &quot;WSAStartup failed: &quot; &lt;&lt; iRes &lt;&lt; endl;\n        return 1;\n    &#125;\n\n    // 2. Create server socket\n    ZeroMemory(&amp;hints, sizeof(hints));\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n    hints.ai_flags = AI_PASSIVE;\n\n    // Resolve the local address and port to be used by the server\n    iRes = getaddrinfo(NULL, DEFAULT_PORT, &amp;hints, &amp;result);\n    if (iRes != 0)\n    &#123;\n        cout &lt;&lt; &quot;getaddrinfo failed: &quot; &lt;&lt; iRes &lt;&lt; endl;\n        WSACleanup();\n        return 1;\n    &#125;\n\n    // Create a SOCKET for connecting to server\n    ListenSocket = socket(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol);\n    // Check for errors to ensure that the socket is valid socket\n    if (ListenSocket == INVALID_SOCKET)\n    &#123;\n        cout &lt;&lt; &quot;Error at socket():&quot;&lt;&lt; WSAGetLastError() &lt;&lt; endl;\n        freeaddrinfo(result);\n        WSACleanup();\n        return 1;\n    &#125;\n\n    // 3. Bind socket\n    // Setup the TCP listening socket\n    iRes = bind(ListenSocket, result-&gt;ai_addr, (int)result-&gt;ai_addrlen);\n    if (iRes == SOCKET_ERROR)\n    &#123;\n        cout &lt;&lt; &quot;bind failed with error: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n        freeaddrinfo(result);\n        closesocket(ListenSocket);\n        WSACleanup();\n        return 1;\n    &#125;\n    // free memory allocated by getaddrinfo() for address information\n    freeaddrinfo(result);\n\n    // 4. Listening on a Socket\n    if (listen(ListenSocket, SOMAXCONN) == SOCKET_ERROR)\n    &#123;\n        cout &lt;&lt; &quot;Listen failed with error: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n        closesocket(ListenSocket);\n        WSACleanup();\n        return 1;\n    &#125;\n\n    // 5. Accepting a Connetion\n    // Accept a client socket\n    ClientSocket = accept(ListenSocket, NULL, NULL);\n    if (ClientSocket == INVALID_SOCKET)\n    &#123;\n        cout &lt;&lt; &quot;accept failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n        closesocket(ListenSocket);\n        WSACleanup();\n        return 1;\n    &#125;\n\n    // No longer need server socket\n    closesocket(ListenSocket);\n\n    // 6. Receiving and Sending Data on the Server\n    iRes = 1;\n    // Receive until the peer shuts down the connection\n    while (iRes &gt; 0)\n    &#123;\n        iRes = recv(ClientSocket, recvbuf, recvbuflen, 0);\n        if (iRes &gt; 0)\n        &#123;\n            cout &lt;&lt; &quot;Bytes received: &quot; &lt;&lt; iRes &lt;&lt; endl;\n\n            // Echo the buffr back to the sender\n            iSendRes = send(ClientSocket, recvbuf, iRes, 0);\n            if (iSendRes == SOCKET_ERROR)\n            &#123;\n                cout &lt;&lt; &quot;send failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n                closesocket(ClientSocket);\n                WSACleanup();\n                return 1;\n            &#125;\n            cout &lt;&lt; &quot;Bytes sent: &quot; &lt;&lt; iSendRes &lt;&lt; endl;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt;&quot;recv failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n            closesocket(ClientSocket);\n            WSACleanup();\n            return 1;\n        &#125;\n    &#125;\n\n    // 7.Disconneting the Server\n    // shutdown the send half of the connetiong since no more data will be sent\n    iRes = shutdown(ClientSocket, SD_SEND);\n    if (iRes == SOCKET_ERROR)\n    &#123;\n        cout &lt;&lt; &quot;shutdown failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n        closesocket(ClientSocket);\n        WSACleanup();\n        return 1;\n    &#125;\n\n    // cleanup\n    closesocket(ClientSocket);\n    WSACleanup();\n\n    return 0;\n&#125;</code></pre>\n<h3 id=\"4-2-Client\"><a href=\"#4-2-Client\" class=\"headerlink\" title=\"4.2 Client\"></a>4.2 Client</h3><pre><code class=\"cpp\">// FileName: client.cpp\n// Description: Create client socket application\n// Author: Jiejing.Ma\n// Update: 2020/12/11\n\n#undef UNICODE\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif // !WIN32_LEAN_AND_MEAN\n\n#include &lt;Windows.h&gt;\n#include &lt;WinSock2.h&gt;\n#include &lt;WS2tcpip.h&gt;\n#include &lt;iphlpapi.h&gt;\n#include &lt;iostream&gt;\n\n// Need to link with Ws2_32.li, Mswsock.lib, Advapi32.lib\n#pragma comment(lib,&quot;Ws2_32.lib&quot;)\n#pragma comment(lib,&quot;Mswsock.lib&quot;)\n#pragma comment(lib,&quot;Advapi32.lib&quot;)\n\n#define DEFAULT_BUFLEN 512\n#define DEFAULT_PORT &quot;27015&quot;\n\nusing namespace std;\n\nint main(int argc,char ** argv)\n&#123;\n    WSADATA wsaData;\n    int iRes;\n\n    SOCKET ConnectSocket  = INVALID_SOCKET;\n\n    addrinfo hints;\n    addrinfo* result = NULL, *ptr=NULL;\n\n    const char *sendbuf=&quot;hello&quot;;\n    char recvbuf[DEFAULT_BUFLEN];\n    int recvbuflen = DEFAULT_BUFLEN;\n\n    // 1. Initialize WinSock\n    iRes = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);\n    if (iRes != 0)\n    &#123;\n        cout &lt;&lt; &quot;WSAStartup failed: &quot; &lt;&lt; iRes &lt;&lt; endl;\n        return 1;\n    &#125;\n\n    // 2. Create socket\n    ZeroMemory(&amp;hints, sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_protocol = IPPROTO_TCP;\n    hints.ai_socktype = SOCK_STREAM;\n\n    // Resolve the server address and port\n    iRes = getaddrinfo(argv[1], DEFAULT_PORT, &amp;hints, &amp;result);\n    if (iRes != 0)\n    &#123;\n        cout &lt;&lt; &quot;getaddrinfo failed:&quot; &lt;&lt; iRes &lt;&lt; endl;\n        WSACleanup();\n        return 1;\n    &#125;\n\n    // Attempt to connect to an address until one succeeds\n    for (ptr = result; ptr != NULL; ptr = ptr-&gt;ai_next)\n    &#123;\n        // Create a SOCKET for connecting to server    \n        ConnectSocket  = socket(ptr-&gt;ai_family, ptr-&gt;ai_socktype, ptr-&gt;ai_protocol);\n        if (ConnectSocket  == INVALID_SOCKET)\n        &#123;\n            cout &lt;&lt; &quot;Error at socket():&quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n            WSACleanup();\n            return 1;\n        &#125;\n\n        // 3.Connect to Server\n        iRes = connect(ConnectSocket , ptr-&gt;ai_addr, (int)ptr-&gt;ai_addrlen);\n        if (iRes == SOCKET_ERROR)\n        &#123;\n            closesocket(ConnectSocket );\n            ConnectSocket  = INVALID_SOCKET;\n            continue;\n        &#125;\n        break;\n    &#125;\n\n    freeaddrinfo(result);\n\n    if (ConnectSocket  == INVALID_SOCKET)\n    &#123;\n        cout &lt;&lt; &quot;Unable to connect to server!&quot; &lt;&lt; endl;\n        WSACleanup();\n        return 1;\n    &#125;\n    // 4. Send and Receive data\n    // Send an initial buffer\n    iRes = send(ConnectSocket , sendbuf, (int)strlen(sendbuf), 0);\n    if (iRes == SOCKET_ERROR)\n    &#123;\n        cout &lt;&lt; &quot;send faild: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n        closesocket(ConnectSocket );\n        WSACleanup();\n        return 1;\n    &#125;\n    cout &lt;&lt; &quot;Bytes sent: &quot; &lt;&lt; iRes &lt;&lt; endl;\n\n    // shutdown the connection for sending since no more data will be sent\n    // the client can still use the ConnectSocket for receiving data\n    iRes = shutdown(ConnectSocket , SD_SEND);\n    if (iRes == SOCKET_ERROR)\n    &#123;\n        cout &lt;&lt; &quot;shutdown failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl;\n        closesocket(ConnectSocket );\n        WSACleanup();\n        return 1;\n    &#125;\n\n    iRes = 1;\n    while (iRes&gt;0)\n    &#123;\n        iRes = recv(ConnectSocket , recvbuf, recvbuflen, 0);\n        if (iRes &gt; 0)\n            printf(&quot;Bytes received: %d\\n&quot;, iRes);\n        else if (iRes == 0)\n            printf(&quot;Connection closed\\n&quot;);\n        else\n            printf(&quot;recv failed: %d\\n&quot;, WSAGetLastError());\n    &#125;\n\n    // 5. Disconnect\n    // cleanup\n    closesocket(ConnectSocket );\n    WSACleanup();\n\n    return 0;\n&#125;</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckhaklucn0006vp7edsck3x8h","category_id":"ckhaklucq0008vp7e203z06vf","_id":"ckhakluct000cvp7e78qke2i4"},{"post_id":"ckhaklucp0007vp7e02on8v3u","category_id":"ckhaklucs000avp7e2hi07uhl","_id":"ckhakluct000gvp7eeer3hl59"},{"post_id":"cki4lrn540000z77ed6qcdn0v","category_id":"cki4lrn550001z77e497rda35","_id":"cki4lrn570004z77e1gjaczve"},{"post_id":"ckioje2me0000af7ebyqkgz19","category_id":"cki4lrn550001z77e497rda35","_id":"ckioje2mo0002af7e1c48ed6d"}],"PostTag":[{"post_id":"ckhaklucn0006vp7edsck3x8h","tag_id":"ckhaklucr0009vp7ef22575wf","_id":"ckhakluct000evp7e3vc9d24j"},{"post_id":"ckhaklucn0006vp7edsck3x8h","tag_id":"ckhaklucs000bvp7eeszp028v","_id":"ckhakluct000fvp7edixw4tmo"},{"post_id":"ckhaklucp0007vp7e02on8v3u","tag_id":"ckhakluct000dvp7e0n7g7wa0","_id":"ckhaklucu000ivp7eh3mz8xbq"},{"post_id":"ckhaklucp0007vp7e02on8v3u","tag_id":"ckhakluct000hvp7e821w9rgh","_id":"ckhaklucu000jvp7e7qoo0bf3"},{"post_id":"cki4lrn540000z77ed6qcdn0v","tag_id":"cki4lrn560002z77ehsgjb8kr","_id":"cki4lrn570005z77e77tq0m6g"},{"post_id":"cki4lrn540000z77ed6qcdn0v","tag_id":"cki4lrn570003z77edjshg11e","_id":"cki4lrn570006z77e2od45g6w"},{"post_id":"ckioje2me0000af7ebyqkgz19","tag_id":"cki4lrn570003z77edjshg11e","_id":"ckioje2mn0001af7ehxv75eho"}],"Tag":[{"name":"CV","_id":"ckhaklucr0009vp7ef22575wf"},{"name":"目标检测","_id":"ckhaklucs000bvp7eeszp028v"},{"name":"视频分析","_id":"ckhakluct000dvp7e0n7g7wa0"},{"name":"DeepStream","_id":"ckhakluct000hvp7e821w9rgh"},{"name":"共享内存","_id":"cki4lrn560002z77ehsgjb8kr"},{"name":"socket","_id":"cki4lrn570003z77edjshg11e"}]}}